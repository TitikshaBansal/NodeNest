{
  "version": 3,
  "sources": ["../../../src/trigger/tasks/extractFrame.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk\";\r\nimport { exec } from \"child_process\";\r\nimport { promisify } from \"util\";\r\nimport * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport * as os from \"os\";\r\nimport { Transloadit } from \"transloadit\";\r\n\r\nconst execAsync = promisify(exec);\r\n\r\n// Helper to poll assembly status until complete\r\nasync function waitForAssembly(statusUrl: string, maxAttempts = 60): Promise<any> {\r\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n    const response = await fetch(statusUrl);\r\n    const status = await response.json();\r\n\r\n    if (status.ok === \"ASSEMBLY_COMPLETED\") {\r\n      return status;\r\n    }\r\n\r\n    if (status.ok === \"ASSEMBLY_CANCELED\" || status.ok === \"ASSEMBLY_FAILED\") {\r\n      throw new Error(`Assembly failed: ${status.error || status.message}`);\r\n    }\r\n\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n  }\r\n\r\n  throw new Error(\"Assembly timed out\");\r\n}\r\n\r\ninterface ExtractFramePayload {\r\n  nodeId: string;\r\n  workflowRunId: string;\r\n  inputs: {\r\n    videoUrl: string;\r\n    timestamp: string | number; // seconds or \"50%\"\r\n  };\r\n}\r\n\r\nexport const extractFrame = task({\r\n  id: \"extract-frame\",\r\n  retry: {\r\n    maxAttempts: 2,\r\n  },\r\n\r\n  run: async (payload: ExtractFramePayload) => {\r\n    const { nodeId, workflowRunId, inputs } = payload;\r\n    const { videoUrl, timestamp } = inputs;\r\n\r\n    const startTime = Date.now();\r\n    let tempDir: string | null = null;\r\n\r\n    try {\r\n      const transloadit = new Transloadit({\r\n        authKey: process.env.TRANSLOADIT_AUTH_KEY!,\r\n        authSecret: process.env.TRANSLOADIT_AUTH_SECRET!,\r\n      });\r\n\r\n      // Create temp directory\r\n      tempDir = await fs.mkdtemp(path.join(os.tmpdir(), \"extract-\"));\r\n      const tempInputPath = path.join(tempDir, \"input.mp4\");\r\n      const tempOutputPath = path.join(tempDir, \"frame.jpg\");\r\n\r\n      // Download video\r\n      const videoResponse = await fetch(videoUrl);\r\n      const videoBuffer = await videoResponse.arrayBuffer();\r\n      await fs.writeFile(tempInputPath, Buffer.from(videoBuffer));\r\n\r\n      // Resolve timestamp\r\n      let timestampSeconds: number;\r\n\r\n      if (typeof timestamp === \"string\" && timestamp.endsWith(\"%\")) {\r\n        const durationCommand =\r\n          `ffprobe -v error -show_entries format=duration ` +\r\n          `-of default=noprint_wrappers=1:nokey=1 \"${tempInputPath}\"`;\r\n\r\n        const durationOutput = await execAsync(durationCommand);\r\n        const videoDuration = parseFloat(durationOutput.stdout.trim());\r\n\r\n        const percentage = parseFloat(timestamp.replace(\"%\", \"\"));\r\n        timestampSeconds = (percentage / 100) * videoDuration;\r\n      } else {\r\n        timestampSeconds = Number(timestamp) || 0;\r\n      }\r\n\r\n      // Extract frame\r\n      const ffmpegCommand =\r\n        `ffmpeg -i \"${tempInputPath}\" -ss ${timestampSeconds} ` +\r\n        `-vframes 1 \"${tempOutputPath}\" -y`;\r\n\r\n      await execAsync(ffmpegCommand);\r\n\r\n      // Upload frame to Transloadit\r\n      const assembly = await transloadit.createAssembly({\r\n        files: {\r\n          image: tempOutputPath,\r\n        },\r\n        params: {\r\n          steps: {\r\n            \":original\": {\r\n              robot: \"/upload/handle\",\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Wait for upload to complete\r\n      const uploadResult = await waitForAssembly(assembly.status_endpoint as string);\r\n\r\n      // Get URL\r\n      let outputUrl: string | null = null;\r\n\r\n      if (uploadResult.results?.[\":original\"]?.[0]?.ssl_url) {\r\n        outputUrl = uploadResult.results[\":original\"][0].ssl_url;\r\n      } else if (uploadResult.results?.[\":original\"]?.[0]?.url) {\r\n        outputUrl = uploadResult.results[\":original\"][0].url;\r\n      } else if (uploadResult.uploads?.[0]?.ssl_url) {\r\n        outputUrl = uploadResult.uploads[0].ssl_url;\r\n      } else if (uploadResult.uploads?.[0]?.url) {\r\n        outputUrl = uploadResult.uploads[0].url;\r\n      }\r\n\r\n      if (!outputUrl) {\r\n        throw new Error(\"Transloadit upload failed - no URL found.\");\r\n      }\r\n\r\n      const duration = Date.now() - startTime;\r\n\r\n      return {\r\n        success: true,\r\n        output: outputUrl,\r\n        duration,\r\n        nodeId,\r\n        workflowRunId,\r\n      };\r\n    } catch (error: any) {\r\n      const duration = Date.now() - startTime;\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message || \"Failed to extract frame\",\r\n        duration,\r\n        nodeId,\r\n        workflowRunId,\r\n      };\r\n    } finally {\r\n      // Cleanup temp directory\r\n      if (tempDir) {\r\n        try {\r\n          await fs.rm(tempDir, { recursive: true, force: true });\r\n        } catch {}\r\n      }\r\n    }\r\n  },\r\n});"],
  "mappings": "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",
  "names": []
}
