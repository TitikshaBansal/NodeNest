import {
  external_exports
} from "./chunk-6NN2F7ES.mjs";
import {
  __commonJS,
  __name,
  __require,
  __toESM,
  init_esm
} from "./chunk-E5ZCWD2M.mjs";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_esm();
    var s = 1e3;
    var m = s * 60;
    var h2 = m * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    __name(parse2, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_esm();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug3, "debug");
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_esm();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var os2 = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream2) {
      const level = supportsColor(stream2, stream2 && stream2.isTTY);
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    init_esm();
    var tty = __require("tty");
    var util = __require("util");
    exports2.init = init2;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log3(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log3, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init2(debug3) {
      debug3.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug3.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    __name(init2, "init");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    init_esm();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    init_esm();
    var Stream = __require("stream").Stream;
    var util = __require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    __name(DelayedStream, "DelayedStream");
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return this.source.readable;
      }, "get")
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    init_esm();
    var util = __require("util");
    var Stream = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    __name(CombinedStream, "CombinedStream");
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream2) {
      return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
    };
    CombinedStream.prototype.append = function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        if (!(stream2 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream2, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream2.on("data", this._checkDataSize.bind(this));
          stream2 = newStream;
        }
        this._handleErrors(stream2);
        if (this.pauseStreams) {
          stream2.pause();
        }
      }
      this._streams.push(stream2);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream2 = this._streams.shift();
      if (typeof stream2 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream2 !== "function") {
        this._pipeNext(stream2);
        return;
      }
      var getStream = stream2;
      getStream(function(stream3) {
        var isStreamLike = CombinedStream.isStreamLike(stream3);
        if (isStreamLike) {
          stream3.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream3);
        }
        this._pipeNext(stream3);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream2) {
      this._currentStream = stream2;
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("end", this._getNext.bind(this));
        stream2.pipe(this, { end: false });
        return;
      }
      var value = stream2;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream2) {
      var self2 = this;
      stream2.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream2) {
        if (!stream2.dataSize) {
          return;
        }
        self2.dataSize += stream2.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    init_esm();
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    init_esm();
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    __name(charset, "charset");
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    __name(contentType, "contentType");
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    __name(extension, "extension");
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    __name(lookup, "lookup");
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(/* @__PURE__ */ __name(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      }, "forEachMimeType"));
    }
    __name(populateMaps, "populateMaps");
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    init_esm();
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
    __name(defer, "defer");
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    init_esm();
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return /* @__PURE__ */ __name(function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(/* @__PURE__ */ __name(function nextTick_callback() {
            callback(err, result);
          }, "nextTick_callback"));
        }
      }, "async_callback");
    }
    __name(async, "async");
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    init_esm();
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    __name(abort, "abort");
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
    __name(clean, "clean");
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    init_esm();
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    __name(iterate, "iterate");
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
    __name(runJob, "runJob");
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    init_esm();
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a2, b) {
          return sortMethod(list[a2], list[b]);
        });
      }
      return initState;
    }
    __name(state, "state");
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    init_esm();
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
    __name(terminator, "terminator");
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    init_esm();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
    __name(parallel, "parallel");
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    init_esm();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, /* @__PURE__ */ __name(function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      }, "iteratorHandler"));
      return terminator.bind(state, callback);
    }
    __name(serialOrdered, "serialOrdered");
    function ascending(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    }
    __name(ascending, "ascending");
    function descending(a2, b) {
      return -1 * ascending(a2, b);
    }
    __name(descending, "descending");
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    init_esm();
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
    __name(serial, "serial");
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    init_esm();
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN2(a2) {
      return a2 !== a2;
    }, "isNaN");
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    init_esm();
    var $isNaN = require_isNaN();
    module2.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    init_esm();
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    init_esm();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a2, b) {
      var arr = [];
      for (var i2 = 0; i2 < a2.length; i2 += 1) {
        arr[i2] = a2[i2];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a2.length] = b[j];
      }
      return arr;
    }, "concatty");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset) {
      var arr = [];
      for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
        arr[j] = arrLike[i2];
      }
      return arr;
    }, "slicy");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str += arr[i2];
        if (i2 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    }, "joiny");
    module2.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    init_esm();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    init_esm();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic");
    module2.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    init_esm();
    var hasSymbols = require_shams();
    module2.exports = /* @__PURE__ */ __name(function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = /* @__PURE__ */ __name(function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    }, "setToStringTag");
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    init_esm();
    var CombinedStream = require_combined_stream();
    var util = __require("util");
    var path2 = __require("path");
    var http3 = __require("http");
    var https2 = __require("https");
    var parseUrl = __require("url").parse;
    var fs = __require("fs");
    var Stream = __require("stream").Stream;
    var crypto2 = __require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    __name(FormData2, "FormData");
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat3) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat3.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path2.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i2 = 0, len = this._streams.length; i2 < len; i2++) {
        if (typeof this._streams[i2] !== "function") {
          if (Buffer.isBuffer(this._streams[i2])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i2]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i2])]);
          }
          if (typeof this._streams[i2] !== "string" || this._streams[i2].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults2 = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https2.request(options);
      } else {
        request = http3.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = /* @__PURE__ */ __name(function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          }, "callback");
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module2.exports = FormData2;
  }
});

// node_modules/defer-to-connect/dist/source/index.js
var require_source = __commonJS({
  "node_modules/defer-to-connect/dist/source/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    __name(isTLSSocket, "isTLSSocket");
    var deferToConnect2 = /* @__PURE__ */ __name((socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = /* @__PURE__ */ __name(() => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      }, "onConnect");
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    }, "deferToConnect");
    exports2.default = deferToConnect2;
    module2.exports = deferToConnect2;
    module2.exports.default = deferToConnect2;
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      // included, because we add Age update Date
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n2 = parseInt(s, 10);
      return isFinite(n2) ? n2 : 0;
    }
    __name(toNumberOrZero, "toNumberOrZero");
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    __name(isErrorResponse, "isErrorResponse");
    function parseCacheControl(header) {
      const cc = {};
      if (!header) return cc;
      const parts = header.trim().split(/,/);
      for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === void 0 ? true : v.trim().replace(/^"|"$/g, "");
      }
      return cc;
    }
    __name(parseCacheControl, "parseCacheControl");
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    __name(formatCacheControl, "formatCacheControl");
    module2.exports = class CachePolicy {
      static {
        __name(this, "CachePolicy");
      }
      /**
       * Creates a new CachePolicy instance.
       * @param {HttpRequest} req - Incoming client request.
       * @param {HttpResponse} res - Received server response.
       * @param {Object} [options={}] - Configuration options.
       * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.
       * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.
       * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.
       * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.
       * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.
       */
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._ignoreCargoCult = !!ignoreCargoCult;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (this._ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      /**
       * You can monkey-patch it for testing.
       * @returns {number} Current time in milliseconds.
       */
      now() {
        return Date.now();
      }
      /**
       * Determines if the response is storable in a cache.
       * @returns {boolean} `false` if can never be cached.
       */
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      /**
       * @returns {boolean} true if expiration is explicitly defined.
       */
      _hasExplicitExpiration() {
        return !!(this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires);
      }
      /**
       * @param {HttpRequest} req - a request
       * @throws {Error} if the headers are missing.
       */
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      /**
       * Checks if the request matches the cache and can be satisfied from the cache immediately,
       * without having to make a request to the server.
       *
       * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.
       *
       * @param {HttpRequest} req - The new incoming HTTP request.
       * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.
       */
      satisfiesWithoutRevalidation(req) {
        const result = this.evaluateRequest(req);
        return !result.revalidation;
      }
      /**
       * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.
       * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.
       */
      _evaluateRequestHitResult(revalidation) {
        return {
          response: {
            headers: this.responseHeaders()
          },
          revalidation
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).
       * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.
       */
      _evaluateRequestRevalidation(request, synchronous) {
        return {
          synchronous,
          headers: this.revalidationHeaders(request)
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.
       */
      _evaluateRequestMissResult(request) {
        return {
          response: void 0,
          revalidation: this._evaluateRequestRevalidation(request, true)
        };
      }
      /**
       * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:
       *
       * ```
       * {
       *     // If defined, you must send a request to the server.
       *     revalidation: {
       *         headers: {}, // HTTP headers to use when sending the revalidation response
       *         // If true, you MUST wait for a response from the server before using the cache
       *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.
       *         synchronous: bool,
       *     },
       *     // If defined, you can use this cached response.
       *     response: {
       *         headers: {}, // Updated cached HTTP headers you must use when responding to the client
       *     },
       * }
       * ```
       * @param {HttpRequest} req - new incoming HTTP request
       * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:
       *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server
       *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers
       */
      evaluateRequest(req) {
        this._assertRequestHasHeaders(req);
        if (this._rescc["must-revalidate"]) {
          return this._evaluateRequestMissResult(req);
        }
        if (!this._requestMatches(req, false)) {
          return this._evaluateRequestMissResult(req);
        }
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return this._evaluateRequestMissResult(req);
        }
        if (requestCC["max-age"] && this.age() > toNumberOrZero(requestCC["max-age"])) {
          return this._evaluateRequestMissResult(req);
        }
        if (requestCC["min-fresh"] && this.maxAge() - this.age() < toNumberOrZero(requestCC["min-fresh"])) {
          return this._evaluateRequestMissResult(req);
        }
        if (this.stale()) {
          const allowsStaleWithoutRevalidation = "max-stale" in requestCC && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (allowsStaleWithoutRevalidation) {
            return this._evaluateRequestHitResult(void 0);
          }
          if (this.useStaleWhileRevalidate()) {
            return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));
          }
          return this._evaluateRequestMissResult(req);
        }
        return this._evaluateRequestHitResult(void 0);
      }
      /**
       * @param {HttpRequest} req - check if this is for the same cache entry
       * @param {boolean} allowHeadMethod - allow a HEAD method to match.
       * @returns {boolean} `true` if the request matches.
       */
      _requestMatches(req, allowHeadMethod) {
        return !!((!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req));
      }
      /**
       * Determines whether storing authenticated responses is allowed.
       * @returns {boolean} `true` if allowed.
       */
      _allowsStoringAuthenticated() {
        return !!(this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"]);
      }
      /**
       * Checks whether the Vary header in the response matches the new request.
       * @param {HttpRequest} req - incoming HTTP request
       * @returns {boolean} `true` if the vary headers match.
       */
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
      }
      /**
       * Creates a copy of the given headers without any hop-by-hop headers.
       * @param {Record<string, string>} inHeaders - old headers from the cached response
       * @returns {Record<string, string>} A new headers object without hop-by-hop headers.
       */
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name]) continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      /**
       * Returns the response headers adjusted for serving the cached response.
       * Removes hop-by-hop headers and updates the Age and Date headers.
       * @returns {Record<string, string>} The adjusted response headers.
       */
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      /**
       * Returns the Date header value from the response or the current time if invalid.
       * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.
       */
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       * @returns {number} The age in seconds.
       */
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      /**
       * @returns {number} The Age header value as a number.
       */
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.
       * This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * Returns the maximum age (freshness lifetime) of the response in seconds.
       * @returns {number} The max-age value in seconds.
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      /**
       * Remaining time this cache entry may be useful for, in *milliseconds*.
       * You can use this as an expiration time for your cache storage.
       *
       * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.
       * @returns {number} Time-to-live in milliseconds.
       */
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3);
      }
      /**
       * If true, this cache entry is past its expiration date.
       * Note that stale cache may be useful sometimes, see `evaluateRequest()`.
       * @returns {boolean} `false` doesn't mean it's fresh nor usable
       */
      stale() {
        return this.maxAge() <= this.age();
      }
      /**
       * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.
       */
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      /** See `evaluateRequest()` for a more complete solution
       * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.
       */
      useStaleWhileRevalidate() {
        const swr = toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return swr > 0 && this.maxAge() + swr > this.age();
      }
      /**
       * Creates a `CachePolicy` instance from a serialized object.
       * @param {Object} obj - The serialized object.
       * @returns {CachePolicy} A new CachePolicy instance.
       */
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      /**
       * @param {any} obj - The serialized object.
       * @throws {Error} If already initialized or if the object is invalid.
       */
      _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._ignoreCargoCult = !!obj.icc;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      /**
       * Serializes the `CachePolicy` instance into a JSON-serializable object.
       * @returns {Object} The serialized object.
       */
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          icc: this._ignoreCargoCult,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       * @param {HttpRequest} incomingReq - The incoming HTTP request.
       * @returns {Record<string, string>} The headers for the revalidation request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.
       * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.
       * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.
       * @throws {Error} If the response headers are missing.
       */
      revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            policy: this,
            modified: false,
            matches: true
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        const optionsCopy = {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl,
          ignoreCargoCult: this._ignoreCargoCult
        };
        if (!matches) {
          return {
            policy: new this.constructor(request, response, optionsCopy),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, optionsCopy),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "node_modules/json-buffer/index.js"(exports2) {
    init_esm();
    exports2.stringify = /* @__PURE__ */ __name(function stringify(o2) {
      if ("undefined" == typeof o2) return o2;
      if (o2 && Buffer.isBuffer(o2))
        return JSON.stringify(":base64:" + o2.toString("base64"));
      if (o2 && o2.toJSON)
        o2 = o2.toJSON();
      if (o2 && "object" === typeof o2) {
        var s = "";
        var array = Array.isArray(o2);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o2) {
          var ignore = "function" == typeof o2[k] || !array && "undefined" === typeof o2[k];
          if (Object.hasOwnProperty.call(o2, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o2[k] == void 0)
                s += "null";
              else
                s += stringify(o2[k]);
            } else if (o2[k] !== void 0) {
              s += stringify(k) + ":" + stringify(o2[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if ("string" === typeof o2) {
        return JSON.stringify(/^:/.test(o2) ? ":" + o2 : o2);
      } else if ("undefined" === typeof o2) {
        return "null";
      } else
        return JSON.stringify(o2);
    }, "stringify");
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if ("string" === typeof value) {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// node_modules/keyv/src/index.js
var require_src2 = __commonJS({
  "node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var EventEmitter3 = __require("events");
    var JSONB = require_json_buffer();
    var loadStore = /* @__PURE__ */ __name((options) => {
      const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (__require(adapters[adapter]))(options);
      }
      return /* @__PURE__ */ new Map();
    }, "loadStore");
    var iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ];
    var Keyv2 = class extends EventEmitter3 {
      static {
        __name(this, "Keyv");
      }
      constructor(uri, { emitErrors = true, ...options } = {}) {
        super();
        this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri === "string" ? { uri } : uri,
          ...options
        };
        if (!this.opts.store) {
          const adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compression) {
          const compression = this.opts.compression;
          this.opts.serialize = compression.serialize.bind(compression);
          this.opts.deserialize = compression.deserialize.bind(compression);
        }
        if (typeof this.opts.store.on === "function" && emitErrors) {
          this.opts.store.on("error", (error) => this.emit("error", error));
        }
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = /* @__PURE__ */ __name((iterator) => async function* () {
          for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
            const data = await this.opts.deserialize(raw);
            if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
              continue;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) {
              this.delete(key);
              continue;
            }
            yield [this._getKeyUnprefix(key), data.value];
          }
        }, "generateIterator");
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
          this.iterator = generateIterator(this.opts.store);
        } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
          this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
        }
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys) {
        return keys.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        const { store } = this.opts;
        const isArray3 = Array.isArray(key);
        const keyPrefixed = isArray3 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray3 && store.getMany === void 0) {
          const promises = [];
          for (const key2 of keyPrefixed) {
            promises.push(
              Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
                if (data === void 0 || data === null) {
                  return void 0;
                }
                if (typeof data.expires === "number" && Date.now() > data.expires) {
                  return this.delete(key2).then(() => void 0);
                }
                return options && options.raw ? data : data.value;
              })
            );
          }
          return Promise.allSettled(promises).then((values) => {
            const data = [];
            for (const value of values) {
              data.push(value.value);
            }
            return data;
          });
        }
        return Promise.resolve().then(() => isArray3 ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0 || data === null) {
            return void 0;
          }
          if (isArray3) {
            return data.map((row, index) => {
              if (typeof row === "string") {
                row = this.opts.deserialize(row);
              }
              if (row === void 0 || row === null) {
                return void 0;
              }
              if (typeof row.expires === "number" && Date.now() > row.expires) {
                this.delete(key[index]).then(() => void 0);
                return void 0;
              }
              return options && options.raw ? row : row.value;
            });
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            return this.delete(key).then(() => void 0);
          }
          return options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl2) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl2 === "undefined") {
          ttl2 = this.opts.ttl;
        }
        if (ttl2 === 0) {
          ttl2 = void 0;
        }
        const { store } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl2 === "number" ? Date.now() + ttl2 : null;
          if (typeof value === "symbol") {
            this.emit("error", "symbol cannot be serialized");
          }
          value = { value, expires };
          return this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl2)).then(() => true);
      }
      delete(key) {
        const { store } = this.opts;
        if (Array.isArray(key)) {
          const keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store.deleteMany === void 0) {
            const promises = [];
            for (const key2 of keyPrefixed2) {
              promises.push(store.delete(key2));
            }
            return Promise.allSettled(promises).then((values) => values.every((x) => x.value === true));
          }
          return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        const { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
      has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(async () => {
          if (typeof store.has === "function") {
            return store.has(keyPrefixed);
          }
          const value = await store.get(keyPrefixed);
          return value !== void 0;
        });
      }
      disconnect() {
        const { store } = this.opts;
        if (typeof store.disconnect === "function") {
          return store.disconnect();
        }
      }
    };
    module2.exports = Keyv2;
  }
});

// node_modules/decompress-response/node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/decompress-response/node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var knownProperties2 = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties2));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction4 = typeof value === "function";
            return isFunction4 ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { Transform, PassThrough } = __require("stream");
    var zlib = __require("zlib");
    var mimicResponse2 = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse2(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var QuickLRU = class {
      static {
        __name(this, "QuickLRU");
      }
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS({
  "node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = (stream2) => {
      if (stream2.listenerCount("error") !== 0) {
        return stream2;
      }
      stream2.__destroy = stream2._destroy;
      stream2._destroy = (...args) => {
        const callback = args.pop();
        stream2.__destroy(...args, async (error) => {
          await Promise.resolve();
          callback(error);
        });
      };
      const onError = /* @__PURE__ */ __name((error) => {
        Promise.resolve().then(() => {
          stream2.emit("error", error);
        });
      }, "onError");
      stream2.once("error", onError);
      Promise.resolve().then(() => {
        stream2.off("error", onError);
      });
      return stream2;
    };
  }
});

// node_modules/http2-wrapper/source/agent.js
var require_agent = __commonJS({
  "node_modules/http2-wrapper/source/agent.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { URL: URL2 } = __require("url");
    var EventEmitter3 = __require("events");
    var tls = __require("tls");
    var http22 = __require("http2");
    var QuickLRU = require_quick_lru();
    var delayAsyncDestroy = require_delay_async_destroy();
    var kCurrentStreamCount = Symbol("currentStreamCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var kLength = Symbol("length");
    var nameKeys = [
      // Not an Agent option actually
      "createConnection",
      // `http2.connect()` options
      "maxDeflateDynamicTableSize",
      "maxSettings",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "peerMaxConcurrentStreams",
      "settings",
      // `tls.connect()` source options
      "family",
      "localAddress",
      "rejectUnauthorized",
      // `tls.connect()` secure context options
      "pskCallback",
      "minDHSize",
      // `tls.connect()` destination options
      // - `servername` is automatically validated, skip it
      // - `host` and `port` just describe the destination server,
      "path",
      "socket",
      // `tls.createSecureContext()` options
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "ticketKeys"
    ];
    var getSortedIndex = /* @__PURE__ */ __name((array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }, "getSortedIndex");
    var compareSessions = /* @__PURE__ */ __name((a2, b) => a2.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams, "compareSessions");
    var closeCoveredSessions = /* @__PURE__ */ __name((where, session) => {
      for (let index = 0; index < where.length; index++) {
        const coveredSession = where[index];
        if (
          // Unfortunately `.every()` returns true for an empty array
          coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams
        ) {
          gracefullyClose(coveredSession);
        }
      }
    }, "closeCoveredSessions");
    var closeSessionIfCovered = /* @__PURE__ */ __name((where, coveredSession) => {
      for (let index = 0; index < where.length; index++) {
        const session = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
          return true;
        }
      }
      return false;
    }, "closeSessionIfCovered");
    var gracefullyClose = /* @__PURE__ */ __name((session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamCount] === 0) {
        session.close();
      }
    }, "gracefullyClose");
    var Agent = class _Agent extends EventEmitter3 {
      static {
        __name(this, "Agent");
      }
      constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxEmptySessions = maxEmptySessions;
        this._emptySessionCount = 0;
        this._sessionCount = 0;
        this.settings = {
          enablePush: false,
          initialWindowSize: 1024 * 1024 * 32
          // 32MB, see https://github.com/nodejs/node/issues/38426
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      get protocol() {
        return "https:";
      }
      normalizeOptions(options) {
        let normalized = "";
        for (let index = 0; index < nameKeys.length; index++) {
          const key = nameKeys[index];
          normalized += ":";
          if (options && options[key] !== void 0) {
            normalized += options[key];
          }
        }
        return normalized;
      }
      _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
          this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
          return;
        }
        for (const normalizedOptions in this.queue) {
          for (const normalizedOrigin in this.queue[normalizedOptions]) {
            const item = this.queue[normalizedOptions][normalizedOrigin];
            if (!item.completed) {
              item.completed = true;
              item();
            }
          }
        }
      }
      _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
      }
      _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
          listeners[index].resolve(session);
          index++;
        }
        listeners.splice(0, index);
        if (listeners.length > 0) {
          this.getSession(normalizedOrigin, options, listeners);
          listeners.length = 0;
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners) && listeners.length > 0) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          try {
            if (typeof origin === "string") {
              origin = new URL2(origin);
            } else if (!(origin instanceof URL2)) {
              throw new TypeError("The `origin` argument needs to be a string or an URL object");
            }
            if (options) {
              const { servername } = options;
              const { hostname } = origin;
              if (servername && hostname !== servername) {
                throw new Error(`Origin ${hostname} differs from servername ${servername}`);
              }
            }
          } catch (error) {
            for (let index = 0; index < listeners.length; index++) {
              listeners[index].reject(error);
            }
            return;
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = origin.origin;
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (let index = 0; index < sessions.length; index++) {
              const session = sessions[index];
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (!session[kOriginSet].includes(normalizedOrigin)) {
                continue;
              }
              const sessionCurrentStreamsCount = session[kCurrentStreamCount];
              if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                continue;
              }
              if (!optimalSession) {
                maxConcurrentStreams = sessionMaxConcurrentStreams;
              }
              if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
                optimalSession = session;
                currentStreamsCount = sessionCurrentStreamsCount;
              }
            }
            if (optimalSession) {
              this._accept(optimalSession, listeners, normalizedOrigin, options);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {
              [kLength]: 0
            };
          }
          const removeFromQueue = /* @__PURE__ */ __name(() => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (--this.queue[normalizedOptions][kLength] === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          }, "removeFromQueue");
          const entry = /* @__PURE__ */ __name(async () => {
            this._sessionCount++;
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            let socket;
            try {
              const computedOptions = { ...options };
              if (computedOptions.settings === void 0) {
                computedOptions.settings = this.settings;
              }
              if (computedOptions.session === void 0) {
                computedOptions.session = this.tlsSessionCache.get(name);
              }
              const createConnection = computedOptions.createConnection || this.createConnection;
              socket = await createConnection.call(this, origin, computedOptions);
              computedOptions.createConnection = () => socket;
              const session = http22.connect(origin, computedOptions);
              session[kCurrentStreamCount] = 0;
              session[kGracefullyClosing] = false;
              const getOriginSet = /* @__PURE__ */ __name(() => {
                const { socket: socket2 } = session;
                let originSet;
                if (socket2.servername === false) {
                  socket2.servername = socket2.remoteAddress;
                  originSet = session.originSet;
                  socket2.servername = false;
                } else {
                  originSet = session.originSet;
                }
                return originSet;
              }, "getOriginSet");
              const isFree = /* @__PURE__ */ __name(() => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams, "isFree");
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error) => {
                for (let index = 0; index < listeners.length; index++) {
                  listeners[index].reject(error);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                this._sessionCount--;
                if (receivedSettings) {
                  this._emptySessionCount--;
                  const where = this.sessions[normalizedOptions];
                  if (where.length === 1) {
                    delete this.sessions[normalizedOptions];
                  } else {
                    where.splice(where.indexOf(session), 1);
                  }
                } else {
                  removeFromQueue();
                  const error = new Error("Session closed without receiving a SETTINGS frame");
                  error.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error);
                  }
                }
                this._processQueue();
              });
              const processListeners = /* @__PURE__ */ __name(() => {
                const queue = this.queue[normalizedOptions];
                if (!queue) {
                  return;
                }
                const originSet = session[kOriginSet];
                for (let index = 0; index < originSet.length; index++) {
                  const origin2 = originSet[index];
                  if (origin2 in queue) {
                    const { listeners: listeners2, completed } = queue[origin2];
                    let index2 = 0;
                    while (index2 < listeners2.length && isFree()) {
                      listeners2[index2].resolve(session);
                      index2++;
                    }
                    queue[origin2].listeners.splice(0, index2);
                    if (queue[origin2].listeners.length === 0 && !completed) {
                      delete queue[origin2];
                      if (--queue[kLength] === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              }, "processListeners");
              session.on("origin", () => {
                session[kOriginSet] = getOriginSet() || [];
                session[kGracefullyClosing] = false;
                closeSessionIfCovered(this.sessions[normalizedOptions], session);
                if (session[kGracefullyClosing] || !isFree()) {
                  return;
                }
                processListeners();
                if (!isFree()) {
                  return;
                }
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                if (entry.destroyed) {
                  const error = new Error("Agent has been destroyed");
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error);
                  }
                  session.destroy();
                  return;
                }
                if (session.setLocalWindowSize) {
                  session.setLocalWindowSize(1024 * 1024 * 4);
                }
                session[kOriginSet] = getOriginSet() || [];
                if (session.socket.encrypted) {
                  const mainOrigin = session[kOriginSet][0];
                  if (mainOrigin !== normalizedOrigin) {
                    const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                    for (let index = 0; index < listeners.length; index++) {
                      listeners[index].reject(error);
                    }
                    session.destroy();
                    return;
                  }
                }
                removeFromQueue();
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                receivedSettings = true;
                this._emptySessionCount++;
                this.emit("session", session);
                this._accept(session, listeners, normalizedOrigin, options);
                if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
                  this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
                }
                session.on("remoteSettings", () => {
                  if (!isFree()) {
                    return;
                  }
                  processListeners();
                  if (!isFree()) {
                    return;
                  }
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream2 = session[kRequest](headers, streamOptions);
                session.ref();
                if (session[kCurrentStreamCount]++ === 0) {
                  this._emptySessionCount--;
                }
                stream2.once("close", () => {
                  if (--session[kCurrentStreamCount] === 0) {
                    this._emptySessionCount++;
                    session.unref();
                    if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
                      session.close();
                      return;
                    }
                  }
                  if (session.destroyed || session.closed) {
                    return;
                  }
                  if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                    closeCoveredSessions(this.sessions[normalizedOptions], session);
                    processListeners();
                    if (session[kCurrentStreamCount] === 0) {
                      this._processQueue();
                    }
                  }
                });
                return stream2;
              };
            } catch (error) {
              removeFromQueue();
              this._sessionCount--;
              for (let index = 0; index < listeners.length; index++) {
                listeners[index].reject(error);
              }
            }
          }, "entry");
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this.queue[normalizedOptions][kLength]++;
          this._processQueue();
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: /* @__PURE__ */ __name((session) => {
              try {
                const stream2 = session.request(headers, streamOptions);
                delayAsyncDestroy(stream2);
                resolve(stream2);
              } catch (error) {
                reject(error);
              }
            }, "resolve")
          }]);
        });
      }
      async createConnection(origin, options) {
        return _Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port2 = origin.port || 443;
        const host = origin.hostname;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        const socket = tls.connect(port2, host, options);
        if (options.socket) {
          socket._peername = {
            family: void 0,
            address: void 0,
            port: port2
          };
        }
        return socket;
      }
      closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0;
        const { sessions } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            const session = thisSessions[index];
            if (session[kCurrentStreamCount] === 0) {
              closedCount++;
              session.close();
              if (closedCount >= maxCount) {
                return closedCount;
              }
            }
          }
        }
        return closedCount;
      }
      destroy(reason) {
        const { sessions, queue } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            thisSessions[index].destroy(reason);
          }
        }
        for (const normalizedOptions in queue) {
          const entries3 = queue[normalizedOptions];
          for (const normalizedOrigin in entries3) {
            entries3[normalizedOrigin].destroyed = true;
          }
        }
        this.queue = {};
        this.tlsSessionCache.clear();
      }
      get emptySessionCount() {
        return this._emptySessionCount;
      }
      get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
      }
      get sessionCount() {
        return this._sessionCount;
      }
    };
    Agent.kCurrentStreamCount = kCurrentStreamCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS({
  "node_modules/http2-wrapper/source/incoming-message.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { Readable: Readable2 } = __require("stream");
    var IncomingMessage = class extends Readable2 {
      static {
        __name(this, "IncomingMessage");
      }
      constructor(socket, highWaterMark) {
        super({
          emitClose: false,
          autoDestroy: true,
          highWaterMark
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this._dumped = false;
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      _destroy(error, callback) {
        if (!this.readableEnded) {
          this.aborted = true;
        }
        callback();
        this.req._request.destroy(error);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  }
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-events.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors = __commonJS({
  "node_modules/http2-wrapper/source/utils/errors.js"(exports2, module2) {
    "use strict";
    init_esm();
    var makeError = /* @__PURE__ */ __name((Base, key, getMessage) => {
      module2.exports[key] = class NodeError extends Base {
        static {
          __name(this, "NodeError");
        }
        constructor(...args) {
          super(typeof getMessage === "string" ? getMessage : getMessage(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    }, "makeError");
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(
      TypeError,
      "ERR_INVALID_PROTOCOL",
      (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`
    );
    makeError(
      Error,
      "ERR_HTTP_HEADERS_SENT",
      (args) => `Cannot ${args[0]} headers after they are sent to the client`
    );
    makeError(
      TypeError,
      "ERR_INVALID_HTTP_TOKEN",
      (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`
    );
    makeError(
      TypeError,
      "ERR_HTTP_INVALID_HEADER_VALUE",
      (args) => `Invalid value "${args[0]} for header "${args[1]}"`
    );
    makeError(
      TypeError,
      "ERR_INVALID_CHAR",
      (args) => `Invalid character in ${args[0]} [${args[1]}]`
    );
    makeError(
      Error,
      "ERR_HTTP2_NO_SOCKET_MANIPULATION",
      "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
    );
  }
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS({
  "node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/validate-header-name.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { ERR_INVALID_HTTP_TOKEN } = require_errors();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    module2.exports = (name) => {
      if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS({
  "node_modules/http2-wrapper/source/utils/validate-header-value.js"(exports2, module2) {
    "use strict";
    init_esm();
    var {
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors();
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    module2.exports = (name, value) => {
      if (typeof value === "undefined") {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }
      if (isInvalidHeaderValue.test(value)) {
        throw new ERR_INVALID_CHAR("header content", name);
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors();
    var proxySocketHandler = {
      has(stream2, property) {
        const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
        return property in stream2 || property in reference;
      },
      get(stream2, property) {
        switch (property) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream2[property].bind(stream2);
          case "writable":
          case "destroyed":
            return stream2[property];
          case "readable":
            if (stream2.destroyed) {
              return false;
            }
            return stream2.readable;
          case "setTimeout": {
            const { session } = stream2;
            if (session !== void 0) {
              return session.setTimeout.bind(session);
            }
            return stream2.setTimeout.bind(stream2);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
            const value = reference[property];
            return typeof value === "function" ? value.bind(reference) : value;
          }
        }
      },
      getPrototypeOf(stream2) {
        if (stream2.session !== void 0) {
          return Reflect.getPrototypeOf(stream2.session.socket);
        }
        return Reflect.getPrototypeOf(stream2);
      },
      set(stream2, property, value) {
        switch (property) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            stream2[property] = value;
            return true;
          case "setTimeout": {
            const { session } = stream2;
            if (session === void 0) {
              stream2.setTimeout = value;
            } else {
              session.setTimeout = value;
            }
            return true;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
            reference[property] = value;
            return true;
          }
        }
      }
    };
    module2.exports = proxySocketHandler;
  }
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS({
  "node_modules/http2-wrapper/source/client-request.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { URL: URL2, urlToHttpOptions } = __require("url");
    var http22 = __require("http2");
    var { Writable } = __require("stream");
    var { Agent, globalAgent } = require_agent();
    var IncomingMessage = require_incoming_message();
    var proxyEvents2 = require_proxy_events();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT
    } = require_errors();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var proxySocketHandler = require_proxy_socket_handler();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_METHOD_CONNECT
    } = http22.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var kPendingAgentPromise = Symbol("pendingAgentPromise");
    var ClientRequest = class extends Writable {
      static {
        __name(this, "ClientRequest");
      }
      constructor(input, options, callback) {
        super({
          autoDestroy: false,
          emitClose: false
        });
        if (typeof input === "string") {
          input = urlToHttpOptions(new URL2(input));
        } else if (input instanceof URL2) {
          input = urlToHttpOptions(input);
        } else {
          input = { ...input };
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = input;
        } else {
          options = Object.assign(input, options);
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
          if (this[kSession].destroyed) {
            throw new Error("The session has been closed already");
          }
          this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === false) {
          this.agent = new Agent({ maxEmptySessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          this.agent = globalAgent;
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
        }
        if (this.agent) {
          this.protocol = this.agent.protocol;
        }
        if (options.protocol && options.protocol !== this.protocol) {
          throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        }
        if (!options.port) {
          options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
        }
        options.host = options.hostname || options.host || "localhost";
        delete options.hostname;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this[kPendingAgentPromise] = void 0;
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        if (!(this.method === "CONNECT" && (options.path === "/" || options.path === void 0))) {
          this.path = options.path;
        }
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        const { headers } = options;
        if (headers) {
          for (const header in headers) {
            this.setHeader(header, headers[header]);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        this[kOrigin] = new URL2(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        const reuseSocket = options._reuseSocket;
        if (reuseSocket) {
          options.createConnection = (...args) => {
            if (reuseSocket.destroyed) {
              return this.agent.createConnection(...args);
            }
            return reuseSocket;
          };
          this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
          });
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        return this[kHeaders][header];
      }
      set path(value) {
        if (value) {
          const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
          this[kHeaders][header] = value;
        }
      }
      get host() {
        return this[kOrigin].hostname;
      }
      set host(_value) {
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk2, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = /* @__PURE__ */ __name(() => this._request.write(chunk2, encoding, callback), "callWrite");
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        this.flushHeaders();
        const callEnd = /* @__PURE__ */ __name(() => {
          if (this._mustNotHaveABody || this.method === "CONNECT") {
            callback();
            return;
          }
          this._request.end(callback);
        }, "callEnd");
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      async _destroy(error, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        } else {
          process.nextTick(() => {
            this.emit("close");
          });
        }
        try {
          await this[kPendingAgentPromise];
        } catch (internalError) {
          if (this.aborted) {
            error = internalError;
          }
        }
        callback(error);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = /* @__PURE__ */ __name((stream2) => {
          this._request = stream2;
          if (this.destroyed) {
            stream2.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents2(stream2, this, ["timeout", "continue"]);
          }
          stream2.once("error", (error) => {
            this.destroy(error);
          });
          stream2.once("aborted", () => {
            const { res } = this;
            if (res) {
              res.aborted = true;
              res.emit("aborted");
              res.destroy();
            } else {
              this.destroy(new Error("The server aborted the HTTP/2 stream"));
            }
          });
          const onResponse = /* @__PURE__ */ __name((headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream2.readableHighWaterMark);
            this.res = response;
            response.url = `${this[kOrigin].origin}${this.path}`;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              response.complete = true;
              response.socket = null;
              response.connection = null;
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream2, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream2.destroy();
              }
            } else {
              stream2.on("data", (chunk2) => {
                if (!response._dumped && !response.push(chunk2)) {
                  stream2.pause();
                }
              });
              stream2.once("end", () => {
                if (!this.aborted) {
                  response.push(null);
                }
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          }, "onResponse");
          stream2.once("response", onResponse);
          stream2.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] }));
          stream2.once("trailers", (trailers, flags, rawTrailers) => {
            const { res } = this;
            if (res === null) {
              onResponse(trailers, flags, rawTrailers);
              return;
            }
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          });
          stream2.once("close", () => {
            const { aborted, res } = this;
            if (res) {
              if (aborted) {
                res.aborted = true;
                res.emit("aborted");
                res.destroy();
              }
              const finish = /* @__PURE__ */ __name(() => {
                res.emit("close");
                this.destroy();
                this.emit("close");
              }, "finish");
              if (res.readable) {
                res.once("end", finish);
              } else {
                finish();
              }
              return;
            }
            if (!this.destroyed) {
              this.destroy(new Error("The HTTP/2 stream has been early terminated"));
              this.emit("close");
              return;
            }
            this.destroy();
            this.emit("close");
          });
          this.socket = new Proxy(stream2, proxySocketHandler);
          for (const job of this[kJobs]) {
            job();
          }
          this[kJobs].length = 0;
          this.emit("socket", this.socket);
        }, "onStream");
        if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
        }
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error) {
            this.destroy(error);
          }
        } else {
          this.reusedSocket = true;
          try {
            const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
            this[kPendingAgentPromise] = promise;
            onStream(await promise);
            this[kPendingAgentPromise] = false;
          } catch (error) {
            this[kPendingAgentPromise] = false;
            this.destroy(error);
          }
        }
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      getHeaderNames() {
        return Object.keys(this[kHeaders]);
      }
      hasHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return Boolean(this[kHeaders][name.toLowerCase()]);
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        validateHeaderName(name);
        validateHeaderValue(name, value);
        const lowercased = name.toLowerCase();
        if (lowercased === "connection") {
          if (value.toLowerCase() === "keep-alive") {
            return;
          }
          throw new Error(`Invalid 'connection' header: ${value}`);
        }
        if (lowercased === "host" && this.method === "CONNECT") {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
        } else {
          this[kHeaders][lowercased] = value;
        }
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = /* @__PURE__ */ __name(() => this._request.setTimeout(ms, callback), "applyTimeout");
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  }
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS({
  "node_modules/resolve-alpn/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var tls = __require("tls");
    module2.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = /* @__PURE__ */ __name(async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      }, "callback");
      const onTimeout = /* @__PURE__ */ __name(async () => {
        timeout = true;
        callback();
      }, "onTimeout");
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error) {
          reject(error);
        }
      })();
    });
  }
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { isIP } = __require("net");
    var assert3 = __require("assert");
    var getHost = /* @__PURE__ */ __name((host) => {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert3(idx2 !== -1);
        return host.slice(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) {
        return host;
      }
      return host.slice(0, idx);
    }, "getHost");
    module2.exports = (host) => {
      const servername = getHost(host);
      if (isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS({
  "node_modules/http2-wrapper/source/auto.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { URL: URL2, urlToHttpOptions } = __require("url");
    var http3 = __require("http");
    var https2 = __require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var { Agent, globalAgent } = require_agent();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var delayAsyncDestroy = require_delay_async_destroy();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = /* @__PURE__ */ __name((agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = /* @__PURE__ */ __name(() => {
        agent.emit("free", socket, options);
      }, "onFree");
      socket.on("free", onFree);
      const onClose = /* @__PURE__ */ __name(() => {
        agent.removeSocket(socket, options);
      }, "onClose");
      socket.on("close", onClose);
      const onTimeout = /* @__PURE__ */ __name(() => {
        const { freeSockets } = agent;
        for (const sockets of Object.values(freeSockets)) {
          if (sockets.includes(socket)) {
            socket.destroy();
            return;
          }
        }
      }, "onTimeout");
      socket.on("timeout", onTimeout);
      const onRemove = /* @__PURE__ */ __name(() => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("timeout", onTimeout);
        socket.off("agentRemove", onRemove);
      }, "onRemove");
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    }, "installSocket");
    var createResolveProtocol = /* @__PURE__ */ __name((cache2, queue2 = /* @__PURE__ */ new Map(), connect = void 0) => {
      return async (options) => {
        const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
        if (!cache2.has(name)) {
          if (queue2.has(name)) {
            const result = await queue2.get(name);
            return { alpnProtocol: result.alpnProtocol };
          }
          const { path: path2 } = options;
          options.path = options.socketPath;
          const resultPromise = resolveALPN(options, connect);
          queue2.set(name, resultPromise);
          try {
            const result = await resultPromise;
            cache2.set(name, result.alpnProtocol);
            queue2.delete(name);
            options.path = path2;
            return result;
          } catch (error) {
            queue2.delete(name);
            options.path = path2;
            throw error;
          }
        }
        return { alpnProtocol: cache2.get(name) };
      };
    }, "createResolveProtocol");
    var defaultResolveProtocol = createResolveProtocol(cache, queue);
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string") {
        input = urlToHttpOptions(new URL2(input));
      } else if (input instanceof URL2) {
        input = urlToHttpOptions(input);
      } else {
        input = { ...input };
      }
      if (typeof options === "function" || options === void 0) {
        callback = options;
        options = input;
      } else {
        options = Object.assign(input, options);
      }
      options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"];
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https2.globalAgent : http3.globalAgent;
      const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;
      let { agent } = options;
      if (agent !== void 0 && agent !== false && agent.constructor.name !== "Object") {
        throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
      }
      if (isHttps) {
        options.resolveSocket = true;
        let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
        if (timeout) {
          if (socket) {
            socket.destroy();
          }
          const error = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
          error.code = "ETIMEDOUT";
          error.ms = options.timeout;
          throw error;
        }
        if (socket && options.createConnection) {
          socket.destroy();
          socket = void 0;
        }
        delete options.resolveSocket;
        const isHttp2 = alpnProtocol === "h2";
        if (agent) {
          agent = isHttp2 ? agent.http2 : agent.https;
          options.agent = agent;
        }
        if (agent === void 0) {
          agent = isHttp2 ? globalAgent : https2.globalAgent;
        }
        if (socket) {
          if (agent === false) {
            socket.destroy();
          } else {
            const defaultCreateConnection = (isHttp2 ? Agent : https2.Agent).prototype.createConnection;
            if (agent.createConnection === defaultCreateConnection) {
              if (isHttp2) {
                options._reuseSocket = socket;
              } else {
                installSocket(agent, socket, options);
              }
            } else {
              socket.destroy();
            }
          }
        }
        if (isHttp2) {
          return delayAsyncDestroy(new Http2ClientRequest(options, callback));
        }
      } else if (agent) {
        options.agent = agent.http;
      }
      if (options.headers) {
        options.headers = { ...options.headers };
        if (options.headers[":authority"]) {
          if (!options.headers.host) {
            options.headers.host = options.headers[":authority"];
          }
          delete options.headers[":authority"];
        }
        delete options.headers[":method"];
        delete options.headers[":scheme"];
        delete options.headers[":path"];
      }
      return delayAsyncDestroy(http3.request(options, callback));
    };
    module2.exports.protocolCache = cache;
    module2.exports.resolveProtocol = defaultResolveProtocol;
    module2.exports.createResolveProtocol = createResolveProtocol;
  }
});

// node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS({
  "node_modules/http2-wrapper/source/utils/js-stream-socket.js"(exports2, module2) {
    "use strict";
    init_esm();
    var stream2 = __require("stream");
    var tls = __require("tls");
    var JSStreamSocket = new tls.TLSSocket(new stream2.PassThrough())._handle._parentWrap.constructor;
    module2.exports = JSStreamSocket;
  }
});

// node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS({
  "node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(exports2, module2) {
    "use strict";
    init_esm();
    var UnexpectedStatusCodeError = class extends Error {
      static {
        __name(this, "UnexpectedStatusCodeError");
      }
      constructor(statusCode, statusMessage = "") {
        super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`);
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
      }
    };
    module2.exports = UnexpectedStatusCodeError;
  }
});

// node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS({
  "node_modules/http2-wrapper/source/utils/check-type.js"(exports2, module2) {
    "use strict";
    init_esm();
    var checkType = /* @__PURE__ */ __name((name, value, types2) => {
      const valid = types2.some((type) => {
        const typeofType = typeof type;
        if (typeofType === "string") {
          return typeof value === type;
        }
        return value instanceof type;
      });
      if (!valid) {
        const names = types2.map((type) => typeof type === "string" ? type : type.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
      }
    }, "checkType");
    module2.exports = checkType;
  }
});

// node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS({
  "node_modules/http2-wrapper/source/proxies/initialize.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { URL: URL2 } = __require("url");
    var checkType = require_check_type();
    module2.exports = (self2, proxyOptions) => {
      checkType("proxyOptions", proxyOptions, ["object"]);
      checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]);
      checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]);
      checkType("proxyOptions.url", proxyOptions.url, [URL2, "string"]);
      const url = new URL2(proxyOptions.url);
      self2.proxyOptions = {
        raw: true,
        ...proxyOptions,
        headers: { ...proxyOptions.headers },
        url
      };
    };
  }
});

// node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS({
  "node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = (self2) => {
      const { username, password } = self2.proxyOptions.url;
      if (username || password) {
        const data = `${username}:${password}`;
        const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
          "proxy-authorization": authorization,
          authorization
        };
      }
      return {};
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(exports2, module2) {
    "use strict";
    init_esm();
    var tls = __require("tls");
    var http3 = __require("http");
    var https2 = __require("https");
    var JSStreamSocket = require_js_stream_socket();
    var { globalAgent } = require_agent();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var getAuthorizationHeaders = require_get_auth_headers();
    var createConnection = /* @__PURE__ */ __name((self2, options, callback) => {
      (async () => {
        try {
          const { proxyOptions } = self2;
          const { url, headers, raw } = proxyOptions;
          const stream2 = await globalAgent.request(url, proxyOptions, {
            ...getAuthorizationHeaders(self2),
            ...headers,
            ":method": "CONNECT",
            ":authority": `${options.host}:${options.port}`
          });
          stream2.once("error", callback);
          stream2.once("response", (headers2) => {
            const statusCode = headers2[":status"];
            if (statusCode !== 200) {
              callback(new UnexpectedStatusCodeError(statusCode, ""));
              return;
            }
            const encrypted = self2 instanceof https2.Agent;
            if (raw && encrypted) {
              options.socket = stream2;
              const secureStream = tls.connect(options);
              secureStream.once("close", () => {
                stream2.destroy();
              });
              callback(null, secureStream);
              return;
            }
            const socket = new JSStreamSocket(stream2);
            socket.encrypted = false;
            socket._handle.getpeername = (out) => {
              out.family = void 0;
              out.address = void 0;
              out.port = void 0;
            };
            callback(null, socket);
          });
        } catch (error) {
          callback(error);
        }
      })();
    }, "createConnection");
    var HttpOverHttp2 = class extends http3.Agent {
      static {
        __name(this, "HttpOverHttp2");
      }
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    var HttpsOverHttp2 = class extends https2.Agent {
      static {
        __name(this, "HttpsOverHttp2");
      }
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    module2.exports = {
      HttpOverHttp2,
      HttpsOverHttp2
    };
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { Agent } = require_agent();
    var JSStreamSocket = require_js_stream_socket();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var Http2OverHttpX = class extends Agent {
      static {
        __name(this, "Http2OverHttpX");
      }
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      async createConnection(origin, options) {
        const authority = `${origin.hostname}:${origin.port || 443}`;
        const [stream2, statusCode, statusMessage] = await this._getProxyStream(authority);
        if (statusCode !== 200) {
          throw new UnexpectedStatusCodeError(statusCode, statusMessage);
        }
        if (this.proxyOptions.raw) {
          options.socket = stream2;
        } else {
          const socket = new JSStreamSocket(stream2);
          socket.encrypted = false;
          socket._handle.getpeername = (out) => {
            out.family = void 0;
            out.address = void 0;
            out.port = void 0;
          };
          return socket;
        }
        return super.createConnection(origin, options);
      }
    };
    module2.exports = Http2OverHttpX;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(exports2, module2) {
    "use strict";
    init_esm();
    var { globalAgent } = require_agent();
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStatusCode = /* @__PURE__ */ __name((stream2) => new Promise((resolve, reject) => {
      stream2.once("error", reject);
      stream2.once("response", (headers) => {
        stream2.off("error", reject);
        resolve(headers[":status"]);
      });
    }), "getStatusCode");
    var Http2OverHttp2 = class extends Http2OverHttpX {
      static {
        __name(this, "Http2OverHttp2");
      }
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const headers = {
          ...getAuthorizationHeaders(this),
          ...proxyOptions.headers,
          ":method": "CONNECT",
          ":authority": authority
        };
        const stream2 = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
        const statusCode = await getStatusCode(stream2);
        return [stream2, statusCode, ""];
      }
    };
    module2.exports = Http2OverHttp2;
  }
});

// node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS({
  "node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(exports2, module2) {
    "use strict";
    init_esm();
    var http3 = __require("http");
    var https2 = __require("https");
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStream = /* @__PURE__ */ __name((request) => new Promise((resolve, reject) => {
      const onConnect = /* @__PURE__ */ __name((response, socket, head) => {
        socket.unshift(head);
        request.off("error", reject);
        resolve([socket, response.statusCode, response.statusMessage]);
      }, "onConnect");
      request.once("error", reject);
      request.once("connect", onConnect);
    }), "getStream");
    var Http2OverHttp = class extends Http2OverHttpX {
      static {
        __name(this, "Http2OverHttp");
      }
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const { url, headers } = this.proxyOptions;
        const network = url.protocol === "https:" ? https2 : http3;
        const request = network.request({
          ...proxyOptions,
          hostname: url.hostname,
          port: url.port,
          path: authority,
          headers: {
            ...getAuthorizationHeaders(this),
            ...headers,
            host: authority
          },
          method: "CONNECT"
        }).end();
        return getStream(request);
      }
    };
    module2.exports = {
      Http2OverHttp,
      Http2OverHttps: Http2OverHttp
    };
  }
});

// node_modules/http2-wrapper/source/index.js
var require_source2 = __commonJS({
  "node_modules/http2-wrapper/source/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var http22 = __require("http2");
    var {
      Agent,
      globalAgent
    } = require_agent();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var {
      HttpOverHttp2,
      HttpsOverHttp2
    } = require_h1_over_h2();
    var Http2OverHttp2 = require_h2_over_h2();
    var {
      Http2OverHttp,
      Http2OverHttps
    } = require_h2_over_h1();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var request = /* @__PURE__ */ __name((url, options, callback) => new ClientRequest(url, options, callback), "request");
    var get = /* @__PURE__ */ __name((url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    }, "get");
    module2.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      Agent,
      globalAgent,
      request,
      get,
      auto,
      proxies: {
        HttpOverHttp2,
        HttpsOverHttp2,
        Http2OverHttp2,
        Http2OverHttp,
        Http2OverHttps
      },
      validateHeaderName,
      validateHeaderValue
    };
  }
});

// node_modules/json-to-ast/build.js
var require_build = __commonJS({
  "node_modules/json-to-ast/build.js"(exports2, module2) {
    init_esm();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.jsonToAst = factory();
    })(exports2, function() {
      "use strict";
      var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function createCommonjsModule(fn, module3) {
        return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
      }
      __name(createCommonjsModule, "createCommonjsModule");
      var graphemeSplitter = createCommonjsModule(function(module3) {
        function GraphemeSplitter() {
          var CR = 0, LF = 1, Control = 2, Extend = 3, Regional_Indicator = 4, SpacingMark = 5, L = 6, V = 7, T = 8, LV = 9, LVT = 10, Other = 11, Prepend = 12, E_Base = 13, E_Modifier = 14, ZWJ = 15, Glue_After_Zwj = 16, E_Base_GAZ = 17;
          var NotBreak = 0, BreakStart = 1, Break = 2, BreakLastRegional = 3, BreakPenultimateRegional = 4;
          function isSurrogate(str, pos) {
            return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
          }
          __name(isSurrogate, "isSurrogate");
          function codePointAt(str, idx) {
            if (idx === void 0) {
              idx = 0;
            }
            var code = str.charCodeAt(idx);
            if (55296 <= code && code <= 56319 && idx < str.length - 1) {
              var hi = code;
              var low = str.charCodeAt(idx + 1);
              if (56320 <= low && low <= 57343) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return hi;
            }
            if (56320 <= code && code <= 57343 && idx >= 1) {
              var hi = str.charCodeAt(idx - 1);
              var low = code;
              if (55296 <= hi && hi <= 56319) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return low;
            }
            return code;
          }
          __name(codePointAt, "codePointAt");
          function shouldBreak(start, mid, end) {
            var all2 = [start].concat(mid).concat([end]);
            var previous = all2[all2.length - 2];
            var next = end;
            var eModifierIndex = all2.lastIndexOf(E_Modifier);
            if (eModifierIndex > 1 && all2.slice(1, eModifierIndex).every(function(c3) {
              return c3 == Extend;
            }) && [Extend, E_Base, E_Base_GAZ].indexOf(start) == -1) {
              return Break;
            }
            var rIIndex = all2.lastIndexOf(Regional_Indicator);
            if (rIIndex > 0 && all2.slice(1, rIIndex).every(function(c3) {
              return c3 == Regional_Indicator;
            }) && [Prepend, Regional_Indicator].indexOf(previous) == -1) {
              if (all2.filter(function(c3) {
                return c3 == Regional_Indicator;
              }).length % 2 == 1) {
                return BreakLastRegional;
              } else {
                return BreakPenultimateRegional;
              }
            }
            if (previous == CR && next == LF) {
              return NotBreak;
            } else if (previous == Control || previous == CR || previous == LF) {
              if (next == E_Modifier && mid.every(function(c3) {
                return c3 == Extend;
              })) {
                return Break;
              } else {
                return BreakStart;
              }
            } else if (next == Control || next == CR || next == LF) {
              return BreakStart;
            } else if (previous == L && (next == L || next == V || next == LV || next == LVT)) {
              return NotBreak;
            } else if ((previous == LV || previous == V) && (next == V || next == T)) {
              return NotBreak;
            } else if ((previous == LVT || previous == T) && next == T) {
              return NotBreak;
            } else if (next == Extend || next == ZWJ) {
              return NotBreak;
            } else if (next == SpacingMark) {
              return NotBreak;
            } else if (previous == Prepend) {
              return NotBreak;
            }
            var previousNonExtendIndex = all2.indexOf(Extend) != -1 ? all2.lastIndexOf(Extend) - 1 : all2.length - 2;
            if ([E_Base, E_Base_GAZ].indexOf(all2[previousNonExtendIndex]) != -1 && all2.slice(previousNonExtendIndex + 1, -1).every(function(c3) {
              return c3 == Extend;
            }) && next == E_Modifier) {
              return NotBreak;
            }
            if (previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
              return NotBreak;
            }
            if (mid.indexOf(Regional_Indicator) != -1) {
              return Break;
            }
            if (previous == Regional_Indicator && next == Regional_Indicator) {
              return NotBreak;
            }
            return BreakStart;
          }
          __name(shouldBreak, "shouldBreak");
          this.nextBreak = function(string, index) {
            if (index === void 0) {
              index = 0;
            }
            if (index < 0) {
              return 0;
            }
            if (index >= string.length - 1) {
              return string.length;
            }
            var prev = getGraphemeBreakProperty(codePointAt(string, index));
            var mid = [];
            for (var i2 = index + 1; i2 < string.length; i2++) {
              if (isSurrogate(string, i2 - 1)) {
                continue;
              }
              var next = getGraphemeBreakProperty(codePointAt(string, i2));
              if (shouldBreak(prev, mid, next)) {
                return i2;
              }
              mid.push(next);
            }
            return string.length;
          };
          this.splitGraphemes = function(str) {
            var res = [];
            var index = 0;
            var brk;
            while ((brk = this.nextBreak(str, index)) < str.length) {
              res.push(str.slice(index, brk));
              index = brk;
            }
            if (index < str.length) {
              res.push(str.slice(index));
            }
            return res;
          };
          this.iterateGraphemes = function(str) {
            var index = 0;
            var res = {
              next: function() {
                var value;
                var brk;
                if ((brk = this.nextBreak(str, index)) < str.length) {
                  value = str.slice(index, brk);
                  index = brk;
                  return { value, done: false };
                }
                if (index < str.length) {
                  value = str.slice(index);
                  index = str.length;
                  return { value, done: false };
                }
                return { value: void 0, done: true };
              }.bind(this)
            };
            if (typeof Symbol !== "undefined" && Symbol.iterator) {
              res[Symbol.iterator] = function() {
                return res;
              };
            }
            return res;
          };
          this.countGraphemes = function(str) {
            var count = 0;
            var index = 0;
            var brk;
            while ((brk = this.nextBreak(str, index)) < str.length) {
              index = brk;
              count++;
            }
            if (index < str.length) {
              count++;
            }
            return count;
          };
          function getGraphemeBreakProperty(code) {
            if (1536 <= code && code <= 1541 || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
            1757 == code || // Cf       ARABIC END OF AYAH
            1807 == code || // Cf       SYRIAC ABBREVIATION MARK
            2274 == code || // Cf       ARABIC DISPUTED END OF AYAH
            3406 == code || // Lo       MALAYALAM LETTER DOT REPH
            69821 == code || // Cf       KAITHI NUMBER SIGN
            70082 <= code && code <= 70083 || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
            72250 == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
            72326 <= code && code <= 72329 || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
            73030 == code) {
              return Prepend;
            }
            if (13 == code) {
              return CR;
            }
            if (10 == code) {
              return LF;
            }
            if (0 <= code && code <= 9 || // Cc  [10] <control-0000>..<control-0009>
            11 <= code && code <= 12 || // Cc   [2] <control-000B>..<control-000C>
            14 <= code && code <= 31 || // Cc  [18] <control-000E>..<control-001F>
            127 <= code && code <= 159 || // Cc  [33] <control-007F>..<control-009F>
            173 == code || // Cf       SOFT HYPHEN
            1564 == code || // Cf       ARABIC LETTER MARK
            6158 == code || // Cf       MONGOLIAN VOWEL SEPARATOR
            8203 == code || // Cf       ZERO WIDTH SPACE
            8206 <= code && code <= 8207 || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
            8232 == code || // Zl       LINE SEPARATOR
            8233 == code || // Zp       PARAGRAPH SEPARATOR
            8234 <= code && code <= 8238 || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
            8288 <= code && code <= 8292 || // Cf   [5] WORD JOINER..INVISIBLE PLUS
            8293 == code || // Cn       <reserved-2065>
            8294 <= code && code <= 8303 || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
            55296 <= code && code <= 57343 || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
            65279 == code || // Cf       ZERO WIDTH NO-BREAK SPACE
            65520 <= code && code <= 65528 || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
            65529 <= code && code <= 65531 || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
            113824 <= code && code <= 113827 || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
            119155 <= code && code <= 119162 || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
            917504 == code || // Cn       <reserved-E0000>
            917505 == code || // Cf       LANGUAGE TAG
            917506 <= code && code <= 917535 || // Cn  [30] <reserved-E0002>..<reserved-E001F>
            917632 <= code && code <= 917759 || // Cn [128] <reserved-E0080>..<reserved-E00FF>
            918e3 <= code && code <= 921599) {
              return Control;
            }
            if (768 <= code && code <= 879 || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
            1155 <= code && code <= 1159 || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
            1160 <= code && code <= 1161 || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
            1425 <= code && code <= 1469 || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
            1471 == code || // Mn       HEBREW POINT RAFE
            1473 <= code && code <= 1474 || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
            1476 <= code && code <= 1477 || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
            1479 == code || // Mn       HEBREW POINT QAMATS QATAN
            1552 <= code && code <= 1562 || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
            1611 <= code && code <= 1631 || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
            1648 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
            1750 <= code && code <= 1756 || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
            1759 <= code && code <= 1764 || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
            1767 <= code && code <= 1768 || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
            1770 <= code && code <= 1773 || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
            1809 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
            1840 <= code && code <= 1866 || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
            1958 <= code && code <= 1968 || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
            2027 <= code && code <= 2035 || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
            2070 <= code && code <= 2073 || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
            2075 <= code && code <= 2083 || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
            2085 <= code && code <= 2087 || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
            2089 <= code && code <= 2093 || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
            2137 <= code && code <= 2139 || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
            2260 <= code && code <= 2273 || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
            2275 <= code && code <= 2306 || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
            2362 == code || // Mn       DEVANAGARI VOWEL SIGN OE
            2364 == code || // Mn       DEVANAGARI SIGN NUKTA
            2369 <= code && code <= 2376 || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
            2381 == code || // Mn       DEVANAGARI SIGN VIRAMA
            2385 <= code && code <= 2391 || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
            2402 <= code && code <= 2403 || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
            2433 == code || // Mn       BENGALI SIGN CANDRABINDU
            2492 == code || // Mn       BENGALI SIGN NUKTA
            2494 == code || // Mc       BENGALI VOWEL SIGN AA
            2497 <= code && code <= 2500 || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
            2509 == code || // Mn       BENGALI SIGN VIRAMA
            2519 == code || // Mc       BENGALI AU LENGTH MARK
            2530 <= code && code <= 2531 || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
            2561 <= code && code <= 2562 || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
            2620 == code || // Mn       GURMUKHI SIGN NUKTA
            2625 <= code && code <= 2626 || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
            2631 <= code && code <= 2632 || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
            2635 <= code && code <= 2637 || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
            2641 == code || // Mn       GURMUKHI SIGN UDAAT
            2672 <= code && code <= 2673 || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
            2677 == code || // Mn       GURMUKHI SIGN YAKASH
            2689 <= code && code <= 2690 || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
            2748 == code || // Mn       GUJARATI SIGN NUKTA
            2753 <= code && code <= 2757 || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
            2759 <= code && code <= 2760 || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
            2765 == code || // Mn       GUJARATI SIGN VIRAMA
            2786 <= code && code <= 2787 || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
            2810 <= code && code <= 2815 || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
            2817 == code || // Mn       ORIYA SIGN CANDRABINDU
            2876 == code || // Mn       ORIYA SIGN NUKTA
            2878 == code || // Mc       ORIYA VOWEL SIGN AA
            2879 == code || // Mn       ORIYA VOWEL SIGN I
            2881 <= code && code <= 2884 || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
            2893 == code || // Mn       ORIYA SIGN VIRAMA
            2902 == code || // Mn       ORIYA AI LENGTH MARK
            2903 == code || // Mc       ORIYA AU LENGTH MARK
            2914 <= code && code <= 2915 || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
            2946 == code || // Mn       TAMIL SIGN ANUSVARA
            3006 == code || // Mc       TAMIL VOWEL SIGN AA
            3008 == code || // Mn       TAMIL VOWEL SIGN II
            3021 == code || // Mn       TAMIL SIGN VIRAMA
            3031 == code || // Mc       TAMIL AU LENGTH MARK
            3072 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
            3134 <= code && code <= 3136 || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
            3142 <= code && code <= 3144 || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
            3146 <= code && code <= 3149 || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
            3157 <= code && code <= 3158 || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
            3170 <= code && code <= 3171 || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
            3201 == code || // Mn       KANNADA SIGN CANDRABINDU
            3260 == code || // Mn       KANNADA SIGN NUKTA
            3263 == code || // Mn       KANNADA VOWEL SIGN I
            3266 == code || // Mc       KANNADA VOWEL SIGN UU
            3270 == code || // Mn       KANNADA VOWEL SIGN E
            3276 <= code && code <= 3277 || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
            3285 <= code && code <= 3286 || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
            3298 <= code && code <= 3299 || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
            3328 <= code && code <= 3329 || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
            3387 <= code && code <= 3388 || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
            3390 == code || // Mc       MALAYALAM VOWEL SIGN AA
            3393 <= code && code <= 3396 || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
            3405 == code || // Mn       MALAYALAM SIGN VIRAMA
            3415 == code || // Mc       MALAYALAM AU LENGTH MARK
            3426 <= code && code <= 3427 || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
            3530 == code || // Mn       SINHALA SIGN AL-LAKUNA
            3535 == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
            3538 <= code && code <= 3540 || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
            3542 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
            3551 == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
            3633 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
            3636 <= code && code <= 3642 || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
            3655 <= code && code <= 3662 || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
            3761 == code || // Mn       LAO VOWEL SIGN MAI KAN
            3764 <= code && code <= 3769 || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
            3771 <= code && code <= 3772 || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
            3784 <= code && code <= 3789 || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
            3864 <= code && code <= 3865 || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
            3893 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
            3895 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
            3897 == code || // Mn       TIBETAN MARK TSA -PHRU
            3953 <= code && code <= 3966 || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
            3968 <= code && code <= 3972 || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
            3974 <= code && code <= 3975 || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
            3981 <= code && code <= 3991 || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
            3993 <= code && code <= 4028 || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
            4038 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
            4141 <= code && code <= 4144 || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
            4146 <= code && code <= 4151 || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
            4153 <= code && code <= 4154 || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
            4157 <= code && code <= 4158 || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
            4184 <= code && code <= 4185 || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
            4190 <= code && code <= 4192 || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
            4209 <= code && code <= 4212 || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
            4226 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
            4229 <= code && code <= 4230 || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
            4237 == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
            4253 == code || // Mn       MYANMAR VOWEL SIGN AITON AI
            4957 <= code && code <= 4959 || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
            5906 <= code && code <= 5908 || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
            5938 <= code && code <= 5940 || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
            5970 <= code && code <= 5971 || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
            6002 <= code && code <= 6003 || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
            6068 <= code && code <= 6069 || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
            6071 <= code && code <= 6077 || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
            6086 == code || // Mn       KHMER SIGN NIKAHIT
            6089 <= code && code <= 6099 || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
            6109 == code || // Mn       KHMER SIGN ATTHACAN
            6155 <= code && code <= 6157 || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
            6277 <= code && code <= 6278 || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
            6313 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
            6432 <= code && code <= 6434 || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
            6439 <= code && code <= 6440 || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
            6450 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
            6457 <= code && code <= 6459 || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
            6679 <= code && code <= 6680 || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
            6683 == code || // Mn       BUGINESE VOWEL SIGN AE
            6742 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
            6744 <= code && code <= 6750 || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
            6752 == code || // Mn       TAI THAM SIGN SAKOT
            6754 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
            6757 <= code && code <= 6764 || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
            6771 <= code && code <= 6780 || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
            6783 == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
            6832 <= code && code <= 6845 || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
            6846 == code || // Me       COMBINING PARENTHESES OVERLAY
            6912 <= code && code <= 6915 || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
            6964 == code || // Mn       BALINESE SIGN REREKAN
            6966 <= code && code <= 6970 || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
            6972 == code || // Mn       BALINESE VOWEL SIGN LA LENGA
            6978 == code || // Mn       BALINESE VOWEL SIGN PEPET
            7019 <= code && code <= 7027 || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
            7040 <= code && code <= 7041 || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
            7074 <= code && code <= 7077 || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
            7080 <= code && code <= 7081 || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
            7083 <= code && code <= 7085 || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
            7142 == code || // Mn       BATAK SIGN TOMPI
            7144 <= code && code <= 7145 || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
            7149 == code || // Mn       BATAK VOWEL SIGN KARO O
            7151 <= code && code <= 7153 || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
            7212 <= code && code <= 7219 || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
            7222 <= code && code <= 7223 || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
            7376 <= code && code <= 7378 || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
            7380 <= code && code <= 7392 || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
            7394 <= code && code <= 7400 || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
            7405 == code || // Mn       VEDIC SIGN TIRYAK
            7412 == code || // Mn       VEDIC TONE CANDRA ABOVE
            7416 <= code && code <= 7417 || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
            7616 <= code && code <= 7673 || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
            7675 <= code && code <= 7679 || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
            8204 == code || // Cf       ZERO WIDTH NON-JOINER
            8400 <= code && code <= 8412 || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
            8413 <= code && code <= 8416 || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
            8417 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
            8418 <= code && code <= 8420 || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
            8421 <= code && code <= 8432 || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
            11503 <= code && code <= 11505 || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
            11647 == code || // Mn       TIFINAGH CONSONANT JOINER
            11744 <= code && code <= 11775 || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
            12330 <= code && code <= 12333 || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
            12334 <= code && code <= 12335 || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
            12441 <= code && code <= 12442 || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
            42607 == code || // Mn       COMBINING CYRILLIC VZMET
            42608 <= code && code <= 42610 || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
            42612 <= code && code <= 42621 || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
            42654 <= code && code <= 42655 || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
            42736 <= code && code <= 42737 || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
            43010 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
            43014 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
            43019 == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
            43045 <= code && code <= 43046 || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
            43204 <= code && code <= 43205 || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
            43232 <= code && code <= 43249 || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
            43302 <= code && code <= 43309 || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
            43335 <= code && code <= 43345 || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
            43392 <= code && code <= 43394 || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
            43443 == code || // Mn       JAVANESE SIGN CECAK TELU
            43446 <= code && code <= 43449 || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
            43452 == code || // Mn       JAVANESE VOWEL SIGN PEPET
            43493 == code || // Mn       MYANMAR SIGN SHAN SAW
            43561 <= code && code <= 43566 || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
            43569 <= code && code <= 43570 || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
            43573 <= code && code <= 43574 || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
            43587 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
            43596 == code || // Mn       CHAM CONSONANT SIGN FINAL M
            43644 == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
            43696 == code || // Mn       TAI VIET MAI KANG
            43698 <= code && code <= 43700 || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
            43703 <= code && code <= 43704 || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
            43710 <= code && code <= 43711 || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
            43713 == code || // Mn       TAI VIET TONE MAI THO
            43756 <= code && code <= 43757 || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
            43766 == code || // Mn       MEETEI MAYEK VIRAMA
            44005 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
            44008 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
            44013 == code || // Mn       MEETEI MAYEK APUN IYEK
            64286 == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
            65024 <= code && code <= 65039 || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
            65056 <= code && code <= 65071 || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
            65438 <= code && code <= 65439 || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
            66045 == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
            66272 == code || // Mn       COPTIC EPACT THOUSANDS MARK
            66422 <= code && code <= 66426 || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
            68097 <= code && code <= 68099 || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
            68101 <= code && code <= 68102 || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
            68108 <= code && code <= 68111 || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
            68152 <= code && code <= 68154 || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
            68159 == code || // Mn       KHAROSHTHI VIRAMA
            68325 <= code && code <= 68326 || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
            69633 == code || // Mn       BRAHMI SIGN ANUSVARA
            69688 <= code && code <= 69702 || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
            69759 <= code && code <= 69761 || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
            69811 <= code && code <= 69814 || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
            69817 <= code && code <= 69818 || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
            69888 <= code && code <= 69890 || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
            69927 <= code && code <= 69931 || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
            69933 <= code && code <= 69940 || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
            70003 == code || // Mn       MAHAJANI SIGN NUKTA
            70016 <= code && code <= 70017 || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
            70070 <= code && code <= 70078 || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
            70090 <= code && code <= 70092 || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
            70191 <= code && code <= 70193 || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
            70196 == code || // Mn       KHOJKI SIGN ANUSVARA
            70198 <= code && code <= 70199 || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
            70206 == code || // Mn       KHOJKI SIGN SUKUN
            70367 == code || // Mn       KHUDAWADI SIGN ANUSVARA
            70371 <= code && code <= 70378 || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
            70400 <= code && code <= 70401 || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
            70460 == code || // Mn       GRANTHA SIGN NUKTA
            70462 == code || // Mc       GRANTHA VOWEL SIGN AA
            70464 == code || // Mn       GRANTHA VOWEL SIGN II
            70487 == code || // Mc       GRANTHA AU LENGTH MARK
            70502 <= code && code <= 70508 || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
            70512 <= code && code <= 70516 || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
            70712 <= code && code <= 70719 || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
            70722 <= code && code <= 70724 || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
            70726 == code || // Mn       NEWA SIGN NUKTA
            70832 == code || // Mc       TIRHUTA VOWEL SIGN AA
            70835 <= code && code <= 70840 || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
            70842 == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
            70845 == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
            70847 <= code && code <= 70848 || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
            70850 <= code && code <= 70851 || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
            71087 == code || // Mc       SIDDHAM VOWEL SIGN AA
            71090 <= code && code <= 71093 || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
            71100 <= code && code <= 71101 || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
            71103 <= code && code <= 71104 || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
            71132 <= code && code <= 71133 || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
            71219 <= code && code <= 71226 || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
            71229 == code || // Mn       MODI SIGN ANUSVARA
            71231 <= code && code <= 71232 || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
            71339 == code || // Mn       TAKRI SIGN ANUSVARA
            71341 == code || // Mn       TAKRI VOWEL SIGN AA
            71344 <= code && code <= 71349 || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
            71351 == code || // Mn       TAKRI SIGN NUKTA
            71453 <= code && code <= 71455 || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
            71458 <= code && code <= 71461 || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
            71463 <= code && code <= 71467 || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
            72193 <= code && code <= 72198 || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
            72201 <= code && code <= 72202 || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
            72243 <= code && code <= 72248 || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
            72251 <= code && code <= 72254 || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
            72263 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
            72273 <= code && code <= 72278 || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
            72281 <= code && code <= 72283 || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
            72330 <= code && code <= 72342 || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
            72344 <= code && code <= 72345 || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
            72752 <= code && code <= 72758 || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
            72760 <= code && code <= 72765 || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
            72767 == code || // Mn       BHAIKSUKI SIGN VIRAMA
            72850 <= code && code <= 72871 || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
            72874 <= code && code <= 72880 || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
            72882 <= code && code <= 72883 || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
            72885 <= code && code <= 72886 || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
            73009 <= code && code <= 73014 || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
            73018 == code || // Mn       MASARAM GONDI VOWEL SIGN E
            73020 <= code && code <= 73021 || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
            73023 <= code && code <= 73029 || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
            73031 == code || // Mn       MASARAM GONDI RA-KARA
            92912 <= code && code <= 92916 || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
            92976 <= code && code <= 92982 || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
            94095 <= code && code <= 94098 || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
            113821 <= code && code <= 113822 || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
            119141 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
            119143 <= code && code <= 119145 || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
            119150 <= code && code <= 119154 || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
            119163 <= code && code <= 119170 || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
            119173 <= code && code <= 119179 || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
            119210 <= code && code <= 119213 || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
            119362 <= code && code <= 119364 || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
            121344 <= code && code <= 121398 || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
            121403 <= code && code <= 121452 || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
            121461 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
            121476 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
            121499 <= code && code <= 121503 || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
            121505 <= code && code <= 121519 || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
            122880 <= code && code <= 122886 || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
            122888 <= code && code <= 122904 || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
            122907 <= code && code <= 122913 || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
            122915 <= code && code <= 122916 || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
            122918 <= code && code <= 122922 || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
            125136 <= code && code <= 125142 || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
            125252 <= code && code <= 125258 || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
            917536 <= code && code <= 917631 || // Cf  [96] TAG SPACE..CANCEL TAG
            917760 <= code && code <= 917999) {
              return Extend;
            }
            if (127462 <= code && code <= 127487) {
              return Regional_Indicator;
            }
            if (2307 == code || // Mc       DEVANAGARI SIGN VISARGA
            2363 == code || // Mc       DEVANAGARI VOWEL SIGN OOE
            2366 <= code && code <= 2368 || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
            2377 <= code && code <= 2380 || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
            2382 <= code && code <= 2383 || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
            2434 <= code && code <= 2435 || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
            2495 <= code && code <= 2496 || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
            2503 <= code && code <= 2504 || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
            2507 <= code && code <= 2508 || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
            2563 == code || // Mc       GURMUKHI SIGN VISARGA
            2622 <= code && code <= 2624 || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
            2691 == code || // Mc       GUJARATI SIGN VISARGA
            2750 <= code && code <= 2752 || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
            2761 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
            2763 <= code && code <= 2764 || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
            2818 <= code && code <= 2819 || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
            2880 == code || // Mc       ORIYA VOWEL SIGN II
            2887 <= code && code <= 2888 || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
            2891 <= code && code <= 2892 || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
            3007 == code || // Mc       TAMIL VOWEL SIGN I
            3009 <= code && code <= 3010 || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
            3014 <= code && code <= 3016 || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
            3018 <= code && code <= 3020 || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
            3073 <= code && code <= 3075 || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
            3137 <= code && code <= 3140 || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
            3202 <= code && code <= 3203 || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
            3262 == code || // Mc       KANNADA VOWEL SIGN AA
            3264 <= code && code <= 3265 || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
            3267 <= code && code <= 3268 || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
            3271 <= code && code <= 3272 || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
            3274 <= code && code <= 3275 || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
            3330 <= code && code <= 3331 || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
            3391 <= code && code <= 3392 || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
            3398 <= code && code <= 3400 || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
            3402 <= code && code <= 3404 || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
            3458 <= code && code <= 3459 || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
            3536 <= code && code <= 3537 || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
            3544 <= code && code <= 3550 || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
            3570 <= code && code <= 3571 || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
            3635 == code || // Lo       THAI CHARACTER SARA AM
            3763 == code || // Lo       LAO VOWEL SIGN AM
            3902 <= code && code <= 3903 || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
            3967 == code || // Mc       TIBETAN SIGN RNAM BCAD
            4145 == code || // Mc       MYANMAR VOWEL SIGN E
            4155 <= code && code <= 4156 || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
            4182 <= code && code <= 4183 || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
            4228 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
            6070 == code || // Mc       KHMER VOWEL SIGN AA
            6078 <= code && code <= 6085 || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
            6087 <= code && code <= 6088 || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
            6435 <= code && code <= 6438 || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
            6441 <= code && code <= 6443 || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
            6448 <= code && code <= 6449 || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
            6451 <= code && code <= 6456 || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
            6681 <= code && code <= 6682 || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
            6741 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
            6743 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
            6765 <= code && code <= 6770 || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
            6916 == code || // Mc       BALINESE SIGN BISAH
            6965 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
            6971 == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
            6973 <= code && code <= 6977 || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
            6979 <= code && code <= 6980 || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
            7042 == code || // Mc       SUNDANESE SIGN PANGWISAD
            7073 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
            7078 <= code && code <= 7079 || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
            7082 == code || // Mc       SUNDANESE SIGN PAMAAEH
            7143 == code || // Mc       BATAK VOWEL SIGN E
            7146 <= code && code <= 7148 || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
            7150 == code || // Mc       BATAK VOWEL SIGN U
            7154 <= code && code <= 7155 || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
            7204 <= code && code <= 7211 || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
            7220 <= code && code <= 7221 || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
            7393 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
            7410 <= code && code <= 7411 || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
            7415 == code || // Mc       VEDIC SIGN ATIKRAMA
            43043 <= code && code <= 43044 || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
            43047 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
            43136 <= code && code <= 43137 || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
            43188 <= code && code <= 43203 || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
            43346 <= code && code <= 43347 || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
            43395 == code || // Mc       JAVANESE SIGN WIGNYAN
            43444 <= code && code <= 43445 || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
            43450 <= code && code <= 43451 || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
            43453 <= code && code <= 43456 || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
            43567 <= code && code <= 43568 || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
            43571 <= code && code <= 43572 || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
            43597 == code || // Mc       CHAM CONSONANT SIGN FINAL H
            43755 == code || // Mc       MEETEI MAYEK VOWEL SIGN II
            43758 <= code && code <= 43759 || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
            43765 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
            44003 <= code && code <= 44004 || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
            44006 <= code && code <= 44007 || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
            44009 <= code && code <= 44010 || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
            44012 == code || // Mc       MEETEI MAYEK LUM IYEK
            69632 == code || // Mc       BRAHMI SIGN CANDRABINDU
            69634 == code || // Mc       BRAHMI SIGN VISARGA
            69762 == code || // Mc       KAITHI SIGN VISARGA
            69808 <= code && code <= 69810 || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
            69815 <= code && code <= 69816 || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
            69932 == code || // Mc       CHAKMA VOWEL SIGN E
            70018 == code || // Mc       SHARADA SIGN VISARGA
            70067 <= code && code <= 70069 || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
            70079 <= code && code <= 70080 || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
            70188 <= code && code <= 70190 || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
            70194 <= code && code <= 70195 || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
            70197 == code || // Mc       KHOJKI SIGN VIRAMA
            70368 <= code && code <= 70370 || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
            70402 <= code && code <= 70403 || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
            70463 == code || // Mc       GRANTHA VOWEL SIGN I
            70465 <= code && code <= 70468 || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
            70471 <= code && code <= 70472 || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
            70475 <= code && code <= 70477 || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
            70498 <= code && code <= 70499 || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
            70709 <= code && code <= 70711 || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
            70720 <= code && code <= 70721 || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
            70725 == code || // Mc       NEWA SIGN VISARGA
            70833 <= code && code <= 70834 || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
            70841 == code || // Mc       TIRHUTA VOWEL SIGN E
            70843 <= code && code <= 70844 || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
            70846 == code || // Mc       TIRHUTA VOWEL SIGN AU
            70849 == code || // Mc       TIRHUTA SIGN VISARGA
            71088 <= code && code <= 71089 || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
            71096 <= code && code <= 71099 || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
            71102 == code || // Mc       SIDDHAM SIGN VISARGA
            71216 <= code && code <= 71218 || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
            71227 <= code && code <= 71228 || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
            71230 == code || // Mc       MODI SIGN VISARGA
            71340 == code || // Mc       TAKRI SIGN VISARGA
            71342 <= code && code <= 71343 || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
            71350 == code || // Mc       TAKRI SIGN VIRAMA
            71456 <= code && code <= 71457 || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
            71462 == code || // Mc       AHOM VOWEL SIGN E
            72199 <= code && code <= 72200 || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
            72249 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
            72279 <= code && code <= 72280 || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
            72343 == code || // Mc       SOYOMBO SIGN VISARGA
            72751 == code || // Mc       BHAIKSUKI VOWEL SIGN AA
            72766 == code || // Mc       BHAIKSUKI SIGN VISARGA
            72873 == code || // Mc       MARCHEN SUBJOINED LETTER YA
            72881 == code || // Mc       MARCHEN VOWEL SIGN I
            72884 == code || // Mc       MARCHEN VOWEL SIGN O
            94033 <= code && code <= 94078 || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
            119142 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
            119149 == code) {
              return SpacingMark;
            }
            if (4352 <= code && code <= 4447 || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
            43360 <= code && code <= 43388) {
              return L;
            }
            if (4448 <= code && code <= 4519 || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
            55216 <= code && code <= 55238) {
              return V;
            }
            if (4520 <= code && code <= 4607 || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
            55243 <= code && code <= 55291) {
              return T;
            }
            if (44032 == code || // Lo       HANGUL SYLLABLE GA
            44060 == code || // Lo       HANGUL SYLLABLE GAE
            44088 == code || // Lo       HANGUL SYLLABLE GYA
            44116 == code || // Lo       HANGUL SYLLABLE GYAE
            44144 == code || // Lo       HANGUL SYLLABLE GEO
            44172 == code || // Lo       HANGUL SYLLABLE GE
            44200 == code || // Lo       HANGUL SYLLABLE GYEO
            44228 == code || // Lo       HANGUL SYLLABLE GYE
            44256 == code || // Lo       HANGUL SYLLABLE GO
            44284 == code || // Lo       HANGUL SYLLABLE GWA
            44312 == code || // Lo       HANGUL SYLLABLE GWAE
            44340 == code || // Lo       HANGUL SYLLABLE GOE
            44368 == code || // Lo       HANGUL SYLLABLE GYO
            44396 == code || // Lo       HANGUL SYLLABLE GU
            44424 == code || // Lo       HANGUL SYLLABLE GWEO
            44452 == code || // Lo       HANGUL SYLLABLE GWE
            44480 == code || // Lo       HANGUL SYLLABLE GWI
            44508 == code || // Lo       HANGUL SYLLABLE GYU
            44536 == code || // Lo       HANGUL SYLLABLE GEU
            44564 == code || // Lo       HANGUL SYLLABLE GYI
            44592 == code || // Lo       HANGUL SYLLABLE GI
            44620 == code || // Lo       HANGUL SYLLABLE GGA
            44648 == code || // Lo       HANGUL SYLLABLE GGAE
            44676 == code || // Lo       HANGUL SYLLABLE GGYA
            44704 == code || // Lo       HANGUL SYLLABLE GGYAE
            44732 == code || // Lo       HANGUL SYLLABLE GGEO
            44760 == code || // Lo       HANGUL SYLLABLE GGE
            44788 == code || // Lo       HANGUL SYLLABLE GGYEO
            44816 == code || // Lo       HANGUL SYLLABLE GGYE
            44844 == code || // Lo       HANGUL SYLLABLE GGO
            44872 == code || // Lo       HANGUL SYLLABLE GGWA
            44900 == code || // Lo       HANGUL SYLLABLE GGWAE
            44928 == code || // Lo       HANGUL SYLLABLE GGOE
            44956 == code || // Lo       HANGUL SYLLABLE GGYO
            44984 == code || // Lo       HANGUL SYLLABLE GGU
            45012 == code || // Lo       HANGUL SYLLABLE GGWEO
            45040 == code || // Lo       HANGUL SYLLABLE GGWE
            45068 == code || // Lo       HANGUL SYLLABLE GGWI
            45096 == code || // Lo       HANGUL SYLLABLE GGYU
            45124 == code || // Lo       HANGUL SYLLABLE GGEU
            45152 == code || // Lo       HANGUL SYLLABLE GGYI
            45180 == code || // Lo       HANGUL SYLLABLE GGI
            45208 == code || // Lo       HANGUL SYLLABLE NA
            45236 == code || // Lo       HANGUL SYLLABLE NAE
            45264 == code || // Lo       HANGUL SYLLABLE NYA
            45292 == code || // Lo       HANGUL SYLLABLE NYAE
            45320 == code || // Lo       HANGUL SYLLABLE NEO
            45348 == code || // Lo       HANGUL SYLLABLE NE
            45376 == code || // Lo       HANGUL SYLLABLE NYEO
            45404 == code || // Lo       HANGUL SYLLABLE NYE
            45432 == code || // Lo       HANGUL SYLLABLE NO
            45460 == code || // Lo       HANGUL SYLLABLE NWA
            45488 == code || // Lo       HANGUL SYLLABLE NWAE
            45516 == code || // Lo       HANGUL SYLLABLE NOE
            45544 == code || // Lo       HANGUL SYLLABLE NYO
            45572 == code || // Lo       HANGUL SYLLABLE NU
            45600 == code || // Lo       HANGUL SYLLABLE NWEO
            45628 == code || // Lo       HANGUL SYLLABLE NWE
            45656 == code || // Lo       HANGUL SYLLABLE NWI
            45684 == code || // Lo       HANGUL SYLLABLE NYU
            45712 == code || // Lo       HANGUL SYLLABLE NEU
            45740 == code || // Lo       HANGUL SYLLABLE NYI
            45768 == code || // Lo       HANGUL SYLLABLE NI
            45796 == code || // Lo       HANGUL SYLLABLE DA
            45824 == code || // Lo       HANGUL SYLLABLE DAE
            45852 == code || // Lo       HANGUL SYLLABLE DYA
            45880 == code || // Lo       HANGUL SYLLABLE DYAE
            45908 == code || // Lo       HANGUL SYLLABLE DEO
            45936 == code || // Lo       HANGUL SYLLABLE DE
            45964 == code || // Lo       HANGUL SYLLABLE DYEO
            45992 == code || // Lo       HANGUL SYLLABLE DYE
            46020 == code || // Lo       HANGUL SYLLABLE DO
            46048 == code || // Lo       HANGUL SYLLABLE DWA
            46076 == code || // Lo       HANGUL SYLLABLE DWAE
            46104 == code || // Lo       HANGUL SYLLABLE DOE
            46132 == code || // Lo       HANGUL SYLLABLE DYO
            46160 == code || // Lo       HANGUL SYLLABLE DU
            46188 == code || // Lo       HANGUL SYLLABLE DWEO
            46216 == code || // Lo       HANGUL SYLLABLE DWE
            46244 == code || // Lo       HANGUL SYLLABLE DWI
            46272 == code || // Lo       HANGUL SYLLABLE DYU
            46300 == code || // Lo       HANGUL SYLLABLE DEU
            46328 == code || // Lo       HANGUL SYLLABLE DYI
            46356 == code || // Lo       HANGUL SYLLABLE DI
            46384 == code || // Lo       HANGUL SYLLABLE DDA
            46412 == code || // Lo       HANGUL SYLLABLE DDAE
            46440 == code || // Lo       HANGUL SYLLABLE DDYA
            46468 == code || // Lo       HANGUL SYLLABLE DDYAE
            46496 == code || // Lo       HANGUL SYLLABLE DDEO
            46524 == code || // Lo       HANGUL SYLLABLE DDE
            46552 == code || // Lo       HANGUL SYLLABLE DDYEO
            46580 == code || // Lo       HANGUL SYLLABLE DDYE
            46608 == code || // Lo       HANGUL SYLLABLE DDO
            46636 == code || // Lo       HANGUL SYLLABLE DDWA
            46664 == code || // Lo       HANGUL SYLLABLE DDWAE
            46692 == code || // Lo       HANGUL SYLLABLE DDOE
            46720 == code || // Lo       HANGUL SYLLABLE DDYO
            46748 == code || // Lo       HANGUL SYLLABLE DDU
            46776 == code || // Lo       HANGUL SYLLABLE DDWEO
            46804 == code || // Lo       HANGUL SYLLABLE DDWE
            46832 == code || // Lo       HANGUL SYLLABLE DDWI
            46860 == code || // Lo       HANGUL SYLLABLE DDYU
            46888 == code || // Lo       HANGUL SYLLABLE DDEU
            46916 == code || // Lo       HANGUL SYLLABLE DDYI
            46944 == code || // Lo       HANGUL SYLLABLE DDI
            46972 == code || // Lo       HANGUL SYLLABLE RA
            47e3 == code || // Lo       HANGUL SYLLABLE RAE
            47028 == code || // Lo       HANGUL SYLLABLE RYA
            47056 == code || // Lo       HANGUL SYLLABLE RYAE
            47084 == code || // Lo       HANGUL SYLLABLE REO
            47112 == code || // Lo       HANGUL SYLLABLE RE
            47140 == code || // Lo       HANGUL SYLLABLE RYEO
            47168 == code || // Lo       HANGUL SYLLABLE RYE
            47196 == code || // Lo       HANGUL SYLLABLE RO
            47224 == code || // Lo       HANGUL SYLLABLE RWA
            47252 == code || // Lo       HANGUL SYLLABLE RWAE
            47280 == code || // Lo       HANGUL SYLLABLE ROE
            47308 == code || // Lo       HANGUL SYLLABLE RYO
            47336 == code || // Lo       HANGUL SYLLABLE RU
            47364 == code || // Lo       HANGUL SYLLABLE RWEO
            47392 == code || // Lo       HANGUL SYLLABLE RWE
            47420 == code || // Lo       HANGUL SYLLABLE RWI
            47448 == code || // Lo       HANGUL SYLLABLE RYU
            47476 == code || // Lo       HANGUL SYLLABLE REU
            47504 == code || // Lo       HANGUL SYLLABLE RYI
            47532 == code || // Lo       HANGUL SYLLABLE RI
            47560 == code || // Lo       HANGUL SYLLABLE MA
            47588 == code || // Lo       HANGUL SYLLABLE MAE
            47616 == code || // Lo       HANGUL SYLLABLE MYA
            47644 == code || // Lo       HANGUL SYLLABLE MYAE
            47672 == code || // Lo       HANGUL SYLLABLE MEO
            47700 == code || // Lo       HANGUL SYLLABLE ME
            47728 == code || // Lo       HANGUL SYLLABLE MYEO
            47756 == code || // Lo       HANGUL SYLLABLE MYE
            47784 == code || // Lo       HANGUL SYLLABLE MO
            47812 == code || // Lo       HANGUL SYLLABLE MWA
            47840 == code || // Lo       HANGUL SYLLABLE MWAE
            47868 == code || // Lo       HANGUL SYLLABLE MOE
            47896 == code || // Lo       HANGUL SYLLABLE MYO
            47924 == code || // Lo       HANGUL SYLLABLE MU
            47952 == code || // Lo       HANGUL SYLLABLE MWEO
            47980 == code || // Lo       HANGUL SYLLABLE MWE
            48008 == code || // Lo       HANGUL SYLLABLE MWI
            48036 == code || // Lo       HANGUL SYLLABLE MYU
            48064 == code || // Lo       HANGUL SYLLABLE MEU
            48092 == code || // Lo       HANGUL SYLLABLE MYI
            48120 == code || // Lo       HANGUL SYLLABLE MI
            48148 == code || // Lo       HANGUL SYLLABLE BA
            48176 == code || // Lo       HANGUL SYLLABLE BAE
            48204 == code || // Lo       HANGUL SYLLABLE BYA
            48232 == code || // Lo       HANGUL SYLLABLE BYAE
            48260 == code || // Lo       HANGUL SYLLABLE BEO
            48288 == code || // Lo       HANGUL SYLLABLE BE
            48316 == code || // Lo       HANGUL SYLLABLE BYEO
            48344 == code || // Lo       HANGUL SYLLABLE BYE
            48372 == code || // Lo       HANGUL SYLLABLE BO
            48400 == code || // Lo       HANGUL SYLLABLE BWA
            48428 == code || // Lo       HANGUL SYLLABLE BWAE
            48456 == code || // Lo       HANGUL SYLLABLE BOE
            48484 == code || // Lo       HANGUL SYLLABLE BYO
            48512 == code || // Lo       HANGUL SYLLABLE BU
            48540 == code || // Lo       HANGUL SYLLABLE BWEO
            48568 == code || // Lo       HANGUL SYLLABLE BWE
            48596 == code || // Lo       HANGUL SYLLABLE BWI
            48624 == code || // Lo       HANGUL SYLLABLE BYU
            48652 == code || // Lo       HANGUL SYLLABLE BEU
            48680 == code || // Lo       HANGUL SYLLABLE BYI
            48708 == code || // Lo       HANGUL SYLLABLE BI
            48736 == code || // Lo       HANGUL SYLLABLE BBA
            48764 == code || // Lo       HANGUL SYLLABLE BBAE
            48792 == code || // Lo       HANGUL SYLLABLE BBYA
            48820 == code || // Lo       HANGUL SYLLABLE BBYAE
            48848 == code || // Lo       HANGUL SYLLABLE BBEO
            48876 == code || // Lo       HANGUL SYLLABLE BBE
            48904 == code || // Lo       HANGUL SYLLABLE BBYEO
            48932 == code || // Lo       HANGUL SYLLABLE BBYE
            48960 == code || // Lo       HANGUL SYLLABLE BBO
            48988 == code || // Lo       HANGUL SYLLABLE BBWA
            49016 == code || // Lo       HANGUL SYLLABLE BBWAE
            49044 == code || // Lo       HANGUL SYLLABLE BBOE
            49072 == code || // Lo       HANGUL SYLLABLE BBYO
            49100 == code || // Lo       HANGUL SYLLABLE BBU
            49128 == code || // Lo       HANGUL SYLLABLE BBWEO
            49156 == code || // Lo       HANGUL SYLLABLE BBWE
            49184 == code || // Lo       HANGUL SYLLABLE BBWI
            49212 == code || // Lo       HANGUL SYLLABLE BBYU
            49240 == code || // Lo       HANGUL SYLLABLE BBEU
            49268 == code || // Lo       HANGUL SYLLABLE BBYI
            49296 == code || // Lo       HANGUL SYLLABLE BBI
            49324 == code || // Lo       HANGUL SYLLABLE SA
            49352 == code || // Lo       HANGUL SYLLABLE SAE
            49380 == code || // Lo       HANGUL SYLLABLE SYA
            49408 == code || // Lo       HANGUL SYLLABLE SYAE
            49436 == code || // Lo       HANGUL SYLLABLE SEO
            49464 == code || // Lo       HANGUL SYLLABLE SE
            49492 == code || // Lo       HANGUL SYLLABLE SYEO
            49520 == code || // Lo       HANGUL SYLLABLE SYE
            49548 == code || // Lo       HANGUL SYLLABLE SO
            49576 == code || // Lo       HANGUL SYLLABLE SWA
            49604 == code || // Lo       HANGUL SYLLABLE SWAE
            49632 == code || // Lo       HANGUL SYLLABLE SOE
            49660 == code || // Lo       HANGUL SYLLABLE SYO
            49688 == code || // Lo       HANGUL SYLLABLE SU
            49716 == code || // Lo       HANGUL SYLLABLE SWEO
            49744 == code || // Lo       HANGUL SYLLABLE SWE
            49772 == code || // Lo       HANGUL SYLLABLE SWI
            49800 == code || // Lo       HANGUL SYLLABLE SYU
            49828 == code || // Lo       HANGUL SYLLABLE SEU
            49856 == code || // Lo       HANGUL SYLLABLE SYI
            49884 == code || // Lo       HANGUL SYLLABLE SI
            49912 == code || // Lo       HANGUL SYLLABLE SSA
            49940 == code || // Lo       HANGUL SYLLABLE SSAE
            49968 == code || // Lo       HANGUL SYLLABLE SSYA
            49996 == code || // Lo       HANGUL SYLLABLE SSYAE
            50024 == code || // Lo       HANGUL SYLLABLE SSEO
            50052 == code || // Lo       HANGUL SYLLABLE SSE
            50080 == code || // Lo       HANGUL SYLLABLE SSYEO
            50108 == code || // Lo       HANGUL SYLLABLE SSYE
            50136 == code || // Lo       HANGUL SYLLABLE SSO
            50164 == code || // Lo       HANGUL SYLLABLE SSWA
            50192 == code || // Lo       HANGUL SYLLABLE SSWAE
            50220 == code || // Lo       HANGUL SYLLABLE SSOE
            50248 == code || // Lo       HANGUL SYLLABLE SSYO
            50276 == code || // Lo       HANGUL SYLLABLE SSU
            50304 == code || // Lo       HANGUL SYLLABLE SSWEO
            50332 == code || // Lo       HANGUL SYLLABLE SSWE
            50360 == code || // Lo       HANGUL SYLLABLE SSWI
            50388 == code || // Lo       HANGUL SYLLABLE SSYU
            50416 == code || // Lo       HANGUL SYLLABLE SSEU
            50444 == code || // Lo       HANGUL SYLLABLE SSYI
            50472 == code || // Lo       HANGUL SYLLABLE SSI
            50500 == code || // Lo       HANGUL SYLLABLE A
            50528 == code || // Lo       HANGUL SYLLABLE AE
            50556 == code || // Lo       HANGUL SYLLABLE YA
            50584 == code || // Lo       HANGUL SYLLABLE YAE
            50612 == code || // Lo       HANGUL SYLLABLE EO
            50640 == code || // Lo       HANGUL SYLLABLE E
            50668 == code || // Lo       HANGUL SYLLABLE YEO
            50696 == code || // Lo       HANGUL SYLLABLE YE
            50724 == code || // Lo       HANGUL SYLLABLE O
            50752 == code || // Lo       HANGUL SYLLABLE WA
            50780 == code || // Lo       HANGUL SYLLABLE WAE
            50808 == code || // Lo       HANGUL SYLLABLE OE
            50836 == code || // Lo       HANGUL SYLLABLE YO
            50864 == code || // Lo       HANGUL SYLLABLE U
            50892 == code || // Lo       HANGUL SYLLABLE WEO
            50920 == code || // Lo       HANGUL SYLLABLE WE
            50948 == code || // Lo       HANGUL SYLLABLE WI
            50976 == code || // Lo       HANGUL SYLLABLE YU
            51004 == code || // Lo       HANGUL SYLLABLE EU
            51032 == code || // Lo       HANGUL SYLLABLE YI
            51060 == code || // Lo       HANGUL SYLLABLE I
            51088 == code || // Lo       HANGUL SYLLABLE JA
            51116 == code || // Lo       HANGUL SYLLABLE JAE
            51144 == code || // Lo       HANGUL SYLLABLE JYA
            51172 == code || // Lo       HANGUL SYLLABLE JYAE
            51200 == code || // Lo       HANGUL SYLLABLE JEO
            51228 == code || // Lo       HANGUL SYLLABLE JE
            51256 == code || // Lo       HANGUL SYLLABLE JYEO
            51284 == code || // Lo       HANGUL SYLLABLE JYE
            51312 == code || // Lo       HANGUL SYLLABLE JO
            51340 == code || // Lo       HANGUL SYLLABLE JWA
            51368 == code || // Lo       HANGUL SYLLABLE JWAE
            51396 == code || // Lo       HANGUL SYLLABLE JOE
            51424 == code || // Lo       HANGUL SYLLABLE JYO
            51452 == code || // Lo       HANGUL SYLLABLE JU
            51480 == code || // Lo       HANGUL SYLLABLE JWEO
            51508 == code || // Lo       HANGUL SYLLABLE JWE
            51536 == code || // Lo       HANGUL SYLLABLE JWI
            51564 == code || // Lo       HANGUL SYLLABLE JYU
            51592 == code || // Lo       HANGUL SYLLABLE JEU
            51620 == code || // Lo       HANGUL SYLLABLE JYI
            51648 == code || // Lo       HANGUL SYLLABLE JI
            51676 == code || // Lo       HANGUL SYLLABLE JJA
            51704 == code || // Lo       HANGUL SYLLABLE JJAE
            51732 == code || // Lo       HANGUL SYLLABLE JJYA
            51760 == code || // Lo       HANGUL SYLLABLE JJYAE
            51788 == code || // Lo       HANGUL SYLLABLE JJEO
            51816 == code || // Lo       HANGUL SYLLABLE JJE
            51844 == code || // Lo       HANGUL SYLLABLE JJYEO
            51872 == code || // Lo       HANGUL SYLLABLE JJYE
            51900 == code || // Lo       HANGUL SYLLABLE JJO
            51928 == code || // Lo       HANGUL SYLLABLE JJWA
            51956 == code || // Lo       HANGUL SYLLABLE JJWAE
            51984 == code || // Lo       HANGUL SYLLABLE JJOE
            52012 == code || // Lo       HANGUL SYLLABLE JJYO
            52040 == code || // Lo       HANGUL SYLLABLE JJU
            52068 == code || // Lo       HANGUL SYLLABLE JJWEO
            52096 == code || // Lo       HANGUL SYLLABLE JJWE
            52124 == code || // Lo       HANGUL SYLLABLE JJWI
            52152 == code || // Lo       HANGUL SYLLABLE JJYU
            52180 == code || // Lo       HANGUL SYLLABLE JJEU
            52208 == code || // Lo       HANGUL SYLLABLE JJYI
            52236 == code || // Lo       HANGUL SYLLABLE JJI
            52264 == code || // Lo       HANGUL SYLLABLE CA
            52292 == code || // Lo       HANGUL SYLLABLE CAE
            52320 == code || // Lo       HANGUL SYLLABLE CYA
            52348 == code || // Lo       HANGUL SYLLABLE CYAE
            52376 == code || // Lo       HANGUL SYLLABLE CEO
            52404 == code || // Lo       HANGUL SYLLABLE CE
            52432 == code || // Lo       HANGUL SYLLABLE CYEO
            52460 == code || // Lo       HANGUL SYLLABLE CYE
            52488 == code || // Lo       HANGUL SYLLABLE CO
            52516 == code || // Lo       HANGUL SYLLABLE CWA
            52544 == code || // Lo       HANGUL SYLLABLE CWAE
            52572 == code || // Lo       HANGUL SYLLABLE COE
            52600 == code || // Lo       HANGUL SYLLABLE CYO
            52628 == code || // Lo       HANGUL SYLLABLE CU
            52656 == code || // Lo       HANGUL SYLLABLE CWEO
            52684 == code || // Lo       HANGUL SYLLABLE CWE
            52712 == code || // Lo       HANGUL SYLLABLE CWI
            52740 == code || // Lo       HANGUL SYLLABLE CYU
            52768 == code || // Lo       HANGUL SYLLABLE CEU
            52796 == code || // Lo       HANGUL SYLLABLE CYI
            52824 == code || // Lo       HANGUL SYLLABLE CI
            52852 == code || // Lo       HANGUL SYLLABLE KA
            52880 == code || // Lo       HANGUL SYLLABLE KAE
            52908 == code || // Lo       HANGUL SYLLABLE KYA
            52936 == code || // Lo       HANGUL SYLLABLE KYAE
            52964 == code || // Lo       HANGUL SYLLABLE KEO
            52992 == code || // Lo       HANGUL SYLLABLE KE
            53020 == code || // Lo       HANGUL SYLLABLE KYEO
            53048 == code || // Lo       HANGUL SYLLABLE KYE
            53076 == code || // Lo       HANGUL SYLLABLE KO
            53104 == code || // Lo       HANGUL SYLLABLE KWA
            53132 == code || // Lo       HANGUL SYLLABLE KWAE
            53160 == code || // Lo       HANGUL SYLLABLE KOE
            53188 == code || // Lo       HANGUL SYLLABLE KYO
            53216 == code || // Lo       HANGUL SYLLABLE KU
            53244 == code || // Lo       HANGUL SYLLABLE KWEO
            53272 == code || // Lo       HANGUL SYLLABLE KWE
            53300 == code || // Lo       HANGUL SYLLABLE KWI
            53328 == code || // Lo       HANGUL SYLLABLE KYU
            53356 == code || // Lo       HANGUL SYLLABLE KEU
            53384 == code || // Lo       HANGUL SYLLABLE KYI
            53412 == code || // Lo       HANGUL SYLLABLE KI
            53440 == code || // Lo       HANGUL SYLLABLE TA
            53468 == code || // Lo       HANGUL SYLLABLE TAE
            53496 == code || // Lo       HANGUL SYLLABLE TYA
            53524 == code || // Lo       HANGUL SYLLABLE TYAE
            53552 == code || // Lo       HANGUL SYLLABLE TEO
            53580 == code || // Lo       HANGUL SYLLABLE TE
            53608 == code || // Lo       HANGUL SYLLABLE TYEO
            53636 == code || // Lo       HANGUL SYLLABLE TYE
            53664 == code || // Lo       HANGUL SYLLABLE TO
            53692 == code || // Lo       HANGUL SYLLABLE TWA
            53720 == code || // Lo       HANGUL SYLLABLE TWAE
            53748 == code || // Lo       HANGUL SYLLABLE TOE
            53776 == code || // Lo       HANGUL SYLLABLE TYO
            53804 == code || // Lo       HANGUL SYLLABLE TU
            53832 == code || // Lo       HANGUL SYLLABLE TWEO
            53860 == code || // Lo       HANGUL SYLLABLE TWE
            53888 == code || // Lo       HANGUL SYLLABLE TWI
            53916 == code || // Lo       HANGUL SYLLABLE TYU
            53944 == code || // Lo       HANGUL SYLLABLE TEU
            53972 == code || // Lo       HANGUL SYLLABLE TYI
            54e3 == code || // Lo       HANGUL SYLLABLE TI
            54028 == code || // Lo       HANGUL SYLLABLE PA
            54056 == code || // Lo       HANGUL SYLLABLE PAE
            54084 == code || // Lo       HANGUL SYLLABLE PYA
            54112 == code || // Lo       HANGUL SYLLABLE PYAE
            54140 == code || // Lo       HANGUL SYLLABLE PEO
            54168 == code || // Lo       HANGUL SYLLABLE PE
            54196 == code || // Lo       HANGUL SYLLABLE PYEO
            54224 == code || // Lo       HANGUL SYLLABLE PYE
            54252 == code || // Lo       HANGUL SYLLABLE PO
            54280 == code || // Lo       HANGUL SYLLABLE PWA
            54308 == code || // Lo       HANGUL SYLLABLE PWAE
            54336 == code || // Lo       HANGUL SYLLABLE POE
            54364 == code || // Lo       HANGUL SYLLABLE PYO
            54392 == code || // Lo       HANGUL SYLLABLE PU
            54420 == code || // Lo       HANGUL SYLLABLE PWEO
            54448 == code || // Lo       HANGUL SYLLABLE PWE
            54476 == code || // Lo       HANGUL SYLLABLE PWI
            54504 == code || // Lo       HANGUL SYLLABLE PYU
            54532 == code || // Lo       HANGUL SYLLABLE PEU
            54560 == code || // Lo       HANGUL SYLLABLE PYI
            54588 == code || // Lo       HANGUL SYLLABLE PI
            54616 == code || // Lo       HANGUL SYLLABLE HA
            54644 == code || // Lo       HANGUL SYLLABLE HAE
            54672 == code || // Lo       HANGUL SYLLABLE HYA
            54700 == code || // Lo       HANGUL SYLLABLE HYAE
            54728 == code || // Lo       HANGUL SYLLABLE HEO
            54756 == code || // Lo       HANGUL SYLLABLE HE
            54784 == code || // Lo       HANGUL SYLLABLE HYEO
            54812 == code || // Lo       HANGUL SYLLABLE HYE
            54840 == code || // Lo       HANGUL SYLLABLE HO
            54868 == code || // Lo       HANGUL SYLLABLE HWA
            54896 == code || // Lo       HANGUL SYLLABLE HWAE
            54924 == code || // Lo       HANGUL SYLLABLE HOE
            54952 == code || // Lo       HANGUL SYLLABLE HYO
            54980 == code || // Lo       HANGUL SYLLABLE HU
            55008 == code || // Lo       HANGUL SYLLABLE HWEO
            55036 == code || // Lo       HANGUL SYLLABLE HWE
            55064 == code || // Lo       HANGUL SYLLABLE HWI
            55092 == code || // Lo       HANGUL SYLLABLE HYU
            55120 == code || // Lo       HANGUL SYLLABLE HEU
            55148 == code || // Lo       HANGUL SYLLABLE HYI
            55176 == code) {
              return LV;
            }
            if (44033 <= code && code <= 44059 || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
            44061 <= code && code <= 44087 || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
            44089 <= code && code <= 44115 || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
            44117 <= code && code <= 44143 || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
            44145 <= code && code <= 44171 || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
            44173 <= code && code <= 44199 || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
            44201 <= code && code <= 44227 || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
            44229 <= code && code <= 44255 || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
            44257 <= code && code <= 44283 || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
            44285 <= code && code <= 44311 || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
            44313 <= code && code <= 44339 || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
            44341 <= code && code <= 44367 || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
            44369 <= code && code <= 44395 || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
            44397 <= code && code <= 44423 || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
            44425 <= code && code <= 44451 || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
            44453 <= code && code <= 44479 || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
            44481 <= code && code <= 44507 || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
            44509 <= code && code <= 44535 || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
            44537 <= code && code <= 44563 || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
            44565 <= code && code <= 44591 || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
            44593 <= code && code <= 44619 || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
            44621 <= code && code <= 44647 || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
            44649 <= code && code <= 44675 || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
            44677 <= code && code <= 44703 || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
            44705 <= code && code <= 44731 || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
            44733 <= code && code <= 44759 || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
            44761 <= code && code <= 44787 || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
            44789 <= code && code <= 44815 || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
            44817 <= code && code <= 44843 || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
            44845 <= code && code <= 44871 || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
            44873 <= code && code <= 44899 || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
            44901 <= code && code <= 44927 || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
            44929 <= code && code <= 44955 || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
            44957 <= code && code <= 44983 || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
            44985 <= code && code <= 45011 || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
            45013 <= code && code <= 45039 || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
            45041 <= code && code <= 45067 || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
            45069 <= code && code <= 45095 || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
            45097 <= code && code <= 45123 || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
            45125 <= code && code <= 45151 || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
            45153 <= code && code <= 45179 || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
            45181 <= code && code <= 45207 || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
            45209 <= code && code <= 45235 || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
            45237 <= code && code <= 45263 || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
            45265 <= code && code <= 45291 || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
            45293 <= code && code <= 45319 || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
            45321 <= code && code <= 45347 || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
            45349 <= code && code <= 45375 || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
            45377 <= code && code <= 45403 || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
            45405 <= code && code <= 45431 || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
            45433 <= code && code <= 45459 || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
            45461 <= code && code <= 45487 || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
            45489 <= code && code <= 45515 || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
            45517 <= code && code <= 45543 || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
            45545 <= code && code <= 45571 || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
            45573 <= code && code <= 45599 || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
            45601 <= code && code <= 45627 || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
            45629 <= code && code <= 45655 || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
            45657 <= code && code <= 45683 || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
            45685 <= code && code <= 45711 || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
            45713 <= code && code <= 45739 || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
            45741 <= code && code <= 45767 || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
            45769 <= code && code <= 45795 || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
            45797 <= code && code <= 45823 || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
            45825 <= code && code <= 45851 || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
            45853 <= code && code <= 45879 || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
            45881 <= code && code <= 45907 || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
            45909 <= code && code <= 45935 || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
            45937 <= code && code <= 45963 || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
            45965 <= code && code <= 45991 || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
            45993 <= code && code <= 46019 || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
            46021 <= code && code <= 46047 || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
            46049 <= code && code <= 46075 || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
            46077 <= code && code <= 46103 || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
            46105 <= code && code <= 46131 || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
            46133 <= code && code <= 46159 || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
            46161 <= code && code <= 46187 || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
            46189 <= code && code <= 46215 || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
            46217 <= code && code <= 46243 || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
            46245 <= code && code <= 46271 || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
            46273 <= code && code <= 46299 || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
            46301 <= code && code <= 46327 || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
            46329 <= code && code <= 46355 || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
            46357 <= code && code <= 46383 || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
            46385 <= code && code <= 46411 || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
            46413 <= code && code <= 46439 || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
            46441 <= code && code <= 46467 || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
            46469 <= code && code <= 46495 || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
            46497 <= code && code <= 46523 || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
            46525 <= code && code <= 46551 || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
            46553 <= code && code <= 46579 || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
            46581 <= code && code <= 46607 || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
            46609 <= code && code <= 46635 || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
            46637 <= code && code <= 46663 || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
            46665 <= code && code <= 46691 || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
            46693 <= code && code <= 46719 || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
            46721 <= code && code <= 46747 || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
            46749 <= code && code <= 46775 || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
            46777 <= code && code <= 46803 || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
            46805 <= code && code <= 46831 || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
            46833 <= code && code <= 46859 || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
            46861 <= code && code <= 46887 || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
            46889 <= code && code <= 46915 || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
            46917 <= code && code <= 46943 || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
            46945 <= code && code <= 46971 || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
            46973 <= code && code <= 46999 || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
            47001 <= code && code <= 47027 || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
            47029 <= code && code <= 47055 || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
            47057 <= code && code <= 47083 || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
            47085 <= code && code <= 47111 || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
            47113 <= code && code <= 47139 || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
            47141 <= code && code <= 47167 || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
            47169 <= code && code <= 47195 || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
            47197 <= code && code <= 47223 || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
            47225 <= code && code <= 47251 || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
            47253 <= code && code <= 47279 || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
            47281 <= code && code <= 47307 || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
            47309 <= code && code <= 47335 || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
            47337 <= code && code <= 47363 || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
            47365 <= code && code <= 47391 || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
            47393 <= code && code <= 47419 || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
            47421 <= code && code <= 47447 || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
            47449 <= code && code <= 47475 || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
            47477 <= code && code <= 47503 || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
            47505 <= code && code <= 47531 || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
            47533 <= code && code <= 47559 || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
            47561 <= code && code <= 47587 || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
            47589 <= code && code <= 47615 || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
            47617 <= code && code <= 47643 || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
            47645 <= code && code <= 47671 || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
            47673 <= code && code <= 47699 || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
            47701 <= code && code <= 47727 || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
            47729 <= code && code <= 47755 || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
            47757 <= code && code <= 47783 || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
            47785 <= code && code <= 47811 || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
            47813 <= code && code <= 47839 || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
            47841 <= code && code <= 47867 || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
            47869 <= code && code <= 47895 || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
            47897 <= code && code <= 47923 || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
            47925 <= code && code <= 47951 || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
            47953 <= code && code <= 47979 || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
            47981 <= code && code <= 48007 || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
            48009 <= code && code <= 48035 || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
            48037 <= code && code <= 48063 || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
            48065 <= code && code <= 48091 || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
            48093 <= code && code <= 48119 || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
            48121 <= code && code <= 48147 || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
            48149 <= code && code <= 48175 || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
            48177 <= code && code <= 48203 || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
            48205 <= code && code <= 48231 || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
            48233 <= code && code <= 48259 || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
            48261 <= code && code <= 48287 || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
            48289 <= code && code <= 48315 || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
            48317 <= code && code <= 48343 || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
            48345 <= code && code <= 48371 || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
            48373 <= code && code <= 48399 || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
            48401 <= code && code <= 48427 || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
            48429 <= code && code <= 48455 || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
            48457 <= code && code <= 48483 || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
            48485 <= code && code <= 48511 || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
            48513 <= code && code <= 48539 || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
            48541 <= code && code <= 48567 || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
            48569 <= code && code <= 48595 || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
            48597 <= code && code <= 48623 || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
            48625 <= code && code <= 48651 || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
            48653 <= code && code <= 48679 || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
            48681 <= code && code <= 48707 || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
            48709 <= code && code <= 48735 || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
            48737 <= code && code <= 48763 || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
            48765 <= code && code <= 48791 || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
            48793 <= code && code <= 48819 || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
            48821 <= code && code <= 48847 || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
            48849 <= code && code <= 48875 || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
            48877 <= code && code <= 48903 || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
            48905 <= code && code <= 48931 || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
            48933 <= code && code <= 48959 || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
            48961 <= code && code <= 48987 || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
            48989 <= code && code <= 49015 || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
            49017 <= code && code <= 49043 || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
            49045 <= code && code <= 49071 || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
            49073 <= code && code <= 49099 || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
            49101 <= code && code <= 49127 || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
            49129 <= code && code <= 49155 || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
            49157 <= code && code <= 49183 || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
            49185 <= code && code <= 49211 || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
            49213 <= code && code <= 49239 || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
            49241 <= code && code <= 49267 || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
            49269 <= code && code <= 49295 || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
            49297 <= code && code <= 49323 || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
            49325 <= code && code <= 49351 || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
            49353 <= code && code <= 49379 || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
            49381 <= code && code <= 49407 || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
            49409 <= code && code <= 49435 || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
            49437 <= code && code <= 49463 || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
            49465 <= code && code <= 49491 || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
            49493 <= code && code <= 49519 || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
            49521 <= code && code <= 49547 || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
            49549 <= code && code <= 49575 || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
            49577 <= code && code <= 49603 || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
            49605 <= code && code <= 49631 || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
            49633 <= code && code <= 49659 || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
            49661 <= code && code <= 49687 || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
            49689 <= code && code <= 49715 || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
            49717 <= code && code <= 49743 || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
            49745 <= code && code <= 49771 || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
            49773 <= code && code <= 49799 || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
            49801 <= code && code <= 49827 || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
            49829 <= code && code <= 49855 || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
            49857 <= code && code <= 49883 || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
            49885 <= code && code <= 49911 || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
            49913 <= code && code <= 49939 || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
            49941 <= code && code <= 49967 || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
            49969 <= code && code <= 49995 || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
            49997 <= code && code <= 50023 || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
            50025 <= code && code <= 50051 || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
            50053 <= code && code <= 50079 || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
            50081 <= code && code <= 50107 || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
            50109 <= code && code <= 50135 || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
            50137 <= code && code <= 50163 || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
            50165 <= code && code <= 50191 || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
            50193 <= code && code <= 50219 || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
            50221 <= code && code <= 50247 || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
            50249 <= code && code <= 50275 || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
            50277 <= code && code <= 50303 || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
            50305 <= code && code <= 50331 || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
            50333 <= code && code <= 50359 || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
            50361 <= code && code <= 50387 || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
            50389 <= code && code <= 50415 || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
            50417 <= code && code <= 50443 || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
            50445 <= code && code <= 50471 || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
            50473 <= code && code <= 50499 || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
            50501 <= code && code <= 50527 || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
            50529 <= code && code <= 50555 || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
            50557 <= code && code <= 50583 || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
            50585 <= code && code <= 50611 || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
            50613 <= code && code <= 50639 || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
            50641 <= code && code <= 50667 || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
            50669 <= code && code <= 50695 || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
            50697 <= code && code <= 50723 || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
            50725 <= code && code <= 50751 || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
            50753 <= code && code <= 50779 || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
            50781 <= code && code <= 50807 || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
            50809 <= code && code <= 50835 || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
            50837 <= code && code <= 50863 || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
            50865 <= code && code <= 50891 || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
            50893 <= code && code <= 50919 || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
            50921 <= code && code <= 50947 || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
            50949 <= code && code <= 50975 || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
            50977 <= code && code <= 51003 || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
            51005 <= code && code <= 51031 || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
            51033 <= code && code <= 51059 || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
            51061 <= code && code <= 51087 || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
            51089 <= code && code <= 51115 || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
            51117 <= code && code <= 51143 || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
            51145 <= code && code <= 51171 || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
            51173 <= code && code <= 51199 || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
            51201 <= code && code <= 51227 || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
            51229 <= code && code <= 51255 || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
            51257 <= code && code <= 51283 || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
            51285 <= code && code <= 51311 || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
            51313 <= code && code <= 51339 || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
            51341 <= code && code <= 51367 || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
            51369 <= code && code <= 51395 || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
            51397 <= code && code <= 51423 || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
            51425 <= code && code <= 51451 || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
            51453 <= code && code <= 51479 || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
            51481 <= code && code <= 51507 || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
            51509 <= code && code <= 51535 || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
            51537 <= code && code <= 51563 || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
            51565 <= code && code <= 51591 || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
            51593 <= code && code <= 51619 || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
            51621 <= code && code <= 51647 || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
            51649 <= code && code <= 51675 || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
            51677 <= code && code <= 51703 || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
            51705 <= code && code <= 51731 || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
            51733 <= code && code <= 51759 || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
            51761 <= code && code <= 51787 || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
            51789 <= code && code <= 51815 || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
            51817 <= code && code <= 51843 || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
            51845 <= code && code <= 51871 || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
            51873 <= code && code <= 51899 || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
            51901 <= code && code <= 51927 || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
            51929 <= code && code <= 51955 || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
            51957 <= code && code <= 51983 || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
            51985 <= code && code <= 52011 || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
            52013 <= code && code <= 52039 || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
            52041 <= code && code <= 52067 || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
            52069 <= code && code <= 52095 || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
            52097 <= code && code <= 52123 || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
            52125 <= code && code <= 52151 || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
            52153 <= code && code <= 52179 || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
            52181 <= code && code <= 52207 || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
            52209 <= code && code <= 52235 || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
            52237 <= code && code <= 52263 || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
            52265 <= code && code <= 52291 || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
            52293 <= code && code <= 52319 || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
            52321 <= code && code <= 52347 || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
            52349 <= code && code <= 52375 || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
            52377 <= code && code <= 52403 || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
            52405 <= code && code <= 52431 || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
            52433 <= code && code <= 52459 || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
            52461 <= code && code <= 52487 || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
            52489 <= code && code <= 52515 || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
            52517 <= code && code <= 52543 || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
            52545 <= code && code <= 52571 || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
            52573 <= code && code <= 52599 || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
            52601 <= code && code <= 52627 || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
            52629 <= code && code <= 52655 || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
            52657 <= code && code <= 52683 || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
            52685 <= code && code <= 52711 || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
            52713 <= code && code <= 52739 || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
            52741 <= code && code <= 52767 || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
            52769 <= code && code <= 52795 || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
            52797 <= code && code <= 52823 || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
            52825 <= code && code <= 52851 || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
            52853 <= code && code <= 52879 || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
            52881 <= code && code <= 52907 || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
            52909 <= code && code <= 52935 || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
            52937 <= code && code <= 52963 || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
            52965 <= code && code <= 52991 || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
            52993 <= code && code <= 53019 || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
            53021 <= code && code <= 53047 || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
            53049 <= code && code <= 53075 || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
            53077 <= code && code <= 53103 || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
            53105 <= code && code <= 53131 || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
            53133 <= code && code <= 53159 || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
            53161 <= code && code <= 53187 || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
            53189 <= code && code <= 53215 || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
            53217 <= code && code <= 53243 || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
            53245 <= code && code <= 53271 || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
            53273 <= code && code <= 53299 || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
            53301 <= code && code <= 53327 || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
            53329 <= code && code <= 53355 || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
            53357 <= code && code <= 53383 || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
            53385 <= code && code <= 53411 || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
            53413 <= code && code <= 53439 || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
            53441 <= code && code <= 53467 || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
            53469 <= code && code <= 53495 || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
            53497 <= code && code <= 53523 || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
            53525 <= code && code <= 53551 || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
            53553 <= code && code <= 53579 || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
            53581 <= code && code <= 53607 || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
            53609 <= code && code <= 53635 || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
            53637 <= code && code <= 53663 || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
            53665 <= code && code <= 53691 || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
            53693 <= code && code <= 53719 || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
            53721 <= code && code <= 53747 || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
            53749 <= code && code <= 53775 || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
            53777 <= code && code <= 53803 || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
            53805 <= code && code <= 53831 || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
            53833 <= code && code <= 53859 || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
            53861 <= code && code <= 53887 || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
            53889 <= code && code <= 53915 || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
            53917 <= code && code <= 53943 || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
            53945 <= code && code <= 53971 || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
            53973 <= code && code <= 53999 || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
            54001 <= code && code <= 54027 || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
            54029 <= code && code <= 54055 || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
            54057 <= code && code <= 54083 || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
            54085 <= code && code <= 54111 || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
            54113 <= code && code <= 54139 || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
            54141 <= code && code <= 54167 || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
            54169 <= code && code <= 54195 || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
            54197 <= code && code <= 54223 || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
            54225 <= code && code <= 54251 || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
            54253 <= code && code <= 54279 || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
            54281 <= code && code <= 54307 || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
            54309 <= code && code <= 54335 || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
            54337 <= code && code <= 54363 || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
            54365 <= code && code <= 54391 || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
            54393 <= code && code <= 54419 || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
            54421 <= code && code <= 54447 || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
            54449 <= code && code <= 54475 || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
            54477 <= code && code <= 54503 || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
            54505 <= code && code <= 54531 || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
            54533 <= code && code <= 54559 || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
            54561 <= code && code <= 54587 || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
            54589 <= code && code <= 54615 || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
            54617 <= code && code <= 54643 || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
            54645 <= code && code <= 54671 || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
            54673 <= code && code <= 54699 || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
            54701 <= code && code <= 54727 || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
            54729 <= code && code <= 54755 || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
            54757 <= code && code <= 54783 || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
            54785 <= code && code <= 54811 || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
            54813 <= code && code <= 54839 || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
            54841 <= code && code <= 54867 || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
            54869 <= code && code <= 54895 || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
            54897 <= code && code <= 54923 || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
            54925 <= code && code <= 54951 || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
            54953 <= code && code <= 54979 || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
            54981 <= code && code <= 55007 || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
            55009 <= code && code <= 55035 || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
            55037 <= code && code <= 55063 || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
            55065 <= code && code <= 55091 || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
            55093 <= code && code <= 55119 || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
            55121 <= code && code <= 55147 || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
            55149 <= code && code <= 55175 || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
            55177 <= code && code <= 55203) {
              return LVT;
            }
            if (9757 == code || // So       WHITE UP POINTING INDEX
            9977 == code || // So       PERSON WITH BALL
            9994 <= code && code <= 9997 || // So   [4] RAISED FIST..WRITING HAND
            127877 == code || // So       FATHER CHRISTMAS
            127938 <= code && code <= 127940 || // So   [3] SNOWBOARDER..SURFER
            127943 == code || // So       HORSE RACING
            127946 <= code && code <= 127948 || // So   [3] SWIMMER..GOLFER
            128066 <= code && code <= 128067 || // So   [2] EAR..NOSE
            128070 <= code && code <= 128080 || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
            128110 == code || // So       POLICE OFFICER
            128112 <= code && code <= 128120 || // So   [9] BRIDE WITH VEIL..PRINCESS
            128124 == code || // So       BABY ANGEL
            128129 <= code && code <= 128131 || // So   [3] INFORMATION DESK PERSON..DANCER
            128133 <= code && code <= 128135 || // So   [3] NAIL POLISH..HAIRCUT
            128170 == code || // So       FLEXED BICEPS
            128372 <= code && code <= 128373 || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
            128378 == code || // So       MAN DANCING
            128400 == code || // So       RAISED HAND WITH FINGERS SPLAYED
            128405 <= code && code <= 128406 || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
            128581 <= code && code <= 128583 || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
            128587 <= code && code <= 128591 || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
            128675 == code || // So       ROWBOAT
            128692 <= code && code <= 128694 || // So   [3] BICYCLIST..PEDESTRIAN
            128704 == code || // So       BATH
            128716 == code || // So       SLEEPING ACCOMMODATION
            129304 <= code && code <= 129308 || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
            129310 <= code && code <= 129311 || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
            129318 == code || // So       FACE PALM
            129328 <= code && code <= 129337 || // So  [10] PREGNANT WOMAN..JUGGLING
            129341 <= code && code <= 129342 || // So   [2] WATER POLO..HANDBALL
            129489 <= code && code <= 129501) {
              return E_Base;
            }
            if (127995 <= code && code <= 127999) {
              return E_Modifier;
            }
            if (8205 == code) {
              return ZWJ;
            }
            if (9792 == code || // So       FEMALE SIGN
            9794 == code || // So       MALE SIGN
            9877 <= code && code <= 9878 || // So   [2] STAFF OF AESCULAPIUS..SCALES
            9992 == code || // So       AIRPLANE
            10084 == code || // So       HEAVY BLACK HEART
            127752 == code || // So       RAINBOW
            127806 == code || // So       EAR OF RICE
            127859 == code || // So       COOKING
            127891 == code || // So       GRADUATION CAP
            127908 == code || // So       MICROPHONE
            127912 == code || // So       ARTIST PALETTE
            127979 == code || // So       SCHOOL
            127981 == code || // So       FACTORY
            128139 == code || // So       KISS MARK
            128187 <= code && code <= 128188 || // So   [2] PERSONAL COMPUTER..BRIEFCASE
            128295 == code || // So       WRENCH
            128300 == code || // So       MICROSCOPE
            128488 == code || // So       LEFT SPEECH BUBBLE
            128640 == code || // So       ROCKET
            128658 == code) {
              return Glue_After_Zwj;
            }
            if (128102 <= code && code <= 128105) {
              return E_Base_GAZ;
            }
            return Other;
          }
          __name(getGraphemeBreakProperty, "getGraphemeBreakProperty");
          return this;
        }
        __name(GraphemeSplitter, "GraphemeSplitter");
        if (module3.exports) {
          module3.exports = GraphemeSplitter;
        }
      });
      var splitter = new graphemeSplitter();
      var substring = /* @__PURE__ */ __name(function substring2(str, start, end) {
        var iterator = splitter.iterateGraphemes(str.substring(start));
        var value = "";
        for (var pos = 0; pos < end - start; pos++) {
          var next = iterator.next();
          value += next.value;
          if (next.done) {
            break;
          }
        }
        return value;
      }, "substring");
      var location = /* @__PURE__ */ __name(function(startLine, startColumn, startOffset, endLine, endColumn, endOffset, source) {
        return {
          start: {
            line: startLine,
            column: startColumn,
            offset: startOffset
          },
          end: {
            line: endLine,
            column: endColumn,
            offset: endOffset
          },
          source: source || null
        };
      }, "location");
      var build = createCommonjsModule(function(module3, exports3) {
        (function(global2, factory) {
          module3.exports = factory();
        })(commonjsGlobal, function() {
          "use strict";
          "use strict";
          var res = "";
          var cache;
          var repeatString = repeat;
          function repeat(str, num) {
            if (typeof str !== "string") {
              throw new TypeError("expected a string");
            }
            if (num === 1) return str;
            if (num === 2) return str + str;
            var max = str.length * num;
            if (cache !== str || typeof cache === "undefined") {
              cache = str;
              res = "";
            } else if (res.length >= max) {
              return res.substr(0, max);
            }
            while (max > res.length && num > 1) {
              if (num & 1) {
                res += str;
              }
              num >>= 1;
              str += str;
            }
            res += str;
            res = res.substr(0, max);
            return res;
          }
          __name(repeat, "repeat");
          "use strict";
          var padStart = /* @__PURE__ */ __name(function padStart2(string, maxLength, fillString) {
            if (string == null || maxLength == null) {
              return string;
            }
            var result = String(string);
            var targetLen = typeof maxLength === "number" ? maxLength : parseInt(maxLength, 10);
            if (isNaN(targetLen) || !isFinite(targetLen)) {
              return result;
            }
            var length = result.length;
            if (length >= targetLen) {
              return result;
            }
            var fill = fillString == null ? "" : String(fillString);
            if (fill === "") {
              fill = " ";
            }
            var fillLen = targetLen - length;
            while (fill.length < fillLen) {
              fill += fill;
            }
            var truncated = fill.length > fillLen ? fill.substr(0, fillLen) : fill;
            return truncated + result;
          }, "padStart");
          var _extends = Object.assign || function(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          function printLine(line, position, maxNumLength, settings) {
            var num = String(position);
            var formattedNum = padStart(num, maxNumLength, " ");
            var tabReplacement = repeatString(" ", settings.tabSize);
            return formattedNum + " | " + line.replace(/\t/g, tabReplacement);
          }
          __name(printLine, "printLine");
          function printLines(lines, start, end, maxNumLength, settings) {
            return lines.slice(start, end).map(function(line, i2) {
              return printLine(line, start + i2 + 1, maxNumLength, settings);
            }).join("\n");
          }
          __name(printLines, "printLines");
          var defaultSettings2 = {
            extraLines: 2,
            tabSize: 4
          };
          var index = /* @__PURE__ */ __name(function index2(input, linePos, columnPos, settings) {
            settings = _extends({}, defaultSettings2, settings);
            var lines = input.split(/\r\n?|\n|\f/);
            var startLinePos = Math.max(1, linePos - settings.extraLines) - 1;
            var endLinePos = Math.min(linePos + settings.extraLines, lines.length);
            var maxNumLength = String(endLinePos).length;
            var prevLines = printLines(lines, startLinePos, linePos, maxNumLength, settings);
            var targetLineBeforeCursor = printLine(lines[linePos - 1].substring(0, columnPos - 1), linePos, maxNumLength, settings);
            var cursorLine = repeatString(" ", targetLineBeforeCursor.length) + "^";
            var nextLines = printLines(lines, linePos, endLinePos, maxNumLength, settings);
            return [prevLines, cursorLine, nextLines].filter(Boolean).join("\n");
          }, "index");
          return index;
        });
      });
      var errorStack = new Error().stack;
      var createError = /* @__PURE__ */ __name(function(props) {
        var error2 = Object.create(SyntaxError.prototype);
        Object.assign(error2, props, {
          name: "SyntaxError"
        });
        Object.defineProperty(error2, "stack", {
          get: /* @__PURE__ */ __name(function get() {
            return errorStack ? errorStack.replace(/^(.+\n){1,3}/, String(error2) + "\n") : "";
          }, "get")
        });
        return error2;
      }, "createError");
      var error = /* @__PURE__ */ __name(function(message, input, source, line, column) {
        throw createError({
          message: line ? message + "\n" + build(input, line, column) : message,
          rawMessage: message,
          source,
          line,
          column
        });
      }, "error");
      var parseErrorTypes = {
        unexpectedEnd: /* @__PURE__ */ __name(function unexpectedEnd() {
          return "Unexpected end of input";
        }, "unexpectedEnd"),
        unexpectedToken: /* @__PURE__ */ __name(function unexpectedToken(token) {
          for (var _len = arguments.length, position = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            position[_key - 1] = arguments[_key];
          }
          return "Unexpected token <" + token + "> at " + position.filter(Boolean).join(":");
        }, "unexpectedToken")
      };
      var tokenizeErrorTypes = {
        unexpectedSymbol: /* @__PURE__ */ __name(function unexpectedSymbol(symbol) {
          for (var _len = arguments.length, position = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            position[_key - 1] = arguments[_key];
          }
          return "Unexpected symbol <" + symbol + "> at " + position.filter(Boolean).join(":");
        }, "unexpectedSymbol")
      };
      var tokenTypes = {
        LEFT_BRACE: 0,
        // {
        RIGHT_BRACE: 1,
        // }
        LEFT_BRACKET: 2,
        // [
        RIGHT_BRACKET: 3,
        // ]
        COLON: 4,
        // :
        COMMA: 5,
        // ,
        STRING: 6,
        //
        NUMBER: 7,
        //
        TRUE: 8,
        // true
        FALSE: 9,
        // false
        NULL: 10
        // null
      };
      var punctuatorTokensMap = {
        // Lexeme: Token
        "{": tokenTypes.LEFT_BRACE,
        "}": tokenTypes.RIGHT_BRACE,
        "[": tokenTypes.LEFT_BRACKET,
        "]": tokenTypes.RIGHT_BRACKET,
        ":": tokenTypes.COLON,
        ",": tokenTypes.COMMA
      };
      var keywordTokensMap = {
        // Lexeme: Token
        "true": tokenTypes.TRUE,
        "false": tokenTypes.FALSE,
        "null": tokenTypes.NULL
      };
      var stringStates = {
        _START_: 0,
        START_QUOTE_OR_CHAR: 1,
        ESCAPE: 2
      };
      var escapes$1 = {
        '"': 0,
        // Quotation mask
        "\\": 1,
        // Reverse solidus
        "/": 2,
        // Solidus
        "b": 3,
        // Backspace
        "f": 4,
        // Form feed
        "n": 5,
        // New line
        "r": 6,
        // Carriage return
        "t": 7,
        // Horizontal tab
        "u": 8
        // 4 hexadecimal digits
      };
      var numberStates = {
        _START_: 0,
        MINUS: 1,
        ZERO: 2,
        DIGIT: 3,
        POINT: 4,
        DIGIT_FRACTION: 5,
        EXP: 6,
        EXP_DIGIT_OR_SIGN: 7
      };
      function isDigit1to9(char) {
        return char >= "1" && char <= "9";
      }
      __name(isDigit1to9, "isDigit1to9");
      function isDigit(char) {
        return char >= "0" && char <= "9";
      }
      __name(isDigit, "isDigit");
      function isHex(char) {
        return isDigit(char) || char >= "a" && char <= "f" || char >= "A" && char <= "F";
      }
      __name(isHex, "isHex");
      function isExp(char) {
        return char === "e" || char === "E";
      }
      __name(isExp, "isExp");
      function parseWhitespace(input, index, line, column) {
        var char = input.charAt(index);
        if (char === "\r") {
          index++;
          line++;
          column = 1;
          if (input.charAt(index) === "\n") {
            index++;
          }
        } else if (char === "\n") {
          index++;
          line++;
          column = 1;
        } else if (char === "	" || char === " ") {
          index++;
          column++;
        } else {
          return null;
        }
        return {
          index,
          line,
          column
        };
      }
      __name(parseWhitespace, "parseWhitespace");
      function parseChar(input, index, line, column) {
        var char = input.charAt(index);
        if (char in punctuatorTokensMap) {
          return {
            type: punctuatorTokensMap[char],
            line,
            column: column + 1,
            index: index + 1,
            value: null
          };
        }
        return null;
      }
      __name(parseChar, "parseChar");
      function parseKeyword(input, index, line, column) {
        for (var name in keywordTokensMap) {
          if (keywordTokensMap.hasOwnProperty(name) && input.substr(index, name.length) === name) {
            return {
              type: keywordTokensMap[name],
              line,
              column: column + name.length,
              index: index + name.length,
              value: name
            };
          }
        }
        return null;
      }
      __name(parseKeyword, "parseKeyword");
      function parseString$1(input, index, line, column) {
        var startIndex = index;
        var state = stringStates._START_;
        while (index < input.length) {
          var char = input.charAt(index);
          switch (state) {
            case stringStates._START_: {
              if (char === '"') {
                index++;
                state = stringStates.START_QUOTE_OR_CHAR;
              } else {
                return null;
              }
              break;
            }
            case stringStates.START_QUOTE_OR_CHAR: {
              if (char === "\\") {
                index++;
                state = stringStates.ESCAPE;
              } else if (char === '"') {
                index++;
                return {
                  type: tokenTypes.STRING,
                  line,
                  column: column + index - startIndex,
                  index,
                  value: input.slice(startIndex, index)
                };
              } else {
                index++;
              }
              break;
            }
            case stringStates.ESCAPE: {
              if (char in escapes$1) {
                index++;
                if (char === "u") {
                  for (var i2 = 0; i2 < 4; i2++) {
                    var curChar = input.charAt(index);
                    if (curChar && isHex(curChar)) {
                      index++;
                    } else {
                      return null;
                    }
                  }
                }
                state = stringStates.START_QUOTE_OR_CHAR;
              } else {
                return null;
              }
              break;
            }
          }
        }
      }
      __name(parseString$1, "parseString$1");
      function parseNumber(input, index, line, column) {
        var startIndex = index;
        var passedValueIndex = index;
        var state = numberStates._START_;
        iterator: while (index < input.length) {
          var char = input.charAt(index);
          switch (state) {
            case numberStates._START_: {
              if (char === "-") {
                state = numberStates.MINUS;
              } else if (char === "0") {
                passedValueIndex = index + 1;
                state = numberStates.ZERO;
              } else if (isDigit1to9(char)) {
                passedValueIndex = index + 1;
                state = numberStates.DIGIT;
              } else {
                return null;
              }
              break;
            }
            case numberStates.MINUS: {
              if (char === "0") {
                passedValueIndex = index + 1;
                state = numberStates.ZERO;
              } else if (isDigit1to9(char)) {
                passedValueIndex = index + 1;
                state = numberStates.DIGIT;
              } else {
                return null;
              }
              break;
            }
            case numberStates.ZERO: {
              if (char === ".") {
                state = numberStates.POINT;
              } else if (isExp(char)) {
                state = numberStates.EXP;
              } else {
                break iterator;
              }
              break;
            }
            case numberStates.DIGIT: {
              if (isDigit(char)) {
                passedValueIndex = index + 1;
              } else if (char === ".") {
                state = numberStates.POINT;
              } else if (isExp(char)) {
                state = numberStates.EXP;
              } else {
                break iterator;
              }
              break;
            }
            case numberStates.POINT: {
              if (isDigit(char)) {
                passedValueIndex = index + 1;
                state = numberStates.DIGIT_FRACTION;
              } else {
                break iterator;
              }
              break;
            }
            case numberStates.DIGIT_FRACTION: {
              if (isDigit(char)) {
                passedValueIndex = index + 1;
              } else if (isExp(char)) {
                state = numberStates.EXP;
              } else {
                break iterator;
              }
              break;
            }
            case numberStates.EXP: {
              if (char === "+" || char === "-") {
                state = numberStates.EXP_DIGIT_OR_SIGN;
              } else if (isDigit(char)) {
                passedValueIndex = index + 1;
                state = numberStates.EXP_DIGIT_OR_SIGN;
              } else {
                break iterator;
              }
              break;
            }
            case numberStates.EXP_DIGIT_OR_SIGN: {
              if (isDigit(char)) {
                passedValueIndex = index + 1;
              } else {
                break iterator;
              }
              break;
            }
          }
          index++;
        }
        if (passedValueIndex > 0) {
          return {
            type: tokenTypes.NUMBER,
            line,
            column: column + passedValueIndex - startIndex,
            index: passedValueIndex,
            value: input.slice(startIndex, passedValueIndex)
          };
        }
        return null;
      }
      __name(parseNumber, "parseNumber");
      var tokenize = /* @__PURE__ */ __name(function tokenize2(input, settings) {
        var line = 1;
        var column = 1;
        var index = 0;
        var tokens = [];
        while (index < input.length) {
          var args = [input, index, line, column];
          var whitespace = parseWhitespace.apply(void 0, args);
          if (whitespace) {
            index = whitespace.index;
            line = whitespace.line;
            column = whitespace.column;
            continue;
          }
          var matched = parseChar.apply(void 0, args) || parseKeyword.apply(void 0, args) || parseString$1.apply(void 0, args) || parseNumber.apply(void 0, args);
          if (matched) {
            var token = {
              type: matched.type,
              value: matched.value,
              loc: location(line, column, index, matched.line, matched.column, matched.index, settings.source)
            };
            tokens.push(token);
            index = matched.index;
            line = matched.line;
            column = matched.column;
          } else {
            error(tokenizeErrorTypes.unexpectedSymbol(substring(input, index, index + 1), settings.source, line, column), input, settings.source, line, column);
          }
        }
        return tokens;
      }, "tokenize");
      var objectStates = {
        _START_: 0,
        OPEN_OBJECT: 1,
        PROPERTY: 2,
        COMMA: 3
      };
      var propertyStates = {
        _START_: 0,
        KEY: 1,
        COLON: 2
      };
      var arrayStates = {
        _START_: 0,
        OPEN_ARRAY: 1,
        VALUE: 2,
        COMMA: 3
      };
      var defaultSettings = {
        loc: true,
        source: null
      };
      function errorEof(input, tokenList, settings) {
        var loc = tokenList.length > 0 ? tokenList[tokenList.length - 1].loc.end : { line: 1, column: 1 };
        error(parseErrorTypes.unexpectedEnd(), input, settings.source, loc.line, loc.column);
      }
      __name(errorEof, "errorEof");
      function parseHexEscape(hexCode) {
        var charCode = 0;
        for (var i2 = 0; i2 < 4; i2++) {
          charCode = charCode * 16 + parseInt(hexCode[i2], 16);
        }
        return String.fromCharCode(charCode);
      }
      __name(parseHexEscape, "parseHexEscape");
      var escapes = {
        "b": "\b",
        // Backspace
        "f": "\f",
        // Form feed
        "n": "\n",
        // New line
        "r": "\r",
        // Carriage return
        "t": "	"
        // Horizontal tab
      };
      var passEscapes = ['"', "\\", "/"];
      function parseString(string) {
        var result = "";
        for (var i2 = 0; i2 < string.length; i2++) {
          var char = string.charAt(i2);
          if (char === "\\") {
            i2++;
            var nextChar = string.charAt(i2);
            if (nextChar === "u") {
              result += parseHexEscape(string.substr(i2 + 1, 4));
              i2 += 4;
            } else if (passEscapes.indexOf(nextChar) !== -1) {
              result += nextChar;
            } else if (nextChar in escapes) {
              result += escapes[nextChar];
            } else {
              break;
            }
          } else {
            result += char;
          }
        }
        return result;
      }
      __name(parseString, "parseString");
      function parseObject(input, tokenList, index, settings) {
        var startToken = void 0;
        var object = {
          type: "Object",
          children: []
        };
        var state = objectStates._START_;
        while (index < tokenList.length) {
          var token = tokenList[index];
          switch (state) {
            case objectStates._START_: {
              if (token.type === tokenTypes.LEFT_BRACE) {
                startToken = token;
                state = objectStates.OPEN_OBJECT;
                index++;
              } else {
                return null;
              }
              break;
            }
            case objectStates.OPEN_OBJECT: {
              if (token.type === tokenTypes.RIGHT_BRACE) {
                if (settings.loc) {
                  object.loc = location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                }
                return {
                  value: object,
                  index: index + 1
                };
              } else {
                var property = parseProperty(input, tokenList, index, settings);
                object.children.push(property.value);
                state = objectStates.PROPERTY;
                index = property.index;
              }
              break;
            }
            case objectStates.PROPERTY: {
              if (token.type === tokenTypes.RIGHT_BRACE) {
                if (settings.loc) {
                  object.loc = location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                }
                return {
                  value: object,
                  index: index + 1
                };
              } else if (token.type === tokenTypes.COMMA) {
                state = objectStates.COMMA;
                index++;
              } else {
                error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
              }
              break;
            }
            case objectStates.COMMA: {
              var _property = parseProperty(input, tokenList, index, settings);
              if (_property) {
                index = _property.index;
                object.children.push(_property.value);
                state = objectStates.PROPERTY;
              } else {
                error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
              }
              break;
            }
          }
        }
        errorEof(input, tokenList, settings);
      }
      __name(parseObject, "parseObject");
      function parseProperty(input, tokenList, index, settings) {
        var startToken = void 0;
        var property = {
          type: "Property",
          key: null,
          value: null
        };
        var state = propertyStates._START_;
        while (index < tokenList.length) {
          var token = tokenList[index];
          switch (state) {
            case propertyStates._START_: {
              if (token.type === tokenTypes.STRING) {
                var key = {
                  type: "Identifier",
                  value: parseString(input.slice(token.loc.start.offset + 1, token.loc.end.offset - 1)),
                  raw: token.value
                };
                if (settings.loc) {
                  key.loc = token.loc;
                }
                startToken = token;
                property.key = key;
                state = propertyStates.KEY;
                index++;
              } else {
                return null;
              }
              break;
            }
            case propertyStates.KEY: {
              if (token.type === tokenTypes.COLON) {
                state = propertyStates.COLON;
                index++;
              } else {
                error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
              }
              break;
            }
            case propertyStates.COLON: {
              var value = parseValue(input, tokenList, index, settings);
              property.value = value.value;
              if (settings.loc) {
                property.loc = location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, value.value.loc.end.line, value.value.loc.end.column, value.value.loc.end.offset, settings.source);
              }
              return {
                value: property,
                index: value.index
              };
            }
          }
        }
      }
      __name(parseProperty, "parseProperty");
      function parseArray(input, tokenList, index, settings) {
        var startToken = void 0;
        var array = {
          type: "Array",
          children: []
        };
        var state = arrayStates._START_;
        var token = void 0;
        while (index < tokenList.length) {
          token = tokenList[index];
          switch (state) {
            case arrayStates._START_: {
              if (token.type === tokenTypes.LEFT_BRACKET) {
                startToken = token;
                state = arrayStates.OPEN_ARRAY;
                index++;
              } else {
                return null;
              }
              break;
            }
            case arrayStates.OPEN_ARRAY: {
              if (token.type === tokenTypes.RIGHT_BRACKET) {
                if (settings.loc) {
                  array.loc = location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                }
                return {
                  value: array,
                  index: index + 1
                };
              } else {
                var value = parseValue(input, tokenList, index, settings);
                index = value.index;
                array.children.push(value.value);
                state = arrayStates.VALUE;
              }
              break;
            }
            case arrayStates.VALUE: {
              if (token.type === tokenTypes.RIGHT_BRACKET) {
                if (settings.loc) {
                  array.loc = location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                }
                return {
                  value: array,
                  index: index + 1
                };
              } else if (token.type === tokenTypes.COMMA) {
                state = arrayStates.COMMA;
                index++;
              } else {
                error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
              }
              break;
            }
            case arrayStates.COMMA: {
              var _value = parseValue(input, tokenList, index, settings);
              index = _value.index;
              array.children.push(_value.value);
              state = arrayStates.VALUE;
              break;
            }
          }
        }
        errorEof(input, tokenList, settings);
      }
      __name(parseArray, "parseArray");
      function parseLiteral(input, tokenList, index, settings) {
        var token = tokenList[index];
        var value = null;
        switch (token.type) {
          case tokenTypes.STRING: {
            value = parseString(input.slice(token.loc.start.offset + 1, token.loc.end.offset - 1));
            break;
          }
          case tokenTypes.NUMBER: {
            value = Number(token.value);
            break;
          }
          case tokenTypes.TRUE: {
            value = true;
            break;
          }
          case tokenTypes.FALSE: {
            value = false;
            break;
          }
          case tokenTypes.NULL: {
            value = null;
            break;
          }
          default: {
            return null;
          }
        }
        var literal = {
          type: "Literal",
          value,
          raw: token.value
        };
        if (settings.loc) {
          literal.loc = token.loc;
        }
        return {
          value: literal,
          index: index + 1
        };
      }
      __name(parseLiteral, "parseLiteral");
      function parseValue(input, tokenList, index, settings) {
        var token = tokenList[index];
        var value = parseLiteral.apply(void 0, arguments) || parseObject.apply(void 0, arguments) || parseArray.apply(void 0, arguments);
        if (value) {
          return value;
        } else {
          error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
        }
      }
      __name(parseValue, "parseValue");
      var parse$1 = /* @__PURE__ */ __name(function(input, settings) {
        settings = Object.assign({}, defaultSettings, settings);
        var tokenList = tokenize(input, settings);
        if (tokenList.length === 0) {
          errorEof(input, tokenList, settings);
        }
        var value = parseValue(input, tokenList, 0, settings);
        if (value.index === tokenList.length) {
          return value.value;
        }
        var token = tokenList[value.index];
        error(parseErrorTypes.unexpectedToken(substring(input, token.loc.start.offset, token.loc.end.offset), settings.source, token.loc.start.line, token.loc.start.column), input, settings.source, token.loc.start.line, token.loc.start.column);
      }, "parse$1");
      return parse$1;
    });
  }
});

// node_modules/tus-js-client/lib.es5/error.js
var require_error = __commonJS({
  "node_modules/tus-js-client/lib.es5/error.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _callSuper(t, o2, e) {
      return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
    }
    __name(_callSuper, "_callSuper");
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    __name(_possibleConstructorReturn, "_possibleConstructorReturn");
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    __name(_assertThisInitialized, "_assertThisInitialized");
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    __name(_inherits, "_inherits");
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = /* @__PURE__ */ __name(function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        __name(Wrapper, "Wrapper");
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      }, "_wrapNativeSuper");
      return _wrapNativeSuper(Class);
    }
    __name(_wrapNativeSuper, "_wrapNativeSuper");
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o2 = [null];
      o2.push.apply(o2, e);
      var p = new (t.bind.apply(t, o2))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    __name(_construct, "_construct");
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
        return !!t;
      }, "_isNativeReflectConstruct"))();
    }
    __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }
    __name(_isNativeFunction, "_isNativeFunction");
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      }, "_setPrototypeOf");
      return _setPrototypeOf(o2, p);
    }
    __name(_setPrototypeOf, "_setPrototypeOf");
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, "_getPrototypeOf");
      return _getPrototypeOf(o2);
    }
    __name(_getPrototypeOf, "_getPrototypeOf");
    var DetailedError = /* @__PURE__ */ function(_Error) {
      function DetailedError2(message) {
        var _this;
        var causingErr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var req = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var res = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        _classCallCheck(this, DetailedError2);
        _this = _callSuper(this, DetailedError2, [message]);
        _this.originalRequest = req;
        _this.originalResponse = res;
        _this.causingError = causingErr;
        if (causingErr != null) {
          message += ", caused by ".concat(causingErr.toString());
        }
        if (req != null) {
          var requestId = req.getHeader("X-Request-ID") || "n/a";
          var method = req.getMethod();
          var url = req.getURL();
          var status = res ? res.getStatus() : "n/a";
          var body = res ? res.getBody() || "" : "n/a";
          message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
        }
        _this.message = message;
        return _this;
      }
      __name(DetailedError2, "DetailedError");
      _inherits(DetailedError2, _Error);
      return _createClass(DetailedError2);
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var _default = exports2.default = DetailedError;
  }
});

// node_modules/tus-js-client/lib.es5/logger.js
var require_logger = __commonJS({
  "node_modules/tus-js-client/lib.es5/logger.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.enableDebugLog = enableDebugLog;
    exports2.log = log3;
    var isEnabled = false;
    function enableDebugLog() {
      isEnabled = true;
    }
    __name(enableDebugLog, "enableDebugLog");
    function log3(msg) {
      if (!isEnabled) return;
      console.log(msg);
    }
    __name(log3, "log");
  }
});

// node_modules/tus-js-client/lib.es5/noopUrlStorage.js
var require_noopUrlStorage = __commonJS({
  "node_modules/tus-js-client/lib.es5/noopUrlStorage.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var NoopUrlStorage = exports2.default = /* @__PURE__ */ function() {
      function NoopUrlStorage2() {
        _classCallCheck(this, NoopUrlStorage2);
      }
      __name(NoopUrlStorage2, "NoopUrlStorage");
      return _createClass(NoopUrlStorage2, [{
        key: "listAllUploads",
        value: /* @__PURE__ */ __name(function listAllUploads() {
          return Promise.resolve([]);
        }, "listAllUploads")
      }, {
        key: "findUploadsByFingerprint",
        value: /* @__PURE__ */ __name(function findUploadsByFingerprint(_fingerprint) {
          return Promise.resolve([]);
        }, "findUploadsByFingerprint")
      }, {
        key: "removeUpload",
        value: /* @__PURE__ */ __name(function removeUpload(_urlStorageKey) {
          return Promise.resolve();
        }, "removeUpload")
      }, {
        key: "addUpload",
        value: /* @__PURE__ */ __name(function addUpload(_fingerprint, _upload) {
          return Promise.resolve(null);
        }, "addUpload")
      }]);
    }();
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports2, module2) {
    init_esm();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports2, function() {
      "use strict";
      var version2 = "3.7.8";
      var VERSION = version2;
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a2) {
        var tab = {};
        a2.forEach(function(c3, i2) {
          return tab[c3] = i2;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = /* @__PURE__ */ __name(function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      }, "_mkUriSafe");
      var _tidyB64 = /* @__PURE__ */ __name(function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      }, "_tidyB64");
      var btoaPolyfill = /* @__PURE__ */ __name(function(bin) {
        var u32, c0, c1, c22, asc = "";
        var pad = bin.length % 3;
        for (var i2 = 0; i2 < bin.length; ) {
          if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c22 = bin.charCodeAt(i2++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c22;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      }, "btoaPolyfill");
      var _btoa = typeof btoa === "function" ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = /* @__PURE__ */ __name(function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      }, "fromUint8Array");
      var cb_utob = /* @__PURE__ */ __name(function(c3) {
        if (c3.length < 2) {
          var cc = c3.charCodeAt(0);
          return cc < 128 ? c3 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c3.charCodeAt(0) - 55296) * 1024 + (c3.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      }, "cb_utob");
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = /* @__PURE__ */ __name(function(u2) {
        return u2.replace(re_utob, cb_utob);
      }, "utob");
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode = /* @__PURE__ */ __name(function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      }, "encode");
      var encodeURI2 = /* @__PURE__ */ __name(function(src) {
        return encode(src, true);
      }, "encodeURI");
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = /* @__PURE__ */ __name(function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      }, "cb_btou");
      var btou = /* @__PURE__ */ __name(function(b) {
        return b.replace(re_btou, cb_btou);
      }, "btou");
      var atobPolyfill = /* @__PURE__ */ __name(function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, r1, r2;
        var binArray = [];
        for (var i2 = 0; i2 < asc.length; ) {
          u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
          if (r1 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255));
          } else if (r2 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
          } else {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
          }
        }
        return binArray.join("");
      }, "atobPolyfill");
      var _atob = typeof atob === "function" ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a2) {
        return _U8Afrom(Buffer.from(a2, "base64"));
      } : function(a2) {
        return _U8Afrom(_atob(a2).split("").map(function(c3) {
          return c3.charCodeAt(0);
        }));
      };
      var toUint8Array = /* @__PURE__ */ __name(function(a2) {
        return _toUint8Array(_unURI(a2));
      }, "toUint8Array");
      var _decode = _hasBuffer ? function(a2) {
        return Buffer.from(a2, "base64").toString("utf8");
      } : _TD ? function(a2) {
        return _TD.decode(_toUint8Array(a2));
      } : function(a2) {
        return btou(_atob(a2));
      };
      var _unURI = /* @__PURE__ */ __name(function(a2) {
        return _tidyB64(a2.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      }, "_unURI");
      var decode = /* @__PURE__ */ __name(function(src) {
        return _decode(_unURI(src));
      }, "decode");
      var isValid = /* @__PURE__ */ __name(function(src) {
        if (typeof src !== "string")
          return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      }, "isValid");
      var _noEnum = /* @__PURE__ */ __name(function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      }, "_noEnum");
      var extendString = /* @__PURE__ */ __name(function() {
        var _add = /* @__PURE__ */ __name(function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        }, "_add");
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      }, "extendString");
      var extendUint8Array = /* @__PURE__ */ __name(function() {
        var _add = /* @__PURE__ */ __name(function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        }, "_add");
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      }, "extendUint8Array");
      var extendBuiltins = /* @__PURE__ */ __name(function() {
        extendString();
        extendUint8Array();
      }, "extendBuiltins");
      var gBase64 = {
        version: version2,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI: encodeURI2,
        encodeURL: encodeURI2,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = /* @__PURE__ */ __name(function required(port2, protocol) {
      protocol = protocol.split(":")[0];
      port2 = +port2;
      if (!port2) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port2 !== 80;
        case "https":
        case "wss":
          return port2 !== 443;
        case "ftp":
          return port2 !== 21;
        case "gopher":
          return port2 !== 70;
        case "file":
          return false;
      }
      return port2 !== 0;
    }, "required");
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports2) {
    "use strict";
    init_esm();
    var has2 = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    __name(decode, "decode");
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    __name(encode, "encode");
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode(part[1]), value = decode(part[2]);
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }
      return result;
    }
    __name(querystring, "querystring");
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix) prefix = "?";
      for (key in obj) {
        if (has2.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode(key);
          value = encode(value);
          if (key === null || value === null) continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    __name(querystringify, "querystringify");
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port2 = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    __name(trimLeft, "trimLeft");
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      /* @__PURE__ */ __name(function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      }, "sanitize"),
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined") globalVar = window;
      else if (typeof global !== "undefined") globalVar = global;
      else if (typeof self !== "undefined") globalVar = self;
      else globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    __name(lolcation, "lolcation");
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    __name(isSpecial, "isSpecial");
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    __name(extractProtocol, "extractProtocol");
    function resolve(relative, base) {
      if (relative === "") return base;
      var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path2.length, last = path2[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path2[i2] === ".") {
          path2.splice(i2, 1);
        } else if (path2[i2] === "..") {
          path2.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0) unshift = true;
          path2.splice(i2, 1);
          up--;
        }
      }
      if (unshift) path2.unshift("");
      if (last === "." || last === "..") path2.push("");
      return path2.join("/");
    }
    __name(resolve, "resolve");
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser) parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse2 = instruction[0];
        key = instruction[1];
        if (parse2 !== parse2) {
          url[key] = address;
        } else if ("string" === typeof parse2) {
          index = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse2.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }
      if (parser) url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    __name(Url, "Url");
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port) value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port2.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        var ins = rules[i2];
        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    __name(set, "set");
    function toString2(stringify) {
      if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password) result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port2.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash) result += url.hash;
      return result;
    }
    __name(toString2, "toString");
    Url.prototype = { set, toString: toString2 };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/tus-js-client/lib.es5/uuid.js
var require_uuid = __commonJS({
  "node_modules/tus-js-client/lib.es5/uuid.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = uuid;
    function uuid() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c3) {
        var r = Math.random() * 16 | 0;
        var v = c3 === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    __name(uuid, "uuid");
  }
});

// node_modules/tus-js-client/lib.es5/upload.js
var require_upload = __commonJS({
  "node_modules/tus-js-client/lib.es5/upload.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _jsBase = require_base64();
    var _urlParse = _interopRequireDefault(require_url_parse());
    var _error = _interopRequireDefault(require_error());
    var _logger = require_logger();
    var _uuid = _interopRequireDefault(require_uuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = /* @__PURE__ */ __name(function _regeneratorRuntime2() {
        return e;
      }, "_regeneratorRuntime");
      var t, e = {}, r = Object.prototype, n2 = r.hasOwnProperty, o2 = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c3 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      __name(define2, "define");
      try {
        define2({}, "");
      } catch (t2) {
        define2 = /* @__PURE__ */ __name(function define3(t3, e2, r2) {
          return t3[e2] = r2;
        }, "define");
      }
      function wrap(t2, e2, r2, n3) {
        var i3 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a3 = Object.create(i3.prototype), c4 = new Context(n3 || []);
        return o2(a3, "_invoke", {
          value: makeInvokeMethod(t2, r2, c4)
        }), a3;
      }
      __name(wrap, "wrap");
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      __name(tryCatch, "tryCatch");
      e.wrap = wrap;
      var h2 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      __name(Generator, "Generator");
      function GeneratorFunction() {
      }
      __name(GeneratorFunction, "GeneratorFunction");
      function GeneratorFunctionPrototype() {
      }
      __name(GeneratorFunctionPrototype, "GeneratorFunctionPrototype");
      var p = {};
      define2(p, a2, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n2.call(v, a2) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      __name(defineIteratorMethods, "defineIteratorMethods");
      function AsyncIterator(t2, e2) {
        function invoke(r3, o3, i3, a3) {
          var c4 = tryCatch(t2[r3], t2, o3);
          if ("throw" !== c4.type) {
            var u3 = c4.arg, h3 = u3.value;
            return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
              invoke("next", t3, i3, a3);
            }, function(t3) {
              invoke("throw", t3, i3, a3);
            }) : e2.resolve(h3).then(function(t3) {
              u3.value = t3, i3(u3);
            }, function(t3) {
              return invoke("throw", t3, i3, a3);
            });
          }
          a3(c4.arg);
        }
        __name(invoke, "invoke");
        var r2;
        o2(this, "_invoke", {
          value: /* @__PURE__ */ __name(function value(t3, n3) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n3, e3, r3);
              });
            }
            __name(callInvokeWithMethodAndArg, "callInvokeWithMethodAndArg");
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }, "value")
        });
      }
      __name(AsyncIterator, "AsyncIterator");
      function makeInvokeMethod(e2, r2, n3) {
        var o3 = h2;
        return function(i3, a3) {
          if (o3 === f) throw Error("Generator is already running");
          if (o3 === s) {
            if ("throw" === i3) throw a3;
            return {
              value: t,
              done: true
            };
          }
          for (n3.method = i3, n3.arg = a3; ; ) {
            var c4 = n3.delegate;
            if (c4) {
              var u3 = maybeInvokeDelegate(c4, n3);
              if (u3) {
                if (u3 === y) continue;
                return u3;
              }
            }
            if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2) throw o3 = s, n3.arg;
              n3.dispatchException(n3.arg);
            } else "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f;
            var p2 = tryCatch(e2, r2, n3);
            if ("normal" === p2.type) {
              if (o3 = n3.done ? s : l, p2.arg === y) continue;
              return {
                value: p2.arg,
                done: n3.done
              };
            }
            "throw" === p2.type && (o3 = s, n3.method = "throw", n3.arg = p2.arg);
          }
        };
      }
      __name(makeInvokeMethod, "makeInvokeMethod");
      function maybeInvokeDelegate(e2, r2) {
        var n3 = r2.method, o3 = e2.iterator[n3];
        if (o3 === t) return r2.delegate = null, "throw" === n3 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
        var i3 = tryCatch(o3, e2.iterator, r2.arg);
        if ("throw" === i3.type) return r2.method = "throw", r2.arg = i3.arg, r2.delegate = null, y;
        var a3 = i3.arg;
        return a3 ? a3.done ? (r2[e2.resultName] = a3.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a3 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      __name(maybeInvokeDelegate, "maybeInvokeDelegate");
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      __name(pushTryEntry, "pushTryEntry");
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      __name(resetTryEntry, "resetTryEntry");
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      __name(Context, "Context");
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a2];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o3 = -1, i3 = /* @__PURE__ */ __name(function next() {
              for (; ++o3 < e2.length; ) if (n2.call(e2, o3)) return next.value = e2[o3], next.done = false, next;
              return next.value = t, next.done = true, next;
            }, "next");
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      __name(values, "values");
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u2, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c3, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n3, o3, i3) {
        void 0 === i3 && (i3 = Promise);
        var a3 = new AsyncIterator(wrap(t2, r2, n3, o3), i3);
        return e.isGeneratorFunction(r2) ? a3 : a3.next().then(function(t3) {
          return t3.done ? t3.value : a3.next();
        });
      }, defineIteratorMethods(g), define2(g, u2, "Generator"), define2(g, a2, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n3 in e2) r2.push(n3);
        return r2.reverse(), /* @__PURE__ */ __name(function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        }, "next");
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: /* @__PURE__ */ __name(function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        }, "reset"),
        stop: /* @__PURE__ */ __name(function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        }, "stop"),
        dispatchException: /* @__PURE__ */ __name(function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n3, o4) {
            return a3.type = "throw", a3.arg = e2, r2.next = n3, o4 && (r2.method = "next", r2.arg = t), !!o4;
          }
          __name(handle, "handle");
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a3 = i3.completion;
            if ("root" === i3.tryLoc) return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c4 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
              if (c4 && u3) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              } else if (c4) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
              } else {
                if (!u3) throw Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              }
            }
          }
        }, "dispatchException"),
        abrupt: /* @__PURE__ */ __name(function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o3 = this.tryEntries[r2];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === t2 || "continue" === t2) && i3.tryLoc <= e2 && e2 <= i3.finallyLoc && (i3 = null);
          var a3 = i3 ? i3.completion : {};
          return a3.type = t2, a3.arg = e2, i3 ? (this.method = "next", this.next = i3.finallyLoc, y) : this.complete(a3);
        }, "abrupt"),
        complete: /* @__PURE__ */ __name(function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        }, "complete"),
        finish: /* @__PURE__ */ __name(function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        }, "finish"),
        "catch": /* @__PURE__ */ __name(function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n3 = r2.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r2);
              }
              return o3;
            }
          }
          throw Error("illegal catch attempt");
        }, "_catch"),
        delegateYield: /* @__PURE__ */ __name(function delegateYield(e2, r2, n3) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t), y;
        }, "delegateYield")
      }, e;
    }
    __name(_regeneratorRuntime, "_regeneratorRuntime");
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    __name(asyncGeneratorStep, "asyncGeneratorStep");
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          __name(_next, "_next");
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          __name(_throw, "_throw");
          _next(void 0);
        });
      };
    }
    __name(_asyncToGenerator, "_asyncToGenerator");
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n2, i2, u2, a2 = [], f = true, o2 = false;
        try {
          if (i2 = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i2.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
        } catch (r2) {
          o2 = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
      if (!it) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it) o2 = it;
          var i2 = 0;
          var F = /* @__PURE__ */ __name(function F2() {
          }, "F");
          return {
            s: F,
            n: /* @__PURE__ */ __name(function n2() {
              if (i2 >= o2.length) return {
                done: true
              };
              return {
                done: false,
                value: o2[i2++]
              };
            }, "n"),
            e: /* @__PURE__ */ __name(function e(_e) {
              throw _e;
            }, "e"),
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: /* @__PURE__ */ __name(function s() {
          it = it.call(o2);
        }, "s"),
        n: /* @__PURE__ */ __name(function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, "n"),
        e: /* @__PURE__ */ __name(function e(_e2) {
          didErr = true;
          err = _e2;
        }, "e"),
        f: /* @__PURE__ */ __name(function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        }, "f")
      };
    }
    __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e);
        r && (o2 = o2.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o2);
      }
      return t;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var PROTOCOL_TUS_V1 = "tus-v1";
    var PROTOCOL_IETF_DRAFT_03 = "ietf-draft-03";
    var PROTOCOL_IETF_DRAFT_05 = "ietf-draft-05";
    var defaultOptions2 = {
      endpoint: null,
      uploadUrl: null,
      metadata: {},
      metadataForPartialUploads: {},
      fingerprint: null,
      uploadSize: null,
      onProgress: null,
      onChunkComplete: null,
      onSuccess: null,
      onError: null,
      onUploadUrlAvailable: null,
      overridePatchMethod: false,
      headers: {},
      addRequestId: false,
      onBeforeRequest: null,
      onAfterResponse: null,
      onShouldRetry: defaultOnShouldRetry,
      chunkSize: Number.POSITIVE_INFINITY,
      retryDelays: [0, 1e3, 3e3, 5e3],
      parallelUploads: 1,
      parallelUploadBoundaries: null,
      storeFingerprintForResuming: true,
      removeFingerprintOnSuccess: false,
      uploadLengthDeferred: false,
      uploadDataDuringCreation: false,
      urlStorage: null,
      fileReader: null,
      httpStack: null,
      protocol: PROTOCOL_TUS_V1
    };
    var BaseUpload = /* @__PURE__ */ function() {
      function BaseUpload2(file, options) {
        _classCallCheck(this, BaseUpload2);
        if ("resume" in options) {
          console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.");
        }
        this.options = options;
        this.options.chunkSize = Number(this.options.chunkSize);
        this._urlStorage = this.options.urlStorage;
        this.file = file;
        this.url = null;
        this._req = null;
        this._fingerprint = null;
        this._urlStorageKey = null;
        this._offset = null;
        this._aborted = false;
        this._size = null;
        this._source = null;
        this._retryAttempt = 0;
        this._retryTimeout = null;
        this._offsetBeforeRetry = 0;
        this._parallelUploads = null;
        this._parallelUploadUrls = null;
      }
      __name(BaseUpload2, "BaseUpload");
      return _createClass(BaseUpload2, [{
        key: "findPreviousUploads",
        value: /* @__PURE__ */ __name(function findPreviousUploads() {
          var _this = this;
          return this.options.fingerprint(this.file, this.options).then(function(fingerprint) {
            return _this._urlStorage.findUploadsByFingerprint(fingerprint);
          });
        }, "findPreviousUploads")
      }, {
        key: "resumeFromPreviousUpload",
        value: /* @__PURE__ */ __name(function resumeFromPreviousUpload(previousUpload) {
          this.url = previousUpload.uploadUrl || null;
          this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
          this._urlStorageKey = previousUpload.urlStorageKey;
        }, "resumeFromPreviousUpload")
      }, {
        key: "start",
        value: /* @__PURE__ */ __name(function start() {
          var _this2 = this;
          var file = this.file;
          if (!file) {
            this._emitError(new Error("tus: no file or stream to upload provided"));
            return;
          }
          if (![PROTOCOL_TUS_V1, PROTOCOL_IETF_DRAFT_03, PROTOCOL_IETF_DRAFT_05].includes(this.options.protocol)) {
            this._emitError(new Error("tus: unsupported protocol ".concat(this.options.protocol)));
            return;
          }
          if (!this.options.endpoint && !this.options.uploadUrl && !this.url) {
            this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));
            return;
          }
          var retryDelays = this.options.retryDelays;
          if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
            this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));
            return;
          }
          if (this.options.parallelUploads > 1) {
            for (var _i = 0, _arr = ["uploadUrl", "uploadSize", "uploadLengthDeferred"]; _i < _arr.length; _i++) {
              var optionName = _arr[_i];
              if (this.options[optionName]) {
                this._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
                return;
              }
            }
          }
          if (this.options.parallelUploadBoundaries) {
            if (this.options.parallelUploads <= 1) {
              this._emitError(new Error("tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled"));
              return;
            }
            if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) {
              this._emitError(new Error("tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`"));
              return;
            }
          }
          this.options.fingerprint(file, this.options).then(function(fingerprint) {
            if (fingerprint == null) {
              (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
            } else {
              (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
            }
            _this2._fingerprint = fingerprint;
            if (_this2._source) {
              return _this2._source;
            }
            return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
          }).then(function(source) {
            _this2._source = source;
            if (_this2.options.uploadLengthDeferred) {
              _this2._size = null;
            } else if (_this2.options.uploadSize != null) {
              _this2._size = Number(_this2.options.uploadSize);
              if (Number.isNaN(_this2._size)) {
                _this2._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));
                return;
              }
            } else {
              _this2._size = _this2._source.size;
              if (_this2._size == null) {
                _this2._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option"));
                return;
              }
            }
            if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
              _this2._startParallelUpload();
            } else {
              _this2._startSingleUpload();
            }
          })["catch"](function(err) {
            _this2._emitError(err);
          });
        }, "start")
        /**
         * Initiate the uploading procedure for a parallelized upload, where one file is split into
         * multiple request which are run in parallel.
         *
         * @api private
         */
      }, {
        key: "_startParallelUpload",
        value: /* @__PURE__ */ __name(function _startParallelUpload() {
          var _this$options$paralle, _this3 = this;
          var totalSize = this._size;
          var totalProgress = 0;
          this._parallelUploads = [];
          var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads;
          var parts = (_this$options$paralle = this.options.parallelUploadBoundaries) !== null && _this$options$paralle !== void 0 ? _this$options$paralle : splitSizeIntoParts(this._source.size, partCount);
          if (this._parallelUploadUrls) {
            parts.forEach(function(part, index) {
              part.uploadUrl = _this3._parallelUploadUrls[index] || null;
            });
          }
          this._parallelUploadUrls = new Array(parts.length);
          var uploads = parts.map(function(part, index) {
            var lastPartProgress = 0;
            return _this3._source.slice(part.start, part.end).then(function(_ref) {
              var value = _ref.value;
              return new Promise(function(resolve, reject) {
                var options = _objectSpread(_objectSpread({}, _this3.options), {}, {
                  // If available, the partial upload should be resumed from a previous URL.
                  uploadUrl: part.uploadUrl || null,
                  // We take manually care of resuming for partial uploads, so they should
                  // not be stored in the URL storage.
                  storeFingerprintForResuming: false,
                  removeFingerprintOnSuccess: false,
                  // Reset the parallelUploads option to not cause recursion.
                  parallelUploads: 1,
                  // Reset this option as we are not doing a parallel upload.
                  parallelUploadBoundaries: null,
                  metadata: _this3.options.metadataForPartialUploads,
                  // Add the header to indicate the this is a partial upload.
                  headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {
                    "Upload-Concat": "partial"
                  }),
                  // Reject or resolve the promise if the upload errors or completes.
                  onSuccess: resolve,
                  onError: reject,
                  // Based in the progress for this partial upload, calculate the progress
                  // for the entire final upload.
                  onProgress: /* @__PURE__ */ __name(function onProgress(newPartProgress) {
                    totalProgress = totalProgress - lastPartProgress + newPartProgress;
                    lastPartProgress = newPartProgress;
                    _this3._emitProgress(totalProgress, totalSize);
                  }, "onProgress"),
                  // Wait until every partial upload has an upload URL, so we can add
                  // them to the URL storage.
                  onUploadUrlAvailable: /* @__PURE__ */ __name(function onUploadUrlAvailable() {
                    _this3._parallelUploadUrls[index] = upload.url;
                    if (_this3._parallelUploadUrls.filter(function(u2) {
                      return Boolean(u2);
                    }).length === parts.length) {
                      _this3._saveUploadInUrlStorage();
                    }
                  }, "onUploadUrlAvailable")
                });
                var upload = new BaseUpload2(value, options);
                upload.start();
                _this3._parallelUploads.push(upload);
              });
            });
          });
          var req;
          Promise.all(uploads).then(function() {
            req = _this3._openRequest("POST", _this3.options.endpoint);
            req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" ")));
            var metadata = encodeMetadata(_this3.options.metadata);
            if (metadata !== "") {
              req.setHeader("Upload-Metadata", metadata);
            }
            return _this3._sendRequest(req, null);
          }).then(function(res) {
            if (!inStatusCategory(res.getStatus(), 200)) {
              _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");
              return;
            }
            var location = res.getHeader("Location");
            if (location == null) {
              _this3._emitHttpError(req, res, "tus: invalid or missing Location header");
              return;
            }
            _this3.url = resolveUrl(_this3.options.endpoint, location);
            (0, _logger.log)("Created upload at ".concat(_this3.url));
            _this3._emitSuccess(res);
          })["catch"](function(err) {
            _this3._emitError(err);
          });
        }, "_startParallelUpload")
        /**
         * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
         * uploaded in a sequential matter.
         *
         * @api private
         */
      }, {
        key: "_startSingleUpload",
        value: /* @__PURE__ */ __name(function _startSingleUpload() {
          this._aborted = false;
          if (this.url != null) {
            (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));
            this._resumeUpload();
            return;
          }
          if (this.options.uploadUrl != null) {
            (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.uploadUrl));
            this.url = this.options.uploadUrl;
            this._resumeUpload();
            return;
          }
          (0, _logger.log)("Creating a new upload");
          this._createUpload();
        }, "_startSingleUpload")
        /**
         * Abort any running request and stop the current upload. After abort is called, no event
         * handler will be invoked anymore. You can use the `start` method to resume the upload
         * again.
         * If `shouldTerminate` is true, the `terminate` function will be called to remove the
         * current upload from the server.
         *
         * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
         * @return {Promise} The Promise will be resolved/rejected when the requests finish.
         */
      }, {
        key: "abort",
        value: /* @__PURE__ */ __name(function abort(shouldTerminate) {
          var _this4 = this;
          if (this._parallelUploads != null) {
            var _iterator = _createForOfIteratorHelper(this._parallelUploads), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var upload = _step.value;
                upload.abort(shouldTerminate);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          if (this._req !== null) {
            this._req.abort();
          }
          this._aborted = true;
          if (this._retryTimeout != null) {
            clearTimeout(this._retryTimeout);
            this._retryTimeout = null;
          }
          if (!shouldTerminate || this.url == null) {
            return Promise.resolve();
          }
          return BaseUpload2.terminate(this.url, this.options).then(function() {
            return _this4._removeFromUrlStorage();
          });
        }, "abort")
      }, {
        key: "_emitHttpError",
        value: /* @__PURE__ */ __name(function _emitHttpError(req, res, message, causingErr) {
          this._emitError(new _error.default(message, causingErr, req, res));
        }, "_emitHttpError")
      }, {
        key: "_emitError",
        value: /* @__PURE__ */ __name(function _emitError(err) {
          var _this5 = this;
          if (this._aborted) return;
          if (this.options.retryDelays != null) {
            var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;
            if (shouldResetDelays) {
              this._retryAttempt = 0;
            }
            if (shouldRetry(err, this._retryAttempt, this.options)) {
              var delay3 = this.options.retryDelays[this._retryAttempt++];
              this._offsetBeforeRetry = this._offset;
              this._retryTimeout = setTimeout(function() {
                _this5.start();
              }, delay3);
              return;
            }
          }
          if (typeof this.options.onError === "function") {
            this.options.onError(err);
          } else {
            throw err;
          }
        }, "_emitError")
        /**
         * Publishes notification if the upload has been successfully completed.
         *
         * @param {object} lastResponse Last HTTP response.
         * @api private
         */
      }, {
        key: "_emitSuccess",
        value: /* @__PURE__ */ __name(function _emitSuccess(lastResponse) {
          if (this.options.removeFingerprintOnSuccess) {
            this._removeFromUrlStorage();
          }
          if (typeof this.options.onSuccess === "function") {
            this.options.onSuccess({
              lastResponse
            });
          }
        }, "_emitSuccess")
        /**
         * Publishes notification when data has been sent to the server. This
         * data may not have been accepted by the server yet.
         *
         * @param {number} bytesSent  Number of bytes sent to the server.
         * @param {number} bytesTotal Total number of bytes to be sent to the server.
         * @api private
         */
      }, {
        key: "_emitProgress",
        value: /* @__PURE__ */ __name(function _emitProgress(bytesSent, bytesTotal) {
          if (typeof this.options.onProgress === "function") {
            this.options.onProgress(bytesSent, bytesTotal);
          }
        }, "_emitProgress")
        /**
         * Publishes notification when a chunk of data has been sent to the server
         * and accepted by the server.
         * @param {number} chunkSize  Size of the chunk that was accepted by the server.
         * @param {number} bytesAccepted Total number of bytes that have been
         *                                accepted by the server.
         * @param {number} bytesTotal Total number of bytes to be sent to the server.
         * @api private
         */
      }, {
        key: "_emitChunkComplete",
        value: /* @__PURE__ */ __name(function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
          if (typeof this.options.onChunkComplete === "function") {
            this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
          }
        }, "_emitChunkComplete")
        /**
         * Create a new upload using the creation extension by sending a POST
         * request to the endpoint. After successful creation the file will be
         * uploaded
         *
         * @api private
         */
      }, {
        key: "_createUpload",
        value: /* @__PURE__ */ __name(function _createUpload() {
          var _this6 = this;
          if (!this.options.endpoint) {
            this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));
            return;
          }
          var req = this._openRequest("POST", this.options.endpoint);
          if (this.options.uploadLengthDeferred) {
            req.setHeader("Upload-Defer-Length", "1");
          } else {
            req.setHeader("Upload-Length", "".concat(this._size));
          }
          var metadata = encodeMetadata(this.options.metadata);
          if (metadata !== "") {
            req.setHeader("Upload-Metadata", metadata);
          }
          var promise;
          if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
            this._offset = 0;
            promise = this._addChunkToRequest(req);
          } else {
            if (this.options.protocol === PROTOCOL_IETF_DRAFT_03 || this.options.protocol === PROTOCOL_IETF_DRAFT_05) {
              req.setHeader("Upload-Complete", "?0");
            }
            promise = this._sendRequest(req, null);
          }
          promise.then(function(res) {
            if (!inStatusCategory(res.getStatus(), 200)) {
              _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");
              return;
            }
            var location = res.getHeader("Location");
            if (location == null) {
              _this6._emitHttpError(req, res, "tus: invalid or missing Location header");
              return;
            }
            _this6.url = resolveUrl(_this6.options.endpoint, location);
            (0, _logger.log)("Created upload at ".concat(_this6.url));
            if (typeof _this6.options.onUploadUrlAvailable === "function") {
              _this6.options.onUploadUrlAvailable();
            }
            if (_this6._size === 0) {
              _this6._emitSuccess(res);
              _this6._source.close();
              return;
            }
            _this6._saveUploadInUrlStorage().then(function() {
              if (_this6.options.uploadDataDuringCreation) {
                _this6._handleUploadResponse(req, res);
              } else {
                _this6._offset = 0;
                _this6._performUpload();
              }
            });
          })["catch"](function(err) {
            _this6._emitHttpError(req, null, "tus: failed to create upload", err);
          });
        }, "_createUpload")
        /*
         * Try to resume an existing upload. First a HEAD request will be sent
         * to retrieve the offset. If the request fails a new upload will be
         * created. In the case of a successful response the file will be uploaded.
         *
         * @api private
         */
      }, {
        key: "_resumeUpload",
        value: /* @__PURE__ */ __name(function _resumeUpload() {
          var _this7 = this;
          var req = this._openRequest("HEAD", this.url);
          var promise = this._sendRequest(req, null);
          promise.then(function(res) {
            var status = res.getStatus();
            if (!inStatusCategory(status, 200)) {
              if (status === 423) {
                _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");
                return;
              }
              if (inStatusCategory(status, 400)) {
                _this7._removeFromUrlStorage();
              }
              if (!_this7.options.endpoint) {
                _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");
                return;
              }
              _this7.url = null;
              _this7._createUpload();
              return;
            }
            var offset = Number.parseInt(res.getHeader("Upload-Offset"), 10);
            if (Number.isNaN(offset)) {
              _this7._emitHttpError(req, res, "tus: invalid or missing offset value");
              return;
            }
            var length = Number.parseInt(res.getHeader("Upload-Length"), 10);
            if (Number.isNaN(length) && !_this7.options.uploadLengthDeferred && _this7.options.protocol === PROTOCOL_TUS_V1) {
              _this7._emitHttpError(req, res, "tus: invalid or missing length value");
              return;
            }
            if (typeof _this7.options.onUploadUrlAvailable === "function") {
              _this7.options.onUploadUrlAvailable();
            }
            _this7._saveUploadInUrlStorage().then(function() {
              if (offset === length) {
                _this7._emitProgress(length, length);
                _this7._emitSuccess(res);
                return;
              }
              _this7._offset = offset;
              _this7._performUpload();
            });
          })["catch"](function(err) {
            _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
          });
        }, "_resumeUpload")
        /**
         * Start uploading the file using PATCH requests. The file will be divided
         * into chunks as specified in the chunkSize option. During the upload
         * the onProgress event handler may be invoked multiple times.
         *
         * @api private
         */
      }, {
        key: "_performUpload",
        value: /* @__PURE__ */ __name(function _performUpload() {
          var _this8 = this;
          if (this._aborted) {
            return;
          }
          var req;
          if (this.options.overridePatchMethod) {
            req = this._openRequest("POST", this.url);
            req.setHeader("X-HTTP-Method-Override", "PATCH");
          } else {
            req = this._openRequest("PATCH", this.url);
          }
          req.setHeader("Upload-Offset", "".concat(this._offset));
          var promise = this._addChunkToRequest(req);
          promise.then(function(res) {
            if (!inStatusCategory(res.getStatus(), 200)) {
              _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");
              return;
            }
            _this8._handleUploadResponse(req, res);
          })["catch"](function(err) {
            if (_this8._aborted) {
              return;
            }
            _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
          });
        }, "_performUpload")
        /**
         * _addChunktoRequest reads a chunk from the source and sends it using the
         * supplied request object. It will not handle the response.
         *
         * @api private
         */
      }, {
        key: "_addChunkToRequest",
        value: /* @__PURE__ */ __name(function _addChunkToRequest(req) {
          var _this9 = this;
          var start = this._offset;
          var end = this._offset + this.options.chunkSize;
          req.setProgressHandler(function(bytesSent) {
            _this9._emitProgress(start + bytesSent, _this9._size);
          });
          if (this.options.protocol === PROTOCOL_TUS_V1) {
            req.setHeader("Content-Type", "application/offset+octet-stream");
          } else if (this.options.protocol === PROTOCOL_IETF_DRAFT_05) {
            req.setHeader("Content-Type", "application/partial-upload");
          }
          if ((end === Number.POSITIVE_INFINITY || end > this._size) && !this.options.uploadLengthDeferred) {
            end = this._size;
          }
          return this._source.slice(start, end).then(function(_ref2) {
            var value = _ref2.value, done = _ref2.done;
            var valueSize = value !== null && value !== void 0 && value.size ? value.size : 0;
            if (_this9.options.uploadLengthDeferred && done) {
              _this9._size = _this9._offset + valueSize;
              req.setHeader("Upload-Length", "".concat(_this9._size));
            }
            var newSize = _this9._offset + valueSize;
            if (!_this9.options.uploadLengthDeferred && done && newSize !== _this9._size) {
              return Promise.reject(new Error("upload was configured with a size of ".concat(_this9._size, " bytes, but the source is done after ").concat(newSize, " bytes")));
            }
            if (value === null) {
              return _this9._sendRequest(req);
            }
            if (_this9.options.protocol === PROTOCOL_IETF_DRAFT_03 || _this9.options.protocol === PROTOCOL_IETF_DRAFT_05) {
              req.setHeader("Upload-Complete", done ? "?1" : "?0");
            }
            _this9._emitProgress(_this9._offset, _this9._size);
            return _this9._sendRequest(req, value);
          });
        }, "_addChunkToRequest")
        /**
         * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
         * and already have received a response.
         *
         * @api private
         */
      }, {
        key: "_handleUploadResponse",
        value: /* @__PURE__ */ __name(function _handleUploadResponse(req, res) {
          var offset = Number.parseInt(res.getHeader("Upload-Offset"), 10);
          if (Number.isNaN(offset)) {
            this._emitHttpError(req, res, "tus: invalid or missing offset value");
            return;
          }
          this._emitProgress(offset, this._size);
          this._emitChunkComplete(offset - this._offset, offset, this._size);
          this._offset = offset;
          if (offset === this._size) {
            this._emitSuccess(res);
            this._source.close();
            return;
          }
          this._performUpload();
        }, "_handleUploadResponse")
        /**
         * Create a new HTTP request object with the given method and URL.
         *
         * @api private
         */
      }, {
        key: "_openRequest",
        value: /* @__PURE__ */ __name(function _openRequest(method, url) {
          var req = openRequest(method, url, this.options);
          this._req = req;
          return req;
        }, "_openRequest")
        /**
         * Remove the entry in the URL storage, if it has been saved before.
         *
         * @api private
         */
      }, {
        key: "_removeFromUrlStorage",
        value: /* @__PURE__ */ __name(function _removeFromUrlStorage() {
          var _this10 = this;
          if (!this._urlStorageKey) return;
          this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function(err) {
            _this10._emitError(err);
          });
          this._urlStorageKey = null;
        }, "_removeFromUrlStorage")
        /**
         * Add the upload URL to the URL storage, if possible.
         *
         * @api private
         */
      }, {
        key: "_saveUploadInUrlStorage",
        value: /* @__PURE__ */ __name(function _saveUploadInUrlStorage() {
          var _this11 = this;
          if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) {
            return Promise.resolve();
          }
          var storedUpload = {
            size: this._size,
            metadata: this.options.metadata,
            creationTime: (/* @__PURE__ */ new Date()).toString()
          };
          if (this._parallelUploads) {
            storedUpload.parallelUploadUrls = this._parallelUploadUrls;
          } else {
            storedUpload.uploadUrl = this.url;
          }
          return this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function(urlStorageKey) {
            _this11._urlStorageKey = urlStorageKey;
          });
        }, "_saveUploadInUrlStorage")
        /**
         * Send a request with the provided body.
         *
         * @api private
         */
      }, {
        key: "_sendRequest",
        value: /* @__PURE__ */ __name(function _sendRequest(req) {
          var body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          return sendRequest(req, body, this.options);
        }, "_sendRequest")
      }], [{
        key: "terminate",
        value: /* @__PURE__ */ __name(function terminate(url) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var req = openRequest("DELETE", url, options);
          return sendRequest(req, null, options).then(function(res) {
            if (res.getStatus() === 204) {
              return;
            }
            throw new _error.default("tus: unexpected response while terminating upload", null, req, res);
          })["catch"](function(err) {
            if (!(err instanceof _error.default)) {
              err = new _error.default("tus: failed to terminate upload", err, req, null);
            }
            if (!shouldRetry(err, 0, options)) {
              throw err;
            }
            var delay3 = options.retryDelays[0];
            var remainingDelays = options.retryDelays.slice(1);
            var newOptions = _objectSpread(_objectSpread({}, options), {}, {
              retryDelays: remainingDelays
            });
            return new Promise(function(resolve) {
              return setTimeout(resolve, delay3);
            }).then(function() {
              return BaseUpload2.terminate(url, newOptions);
            });
          });
        }, "terminate")
      }]);
    }();
    function encodeMetadata(metadata) {
      return Object.entries(metadata).map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
        return "".concat(key, " ").concat(_jsBase.Base64.encode(String(value)));
      }).join(",");
    }
    __name(encodeMetadata, "encodeMetadata");
    function inStatusCategory(status, category) {
      return status >= category && status < category + 100;
    }
    __name(inStatusCategory, "inStatusCategory");
    function openRequest(method, url, options) {
      var req = options.httpStack.createRequest(method, url);
      if (options.protocol === PROTOCOL_IETF_DRAFT_03) {
        req.setHeader("Upload-Draft-Interop-Version", "5");
      } else if (options.protocol === PROTOCOL_IETF_DRAFT_05) {
        req.setHeader("Upload-Draft-Interop-Version", "6");
      } else {
        req.setHeader("Tus-Resumable", "1.0.0");
      }
      var headers = options.headers || {};
      for (var _i2 = 0, _Object$entries = Object.entries(headers); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
        req.setHeader(name, value);
      }
      if (options.addRequestId) {
        var requestId = (0, _uuid.default)();
        req.setHeader("X-Request-ID", requestId);
      }
      return req;
    }
    __name(openRequest, "openRequest");
    function sendRequest(_x, _x2, _x3) {
      return _sendRequest2.apply(this, arguments);
    }
    __name(sendRequest, "sendRequest");
    function _sendRequest2() {
      _sendRequest2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(req, body, options) {
        var res;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof options.onBeforeRequest === "function")) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return options.onBeforeRequest(req);
            case 3:
              _context.next = 5;
              return req.send(body);
            case 5:
              res = _context.sent;
              if (!(typeof options.onAfterResponse === "function")) {
                _context.next = 9;
                break;
              }
              _context.next = 9;
              return options.onAfterResponse(req, res);
            case 9:
              return _context.abrupt("return", res);
            case 10:
            case "end":
              return _context.stop();
          }
        }, "_callee$"), _callee);
      }, "_callee")));
      return _sendRequest2.apply(this, arguments);
    }
    __name(_sendRequest2, "_sendRequest2");
    function isOnline() {
      var online = true;
      if (typeof navigator !== "undefined" && navigator.onLine === false) {
        online = false;
      }
      return online;
    }
    __name(isOnline, "isOnline");
    function shouldRetry(err, retryAttempt, options) {
      if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
        return false;
      }
      if (options && typeof options.onShouldRetry === "function") {
        return options.onShouldRetry(err, retryAttempt, options);
      }
      return defaultOnShouldRetry(err);
    }
    __name(shouldRetry, "shouldRetry");
    function defaultOnShouldRetry(err) {
      var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
      return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
    }
    __name(defaultOnShouldRetry, "defaultOnShouldRetry");
    function resolveUrl(origin, link) {
      return new _urlParse.default(link, origin).toString();
    }
    __name(resolveUrl, "resolveUrl");
    function splitSizeIntoParts(totalSize, partCount) {
      var partSize = Math.floor(totalSize / partCount);
      var parts = [];
      for (var i2 = 0; i2 < partCount; i2++) {
        parts.push({
          start: partSize * i2,
          end: partSize * (i2 + 1)
        });
      }
      parts[partCount - 1].end = totalSize;
      return parts;
    }
    __name(splitSizeIntoParts, "splitSizeIntoParts");
    BaseUpload.defaultOptions = defaultOptions2;
    var _default = exports2.default = BaseUpload;
  }
});

// node_modules/tus-js-client/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/tus-js-client/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var isStream3 = /* @__PURE__ */ __name((stream2) => stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function", "isStream");
    isStream3.writable = (stream2) => isStream3(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
    isStream3.readable = (stream2) => isStream3(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
    isStream3.duplex = (stream2) => isStream3.writable(stream2) && isStream3.readable(stream2);
    isStream3.transform = (stream2) => isStream3.duplex(stream2) && typeof stream2._transform === "function";
    module2.exports = isStream3;
  }
});

// node_modules/tus-js-client/lib.es5/node/sources/BufferSource.js
var require_BufferSource = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/sources/BufferSource.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var BufferSource = exports2.default = /* @__PURE__ */ function() {
      function BufferSource2(buffer) {
        _classCallCheck(this, BufferSource2);
        this._buffer = buffer;
        this.size = buffer.length;
      }
      __name(BufferSource2, "BufferSource");
      return _createClass(BufferSource2, [{
        key: "slice",
        value: /* @__PURE__ */ __name(function slice(start, end) {
          var value = this._buffer.slice(start, end);
          value.size = value.length;
          var done = end >= this.size;
          return Promise.resolve({
            value,
            done
          });
        }, "slice")
      }, {
        key: "close",
        value: /* @__PURE__ */ __name(function close() {
        }, "close")
      }]);
    }();
  }
});

// node_modules/tus-js-client/lib.es5/node/sources/FileSource.js
var require_FileSource = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/sources/FileSource.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getFileSource;
    var _fs = __require("fs");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = /* @__PURE__ */ __name(function _regeneratorRuntime2() {
        return e;
      }, "_regeneratorRuntime");
      var t, e = {}, r = Object.prototype, n2 = r.hasOwnProperty, o2 = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c3 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      __name(define2, "define");
      try {
        define2({}, "");
      } catch (t2) {
        define2 = /* @__PURE__ */ __name(function define3(t3, e2, r2) {
          return t3[e2] = r2;
        }, "define");
      }
      function wrap(t2, e2, r2, n3) {
        var i3 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a3 = Object.create(i3.prototype), c4 = new Context(n3 || []);
        return o2(a3, "_invoke", {
          value: makeInvokeMethod(t2, r2, c4)
        }), a3;
      }
      __name(wrap, "wrap");
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      __name(tryCatch, "tryCatch");
      e.wrap = wrap;
      var h2 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      __name(Generator, "Generator");
      function GeneratorFunction() {
      }
      __name(GeneratorFunction, "GeneratorFunction");
      function GeneratorFunctionPrototype() {
      }
      __name(GeneratorFunctionPrototype, "GeneratorFunctionPrototype");
      var p = {};
      define2(p, a2, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n2.call(v, a2) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      __name(defineIteratorMethods, "defineIteratorMethods");
      function AsyncIterator(t2, e2) {
        function invoke(r3, o3, i3, a3) {
          var c4 = tryCatch(t2[r3], t2, o3);
          if ("throw" !== c4.type) {
            var u3 = c4.arg, h3 = u3.value;
            return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
              invoke("next", t3, i3, a3);
            }, function(t3) {
              invoke("throw", t3, i3, a3);
            }) : e2.resolve(h3).then(function(t3) {
              u3.value = t3, i3(u3);
            }, function(t3) {
              return invoke("throw", t3, i3, a3);
            });
          }
          a3(c4.arg);
        }
        __name(invoke, "invoke");
        var r2;
        o2(this, "_invoke", {
          value: /* @__PURE__ */ __name(function value(t3, n3) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n3, e3, r3);
              });
            }
            __name(callInvokeWithMethodAndArg, "callInvokeWithMethodAndArg");
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }, "value")
        });
      }
      __name(AsyncIterator, "AsyncIterator");
      function makeInvokeMethod(e2, r2, n3) {
        var o3 = h2;
        return function(i3, a3) {
          if (o3 === f) throw Error("Generator is already running");
          if (o3 === s) {
            if ("throw" === i3) throw a3;
            return {
              value: t,
              done: true
            };
          }
          for (n3.method = i3, n3.arg = a3; ; ) {
            var c4 = n3.delegate;
            if (c4) {
              var u3 = maybeInvokeDelegate(c4, n3);
              if (u3) {
                if (u3 === y) continue;
                return u3;
              }
            }
            if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2) throw o3 = s, n3.arg;
              n3.dispatchException(n3.arg);
            } else "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f;
            var p2 = tryCatch(e2, r2, n3);
            if ("normal" === p2.type) {
              if (o3 = n3.done ? s : l, p2.arg === y) continue;
              return {
                value: p2.arg,
                done: n3.done
              };
            }
            "throw" === p2.type && (o3 = s, n3.method = "throw", n3.arg = p2.arg);
          }
        };
      }
      __name(makeInvokeMethod, "makeInvokeMethod");
      function maybeInvokeDelegate(e2, r2) {
        var n3 = r2.method, o3 = e2.iterator[n3];
        if (o3 === t) return r2.delegate = null, "throw" === n3 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
        var i3 = tryCatch(o3, e2.iterator, r2.arg);
        if ("throw" === i3.type) return r2.method = "throw", r2.arg = i3.arg, r2.delegate = null, y;
        var a3 = i3.arg;
        return a3 ? a3.done ? (r2[e2.resultName] = a3.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a3 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      __name(maybeInvokeDelegate, "maybeInvokeDelegate");
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      __name(pushTryEntry, "pushTryEntry");
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      __name(resetTryEntry, "resetTryEntry");
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      __name(Context, "Context");
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a2];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o3 = -1, i3 = /* @__PURE__ */ __name(function next() {
              for (; ++o3 < e2.length; ) if (n2.call(e2, o3)) return next.value = e2[o3], next.done = false, next;
              return next.value = t, next.done = true, next;
            }, "next");
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      __name(values, "values");
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u2, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c3, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n3, o3, i3) {
        void 0 === i3 && (i3 = Promise);
        var a3 = new AsyncIterator(wrap(t2, r2, n3, o3), i3);
        return e.isGeneratorFunction(r2) ? a3 : a3.next().then(function(t3) {
          return t3.done ? t3.value : a3.next();
        });
      }, defineIteratorMethods(g), define2(g, u2, "Generator"), define2(g, a2, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n3 in e2) r2.push(n3);
        return r2.reverse(), /* @__PURE__ */ __name(function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        }, "next");
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: /* @__PURE__ */ __name(function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        }, "reset"),
        stop: /* @__PURE__ */ __name(function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        }, "stop"),
        dispatchException: /* @__PURE__ */ __name(function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n3, o4) {
            return a3.type = "throw", a3.arg = e2, r2.next = n3, o4 && (r2.method = "next", r2.arg = t), !!o4;
          }
          __name(handle, "handle");
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a3 = i3.completion;
            if ("root" === i3.tryLoc) return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c4 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
              if (c4 && u3) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              } else if (c4) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
              } else {
                if (!u3) throw Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              }
            }
          }
        }, "dispatchException"),
        abrupt: /* @__PURE__ */ __name(function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o3 = this.tryEntries[r2];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === t2 || "continue" === t2) && i3.tryLoc <= e2 && e2 <= i3.finallyLoc && (i3 = null);
          var a3 = i3 ? i3.completion : {};
          return a3.type = t2, a3.arg = e2, i3 ? (this.method = "next", this.next = i3.finallyLoc, y) : this.complete(a3);
        }, "abrupt"),
        complete: /* @__PURE__ */ __name(function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        }, "complete"),
        finish: /* @__PURE__ */ __name(function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        }, "finish"),
        "catch": /* @__PURE__ */ __name(function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n3 = r2.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r2);
              }
              return o3;
            }
          }
          throw Error("illegal catch attempt");
        }, "_catch"),
        delegateYield: /* @__PURE__ */ __name(function delegateYield(e2, r2, n3) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t), y;
        }, "delegateYield")
      }, e;
    }
    __name(_regeneratorRuntime, "_regeneratorRuntime");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    __name(asyncGeneratorStep, "asyncGeneratorStep");
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          __name(_next, "_next");
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          __name(_throw, "_throw");
          _next(void 0);
        });
      };
    }
    __name(_asyncToGenerator, "_asyncToGenerator");
    function getFileSource(_x) {
      return _getFileSource.apply(this, arguments);
    }
    __name(getFileSource, "getFileSource");
    function _getFileSource() {
      _getFileSource = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(stream2) {
        var _stream$start;
        var path2, _yield$fsPromises$sta, size, start, end, actualSize;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              path2 = stream2.path.toString();
              _context.next = 3;
              return _fs.promises.stat(path2);
            case 3:
              _yield$fsPromises$sta = _context.sent;
              size = _yield$fsPromises$sta.size;
              start = (_stream$start = stream2.start) !== null && _stream$start !== void 0 ? _stream$start : 0;
              end = Number.isFinite(stream2.end) ? stream2.end + 1 : size;
              actualSize = end - start;
              return _context.abrupt("return", new FileSource(stream2, path2, actualSize));
            case 9:
            case "end":
              return _context.stop();
          }
        }, "_callee$"), _callee);
      }, "_callee")));
      return _getFileSource.apply(this, arguments);
    }
    __name(_getFileSource, "_getFileSource");
    var FileSource = /* @__PURE__ */ function() {
      function FileSource2(stream2, path2, size) {
        _classCallCheck(this, FileSource2);
        this._stream = stream2;
        this._path = path2;
        this.size = size;
      }
      __name(FileSource2, "FileSource");
      return _createClass(FileSource2, [{
        key: "slice",
        value: /* @__PURE__ */ __name(function slice(start, end) {
          var _this$_stream$start;
          var offset = (_this$_stream$start = this._stream.start) !== null && _this$_stream$start !== void 0 ? _this$_stream$start : 0;
          var stream2 = (0, _fs.createReadStream)(this._path, {
            start: offset + start,
            // The `end` option for createReadStream is treated inclusively
            // (see https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options).
            // However, the Buffer#slice(start, end) and also our Source#slice(start, end)
            // method treat the end range exclusively, so we have to subtract 1.
            // This prevents an off-by-one error when reporting upload progress.
            end: offset + end - 1,
            autoClose: true
          });
          stream2.size = Math.min(end - start, this.size);
          var done = stream2.size >= this.size;
          return Promise.resolve({
            value: stream2,
            done
          });
        }, "slice")
      }, {
        key: "close",
        value: /* @__PURE__ */ __name(function close() {
          this._stream.destroy();
        }, "close")
      }]);
    }();
  }
});

// node_modules/tus-js-client/lib.es5/node/sources/StreamSource.js
var require_StreamSource = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/sources/StreamSource.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = /* @__PURE__ */ __name(function _regeneratorRuntime2() {
        return e;
      }, "_regeneratorRuntime");
      var t, e = {}, r = Object.prototype, n2 = r.hasOwnProperty, o2 = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c3 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      __name(define2, "define");
      try {
        define2({}, "");
      } catch (t2) {
        define2 = /* @__PURE__ */ __name(function define3(t3, e2, r2) {
          return t3[e2] = r2;
        }, "define");
      }
      function wrap(t2, e2, r2, n3) {
        var i3 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a3 = Object.create(i3.prototype), c4 = new Context(n3 || []);
        return o2(a3, "_invoke", {
          value: makeInvokeMethod(t2, r2, c4)
        }), a3;
      }
      __name(wrap, "wrap");
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      __name(tryCatch, "tryCatch");
      e.wrap = wrap;
      var h2 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      __name(Generator, "Generator");
      function GeneratorFunction() {
      }
      __name(GeneratorFunction, "GeneratorFunction");
      function GeneratorFunctionPrototype() {
      }
      __name(GeneratorFunctionPrototype, "GeneratorFunctionPrototype");
      var p = {};
      define2(p, a2, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n2.call(v, a2) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      __name(defineIteratorMethods, "defineIteratorMethods");
      function AsyncIterator(t2, e2) {
        function invoke(r3, o3, i3, a3) {
          var c4 = tryCatch(t2[r3], t2, o3);
          if ("throw" !== c4.type) {
            var u3 = c4.arg, h3 = u3.value;
            return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
              invoke("next", t3, i3, a3);
            }, function(t3) {
              invoke("throw", t3, i3, a3);
            }) : e2.resolve(h3).then(function(t3) {
              u3.value = t3, i3(u3);
            }, function(t3) {
              return invoke("throw", t3, i3, a3);
            });
          }
          a3(c4.arg);
        }
        __name(invoke, "invoke");
        var r2;
        o2(this, "_invoke", {
          value: /* @__PURE__ */ __name(function value(t3, n3) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n3, e3, r3);
              });
            }
            __name(callInvokeWithMethodAndArg, "callInvokeWithMethodAndArg");
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }, "value")
        });
      }
      __name(AsyncIterator, "AsyncIterator");
      function makeInvokeMethod(e2, r2, n3) {
        var o3 = h2;
        return function(i3, a3) {
          if (o3 === f) throw Error("Generator is already running");
          if (o3 === s) {
            if ("throw" === i3) throw a3;
            return {
              value: t,
              done: true
            };
          }
          for (n3.method = i3, n3.arg = a3; ; ) {
            var c4 = n3.delegate;
            if (c4) {
              var u3 = maybeInvokeDelegate(c4, n3);
              if (u3) {
                if (u3 === y) continue;
                return u3;
              }
            }
            if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2) throw o3 = s, n3.arg;
              n3.dispatchException(n3.arg);
            } else "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f;
            var p2 = tryCatch(e2, r2, n3);
            if ("normal" === p2.type) {
              if (o3 = n3.done ? s : l, p2.arg === y) continue;
              return {
                value: p2.arg,
                done: n3.done
              };
            }
            "throw" === p2.type && (o3 = s, n3.method = "throw", n3.arg = p2.arg);
          }
        };
      }
      __name(makeInvokeMethod, "makeInvokeMethod");
      function maybeInvokeDelegate(e2, r2) {
        var n3 = r2.method, o3 = e2.iterator[n3];
        if (o3 === t) return r2.delegate = null, "throw" === n3 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
        var i3 = tryCatch(o3, e2.iterator, r2.arg);
        if ("throw" === i3.type) return r2.method = "throw", r2.arg = i3.arg, r2.delegate = null, y;
        var a3 = i3.arg;
        return a3 ? a3.done ? (r2[e2.resultName] = a3.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a3 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      __name(maybeInvokeDelegate, "maybeInvokeDelegate");
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      __name(pushTryEntry, "pushTryEntry");
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      __name(resetTryEntry, "resetTryEntry");
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      __name(Context, "Context");
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a2];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o3 = -1, i3 = /* @__PURE__ */ __name(function next() {
              for (; ++o3 < e2.length; ) if (n2.call(e2, o3)) return next.value = e2[o3], next.done = false, next;
              return next.value = t, next.done = true, next;
            }, "next");
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      __name(values, "values");
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u2, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c3, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n3, o3, i3) {
        void 0 === i3 && (i3 = Promise);
        var a3 = new AsyncIterator(wrap(t2, r2, n3, o3), i3);
        return e.isGeneratorFunction(r2) ? a3 : a3.next().then(function(t3) {
          return t3.done ? t3.value : a3.next();
        });
      }, defineIteratorMethods(g), define2(g, u2, "Generator"), define2(g, a2, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n3 in e2) r2.push(n3);
        return r2.reverse(), /* @__PURE__ */ __name(function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        }, "next");
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: /* @__PURE__ */ __name(function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        }, "reset"),
        stop: /* @__PURE__ */ __name(function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        }, "stop"),
        dispatchException: /* @__PURE__ */ __name(function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n3, o4) {
            return a3.type = "throw", a3.arg = e2, r2.next = n3, o4 && (r2.method = "next", r2.arg = t), !!o4;
          }
          __name(handle, "handle");
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a3 = i3.completion;
            if ("root" === i3.tryLoc) return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c4 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
              if (c4 && u3) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              } else if (c4) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
              } else {
                if (!u3) throw Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              }
            }
          }
        }, "dispatchException"),
        abrupt: /* @__PURE__ */ __name(function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o3 = this.tryEntries[r2];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === t2 || "continue" === t2) && i3.tryLoc <= e2 && e2 <= i3.finallyLoc && (i3 = null);
          var a3 = i3 ? i3.completion : {};
          return a3.type = t2, a3.arg = e2, i3 ? (this.method = "next", this.next = i3.finallyLoc, y) : this.complete(a3);
        }, "abrupt"),
        complete: /* @__PURE__ */ __name(function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        }, "complete"),
        finish: /* @__PURE__ */ __name(function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        }, "finish"),
        "catch": /* @__PURE__ */ __name(function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n3 = r2.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r2);
              }
              return o3;
            }
          }
          throw Error("illegal catch attempt");
        }, "_catch"),
        delegateYield: /* @__PURE__ */ __name(function delegateYield(e2, r2, n3) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t), y;
        }, "delegateYield")
      }, e;
    }
    __name(_regeneratorRuntime, "_regeneratorRuntime");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    __name(asyncGeneratorStep, "asyncGeneratorStep");
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          __name(_next, "_next");
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          __name(_throw, "_throw");
          _next(void 0);
        });
      };
    }
    __name(_asyncToGenerator, "_asyncToGenerator");
    function readChunk(_x, _x2) {
      return _readChunk.apply(this, arguments);
    }
    __name(readChunk, "readChunk");
    function _readChunk() {
      _readChunk = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee2(stream2, size) {
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function(resolve, reject) {
                var onError = /* @__PURE__ */ __name(function onError2(err) {
                  stream2.off("readable", onReadable);
                  reject(err);
                }, "onError");
                var onReadable = /* @__PURE__ */ __name(function onReadable2() {
                  var chunk2 = stream2.read(size);
                  if (chunk2 !== null) {
                    stream2.off("error", onError);
                    stream2.off("readable", onReadable2);
                    resolve(chunk2);
                  }
                }, "onReadable");
                stream2.once("error", onError);
                stream2.on("readable", onReadable);
              }));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, "_callee2$"), _callee2);
      }, "_callee2")));
      return _readChunk.apply(this, arguments);
    }
    __name(_readChunk, "_readChunk");
    var StreamSource = exports2.default = /* @__PURE__ */ function() {
      function StreamSource2(stream2) {
        var _this = this;
        _classCallCheck(this, StreamSource2);
        this._stream = stream2;
        this.size = null;
        this._buf = Buffer.alloc(0);
        this._bufPos = 0;
        this._ended = false;
        this._error = null;
        stream2.pause();
        stream2.on("end", function() {
          _this._ended = true;
        });
        stream2.on("error", function(err) {
          _this._error = err;
        });
      }
      __name(StreamSource2, "StreamSource");
      return _createClass(StreamSource2, [{
        key: "slice",
        value: function() {
          var _slice = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(start, end) {
            var returnBuffer, bufStart, bufEnd, requestedSize, newChunk;
            return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (!(start < this._bufPos)) {
                    _context.next = 2;
                    break;
                  }
                  throw new Error("cannot slice from position which we already seeked away");
                case 2:
                  if (!(start > this._bufPos + this._buf.length)) {
                    _context.next = 4;
                    break;
                  }
                  throw new Error("slice start is outside of buffer (currently not implemented)");
                case 4:
                  if (!this._error) {
                    _context.next = 6;
                    break;
                  }
                  throw this._error;
                case 6:
                  if (start < this._bufPos + this._buf.length) {
                    bufStart = start - this._bufPos;
                    bufEnd = Math.min(this._buf.length, end - this._bufPos);
                    returnBuffer = this._buf.slice(bufStart, bufEnd);
                  } else {
                    returnBuffer = Buffer.alloc(0);
                  }
                  if (!this._ended) {
                    _context.next = 10;
                    break;
                  }
                  returnBuffer.size = returnBuffer.length;
                  return _context.abrupt("return", {
                    value: returnBuffer,
                    done: true
                  });
                case 10:
                  requestedSize = end - start;
                  if (!(requestedSize > returnBuffer.length)) {
                    _context.next = 16;
                    break;
                  }
                  _context.next = 14;
                  return readChunk(this._stream, requestedSize - returnBuffer.length);
                case 14:
                  newChunk = _context.sent;
                  returnBuffer = Buffer.concat([returnBuffer, newChunk]);
                case 16:
                  this._buf = returnBuffer;
                  this._bufPos = start;
                  returnBuffer.size = returnBuffer.length;
                  return _context.abrupt("return", {
                    value: returnBuffer,
                    done: this._ended
                  });
                case 20:
                case "end":
                  return _context.stop();
              }
            }, "_callee$"), _callee, this);
          }, "_callee")));
          function slice(_x3, _x4) {
            return _slice.apply(this, arguments);
          }
          __name(slice, "slice");
          return slice;
        }()
      }, {
        key: "close",
        value: /* @__PURE__ */ __name(function close() {
          this._stream.destroy();
        }, "close")
      }]);
    }();
  }
});

// node_modules/tus-js-client/lib.es5/node/fileReader.js
var require_fileReader = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/fileReader.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _fs = __require("fs");
    var _isStream = _interopRequireDefault(require_is_stream());
    var _BufferSource = _interopRequireDefault(require_BufferSource());
    var _FileSource = _interopRequireDefault(require_FileSource());
    var _StreamSource = _interopRequireDefault(require_StreamSource());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var FileReader = exports2.default = /* @__PURE__ */ function() {
      function FileReader2() {
        _classCallCheck(this, FileReader2);
      }
      __name(FileReader2, "FileReader");
      return _createClass(FileReader2, [{
        key: "openFile",
        value: /* @__PURE__ */ __name(function openFile(input, chunkSize) {
          if (Buffer.isBuffer(input)) {
            return Promise.resolve(new _BufferSource.default(input));
          }
          if (input instanceof _fs.ReadStream && input.path != null) {
            return (0, _FileSource.default)(input);
          }
          if (_isStream.default.readable(input)) {
            chunkSize = Number(chunkSize);
            if (!Number.isFinite(chunkSize)) {
              return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option; specify a chunkSize to control the memory consumption"));
            }
            return Promise.resolve(new _StreamSource.default(input));
          }
          return Promise.reject(new Error("source object may only be an instance of Buffer or Readable in this environment"));
        }, "openFile")
      }]);
    }();
  }
});

// node_modules/tus-js-client/lib.es5/node/fileSignature.js
var require_fileSignature = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/fileSignature.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fingerprint;
    var _crypto = __require("crypto");
    var fs = _interopRequireWildcard(__require("fs"));
    var path2 = _interopRequireWildcard(__require("path"));
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(e2) {
        return e2 ? t : r;
      }, "_getRequireWildcardCache"))(e);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u2 in e) if ("default" !== u2 && {}.hasOwnProperty.call(e, u2)) {
        var i2 = a2 ? Object.getOwnPropertyDescriptor(e, u2) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e[u2];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function fingerprint(file, options) {
      if (Buffer.isBuffer(file)) {
        var blockSize = 64 * 1024;
        var content = file.slice(0, Math.min(blockSize, file.length));
        var hash = (0, _crypto.createHash)("md5").update(content).digest("hex");
        var ret = ["node-buffer", hash, file.length, options.endpoint].join("-");
        return Promise.resolve(ret);
      }
      if (file instanceof fs.ReadStream && file.path != null) {
        return new Promise(function(resolve, reject) {
          var name = path2.resolve(file.path);
          fs.stat(file.path, function(err, info) {
            if (err) {
              reject(err);
              return;
            }
            var ret2 = ["node-file", name, info.size, info.mtime.getTime(), options.endpoint].join("-");
            resolve(ret2);
          });
        });
      }
      return Promise.resolve(null);
    }
    __name(fingerprint, "fingerprint");
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports2, module2) {
    init_esm();
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var objectProto12 = Object.prototype;
    var objectToString3 = objectProto12.toString;
    var nativeMax2 = Math.max;
    var nativeMin = Math.min;
    var now = /* @__PURE__ */ __name(function() {
      return root2.Date.now();
    }, "now");
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject4(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      __name(invokeFunc, "invokeFunc");
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      __name(leadingEdge, "leadingEdge");
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      __name(remainingWait, "remainingWait");
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      __name(shouldInvoke, "shouldInvoke");
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      __name(timerExpired, "timerExpired");
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      __name(trailingEdge, "trailingEdge");
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      __name(cancel, "cancel");
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      __name(flush, "flush");
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      __name(debounced, "debounced");
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    __name(debounce, "debounce");
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject4(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    __name(throttle, "throttle");
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject4, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString3.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module2.exports = throttle;
  }
});

// node_modules/tus-js-client/lib.es5/node/httpStack.js
var require_httpStack = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/httpStack.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var http3 = _interopRequireWildcard(__require("http"));
    var https2 = _interopRequireWildcard(__require("https"));
    var _stream = __require("stream");
    var _url = __require("url");
    var _lodash = _interopRequireDefault(require_lodash());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(e2) {
        return e2 ? t : r;
      }, "_getRequireWildcardCache"))(e);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u2 in e) if ("default" !== u2 && {}.hasOwnProperty.call(e, u2)) {
        var i2 = a2 ? Object.getOwnPropertyDescriptor(e, u2) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e[u2];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _callSuper(t, o2, e) {
      return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
    }
    __name(_callSuper, "_callSuper");
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    __name(_possibleConstructorReturn, "_possibleConstructorReturn");
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    __name(_assertThisInitialized, "_assertThisInitialized");
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
        return !!t;
      }, "_isNativeReflectConstruct"))();
    }
    __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, "_getPrototypeOf");
      return _getPrototypeOf(o2);
    }
    __name(_getPrototypeOf, "_getPrototypeOf");
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    __name(_inherits, "_inherits");
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      }, "_setPrototypeOf");
      return _setPrototypeOf(o2, p);
    }
    __name(_setPrototypeOf, "_setPrototypeOf");
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e);
        r && (o2 = o2.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o2);
      }
      return t;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var NodeHttpStack = exports2.default = /* @__PURE__ */ function() {
      function NodeHttpStack2() {
        var requestOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, NodeHttpStack2);
        this._requestOptions = requestOptions;
      }
      __name(NodeHttpStack2, "NodeHttpStack");
      return _createClass(NodeHttpStack2, [{
        key: "createRequest",
        value: /* @__PURE__ */ __name(function createRequest(method, url) {
          return new Request2(method, url, this._requestOptions);
        }, "createRequest")
      }, {
        key: "getName",
        value: /* @__PURE__ */ __name(function getName() {
          return "NodeHttpStack";
        }, "getName")
      }]);
    }();
    var Request2 = /* @__PURE__ */ function() {
      function Request3(method, url, options) {
        _classCallCheck(this, Request3);
        this._method = method;
        this._url = url;
        this._headers = {};
        this._request = null;
        this._progressHandler = function() {
        };
        this._requestOptions = options || {};
      }
      __name(Request3, "Request");
      return _createClass(Request3, [{
        key: "getMethod",
        value: /* @__PURE__ */ __name(function getMethod() {
          return this._method;
        }, "getMethod")
      }, {
        key: "getURL",
        value: /* @__PURE__ */ __name(function getURL() {
          return this._url;
        }, "getURL")
      }, {
        key: "setHeader",
        value: /* @__PURE__ */ __name(function setHeader(header, value) {
          this._headers[header] = value;
        }, "setHeader")
      }, {
        key: "getHeader",
        value: /* @__PURE__ */ __name(function getHeader(header) {
          return this._headers[header];
        }, "getHeader")
      }, {
        key: "setProgressHandler",
        value: /* @__PURE__ */ __name(function setProgressHandler(progressHandler) {
          this._progressHandler = progressHandler;
        }, "setProgressHandler")
      }, {
        key: "send",
        value: /* @__PURE__ */ __name(function send() {
          var _this = this;
          var body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          return new Promise(function(resolve, reject) {
            var options = _objectSpread(_objectSpread(_objectSpread({}, (0, _url.parse)(_this._url)), _this._requestOptions), {}, {
              method: _this._method,
              headers: _objectSpread(_objectSpread({}, _this._requestOptions.headers || {}), _this._headers)
            });
            if (body !== null && body !== void 0 && body.size) {
              options.headers["Content-Length"] = body.size;
            }
            var httpModule = options.protocol === "https:" ? https2 : http3;
            _this._request = httpModule.request(options);
            var req = _this._request;
            req.on("response", function(res) {
              var resChunks = [];
              res.on("data", function(data) {
                resChunks.push(data);
              });
              res.on("end", function() {
                var responseText = Buffer.concat(resChunks).toString("utf8");
                resolve(new Response2(res, responseText));
              });
            });
            req.on("error", function(err) {
              reject(err);
            });
            if (body instanceof _stream.Readable) {
              body.pipe(new ProgressEmitter(_this._progressHandler)).pipe(req);
            } else if (body instanceof Uint8Array) {
              writeBufferToStreamWithProgress(req, body, _this._progressHandler);
            } else {
              req.end(body);
            }
          });
        }, "send")
      }, {
        key: "abort",
        value: /* @__PURE__ */ __name(function abort() {
          if (this._request !== null) this._request.abort();
          return Promise.resolve();
        }, "abort")
      }, {
        key: "getUnderlyingObject",
        value: /* @__PURE__ */ __name(function getUnderlyingObject() {
          return this._request;
        }, "getUnderlyingObject")
      }]);
    }();
    var Response2 = /* @__PURE__ */ function() {
      function Response3(res, body) {
        _classCallCheck(this, Response3);
        this._response = res;
        this._body = body;
      }
      __name(Response3, "Response");
      return _createClass(Response3, [{
        key: "getStatus",
        value: /* @__PURE__ */ __name(function getStatus() {
          return this._response.statusCode;
        }, "getStatus")
      }, {
        key: "getHeader",
        value: /* @__PURE__ */ __name(function getHeader(header) {
          return this._response.headers[header.toLowerCase()];
        }, "getHeader")
      }, {
        key: "getBody",
        value: /* @__PURE__ */ __name(function getBody() {
          return this._body;
        }, "getBody")
      }, {
        key: "getUnderlyingObject",
        value: /* @__PURE__ */ __name(function getUnderlyingObject() {
          return this._response;
        }, "getUnderlyingObject")
      }]);
    }();
    var ProgressEmitter = /* @__PURE__ */ function(_Transform) {
      function ProgressEmitter2(onprogress) {
        var _this2;
        _classCallCheck(this, ProgressEmitter2);
        _this2 = _callSuper(this, ProgressEmitter2);
        _this2._onprogress = (0, _lodash.default)(onprogress, 100, {
          leading: true,
          trailing: false
        });
        _this2._position = 0;
        return _this2;
      }
      __name(ProgressEmitter2, "ProgressEmitter");
      _inherits(ProgressEmitter2, _Transform);
      return _createClass(ProgressEmitter2, [{
        key: "_transform",
        value: /* @__PURE__ */ __name(function _transform(chunk2, _encoding, callback) {
          this._position += chunk2.length;
          this._onprogress(this._position);
          callback(null, chunk2);
        }, "_transform")
      }]);
    }(_stream.Transform);
    var writeBufferToStreamWithProgress = /* @__PURE__ */ __name(function writeBufferToStreamWithProgress2(stream2, source, onprogress) {
      onprogress = (0, _lodash.default)(onprogress, 100, {
        leading: true,
        trailing: false
      });
      var offset = 0;
      function writeNextChunk() {
        var chunkSize = Math.min(stream2.writableHighWaterMark, source.length - offset);
        var chunk2 = source.subarray(offset, offset + chunkSize);
        offset += chunk2.length;
        var canContinue = stream2.write(chunk2);
        if (!canContinue) {
          stream2.once("drain", writeNextChunk);
          onprogress(offset);
        } else if (offset < source.length) {
          writeNextChunk();
        } else {
          stream2.end();
        }
      }
      __name(writeNextChunk, "writeNextChunk");
      writeNextChunk();
    }, "writeBufferToStreamWithProgress");
  }
});

// node_modules/custom-error-instance/bin/factories.js
var require_factories = __commonJS({
  "node_modules/custom-error-instance/bin/factories.js"(exports2) {
    "use strict";
    init_esm();
    exports2.expectReceive = function(properties, configuration, factory) {
      var message;
      factory.root(properties, configuration, factory);
      message = this.message;
      if (properties.hasOwnProperty("expected")) message += " Expected " + properties.expected + ".";
      if (properties.hasOwnProperty("received")) message += " Received: " + properties.received + ".";
      this.message = message;
    };
    exports2.root = function(properties, configuration, factories) {
      var _this = this;
      var code;
      var config = { stackLength: Error.stackTraceLimit, rootOnly: true };
      var messageStr = "";
      var originalStackLength = Error.stackTraceLimit;
      var stack;
      function updateStack() {
        stack[0] = _this.toString();
        _this.stack = stack.join("\n");
      }
      __name(updateStack, "updateStack");
      if (!configuration || typeof configuration !== "object") configuration = {};
      if (configuration.hasOwnProperty("stackLength") && typeof configuration.stackLength === "number" && !isNaN(configuration.stackLength) && configuration.stackLength >= 0) config.stackLength = configuration.stackLength;
      if (!configuration.hasOwnProperty("rootOnly")) config.rootOnly = configuration.rootOnly;
      if (!config.rootOnly || this.CustomError.parent === Error) {
        Object.keys(properties).forEach(function(key) {
          switch (key) {
            case "code":
              code = properties.code || void 0;
              break;
            case "message":
              messageStr = properties.message || "";
              break;
            default:
              _this[key] = properties[key];
          }
        });
        Error.stackTraceLimit = config.stackLength + 2;
        stack = new Error().stack.split("\n");
        stack.splice(0, 3);
        stack.unshift("");
        Error.stackTraceLimit = originalStackLength;
        this.stack = stack.join("\n");
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          get: /* @__PURE__ */ __name(function() {
            return code;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            code = value;
            updateStack();
          }, "set")
        });
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: true,
          get: /* @__PURE__ */ __name(function() {
            return messageStr;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            messageStr = value;
            updateStack();
          }, "set")
        });
        updateStack();
      }
    };
  }
});

// node_modules/custom-error-instance/bin/error.js
var require_error2 = __commonJS({
  "node_modules/custom-error-instance/bin/error.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = CustomError;
    CustomError.factory = require_factories();
    var Err = CustomError("CustomError");
    Err.order = CustomError(Err, { message: "Arguments out of order.", code: "EOARG" });
    function CustomError(name, parent, properties, factory) {
      var construct;
      var isRoot;
      parent = findArg(arguments, 1, Error, isParentArg, [isPropertiesArg, isFactoryArg]);
      properties = findArg(arguments, 2, {}, isPropertiesArg, [isFactoryArg]);
      factory = findArg(arguments, 3, noop4, isFactoryArg, []);
      name = findArg(arguments, 0, parent === Error ? "Error" : parent.prototype.CustomError.name, isNameArg, [isParentArg, isPropertiesArg, isFactoryArg]);
      isRoot = parent === Error;
      if (isRoot && factory === noop4) factory = CustomError.factory.root;
      construct = /* @__PURE__ */ __name(function(message, configuration) {
        var _this;
        var ar;
        var factories;
        var i2;
        var item;
        var props;
        if (!(this instanceof construct)) return new construct(message, configuration);
        delete this.constructor.name;
        Object.defineProperty(this.constructor, "name", {
          enumerable: false,
          configurable: true,
          value: name,
          writable: false
        });
        if (typeof message === "string") message = { message };
        if (!message) message = {};
        ar = this.CustomError.chain.slice(0).reverse().map(function(value) {
          return value.properties;
        });
        ar.push(message);
        ar.unshift({});
        props = Object.assign.apply(Object, ar);
        _this = this;
        factories = {};
        Object.keys(CustomError.factory).forEach(function(key) {
          factories[key] = function(props2, config) {
            CustomError.factory[key].call(_this, props2, config, factories);
          };
        });
        for (i2 = this.CustomError.chain.length - 1; i2 >= 0; i2--) {
          item = this.CustomError.chain[i2];
          if (item.factory !== noop4) {
            item.factory.call(this, props, configuration, factories);
          }
        }
      }, "construct");
      construct.prototype = Object.create(parent.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.name = name;
      construct.prototype.CustomError = {
        chain: isRoot ? [] : parent.prototype.CustomError.chain.slice(0),
        factory,
        name,
        parent,
        properties
      };
      construct.prototype.CustomError.chain.unshift(construct.prototype.CustomError);
      construct.prototype.toString = function() {
        var result = this.CustomError.chain[this.CustomError.chain.length - 1].name;
        if (this.code) result += " " + this.code;
        if (this.message) result += ": " + this.message;
        return result;
      };
      return construct;
    }
    __name(CustomError, "CustomError");
    function findArg(args, index, defaultValue, filter, antiFilters) {
      var anti = -1;
      var found = -1;
      var i2;
      var j;
      var len = index < args.length ? index : args.length;
      var val;
      for (i2 = 0; i2 <= len; i2++) {
        val = args[i2];
        if (anti === -1) {
          for (j = 0; j < antiFilters.length; j++) {
            if (antiFilters[j](val)) anti = i2;
          }
        }
        if (found === -1 && filter(val)) {
          found = i2;
        }
      }
      if (found !== -1 && anti !== -1 && anti < found) throw new Err.order();
      return found !== -1 ? args[found] : defaultValue;
    }
    __name(findArg, "findArg");
    function isFactoryArg(value) {
      return typeof value === "function" && value !== Error && !value.prototype.CustomError;
    }
    __name(isFactoryArg, "isFactoryArg");
    function isNameArg(value) {
      return typeof value === "string";
    }
    __name(isNameArg, "isNameArg");
    function isParentArg(value) {
      return typeof value === "function" && (value === Error || value.prototype.CustomError);
    }
    __name(isParentArg, "isParentArg");
    function isPropertiesArg(value) {
      return value && typeof value === "object";
    }
    __name(isPropertiesArg, "isPropertiesArg");
    function noop4() {
    }
    __name(noop4, "noop");
  }
});

// node_modules/custom-error-instance/index.js
var require_custom_error_instance = __commonJS({
  "node_modules/custom-error-instance/index.js"(exports2, module2) {
    init_esm();
    module2.exports = require_error2();
  }
});

// node_modules/lodash._basetostring/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash._basetostring/index.js"(exports2, module2) {
    init_esm();
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports4 = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule4 = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal2 = checkGlobal(freeExports4 && freeModule4 && typeof global == "object" && global);
    var freeSelf2 = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal2 || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf2 || thisGlobal || Function("return this")();
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    __name(checkGlobal, "checkGlobal");
    var objectProto12 = Object.prototype;
    var objectToString3 = objectProto12.toString;
    var Symbol3 = root2.Symbol;
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString3.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    module2.exports = baseToString;
  }
});

// node_modules/lodash._stringtopath/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash._stringtopath/index.js"(exports2, module2) {
    init_esm();
    var baseToString = require_lodash2();
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports4 = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule4 = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal2 = checkGlobal(freeExports4 && freeModule4 && typeof global == "object" && global);
    var freeSelf2 = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal2 || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf2 || thisGlobal || Function("return this")();
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    __name(checkGlobal, "checkGlobal");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    var arrayProto2 = Array.prototype;
    var objectProto12 = Object.prototype;
    var funcToString4 = Function.prototype.toString;
    var hasOwnProperty10 = objectProto12.hasOwnProperty;
    var objectToString3 = objectProto12.toString;
    var reIsNative2 = RegExp(
      "^" + funcToString4.call(hasOwnProperty10).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice2 = arrayProto2.splice;
    var Map3 = getNative2(root2, "Map");
    var nativeCreate2 = getNative2(Object, "create");
    function Hash2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear2() {
      this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    }
    __name(hashClear2, "hashClear");
    function hashDelete2(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete2, "hashDelete");
    function hashGet2(key) {
      var data = this.__data__;
      if (nativeCreate2) {
        var result = data[key];
        return result === HASH_UNDEFINED3 ? void 0 : result;
      }
      return hasOwnProperty10.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet2, "hashGet");
    function hashHas2(key) {
      var data = this.__data__;
      return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
    }
    __name(hashHas2, "hashHas");
    function hashSet2(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED3 : value;
      return this;
    }
    __name(hashSet2, "hashSet");
    Hash2.prototype.clear = hashClear2;
    Hash2.prototype["delete"] = hashDelete2;
    Hash2.prototype.get = hashGet2;
    Hash2.prototype.has = hashHas2;
    Hash2.prototype.set = hashSet2;
    function ListCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache2, "ListCache");
    function listCacheClear2() {
      this.__data__ = [];
    }
    __name(listCacheClear2, "listCacheClear");
    function listCacheDelete2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice2.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete2, "listCacheDelete");
    function listCacheGet2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet2, "listCacheGet");
    function listCacheHas2(key) {
      return assocIndexOf2(this.__data__, key) > -1;
    }
    __name(listCacheHas2, "listCacheHas");
    function listCacheSet2(key, value) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet2, "listCacheSet");
    ListCache2.prototype.clear = listCacheClear2;
    ListCache2.prototype["delete"] = listCacheDelete2;
    ListCache2.prototype.get = listCacheGet2;
    ListCache2.prototype.has = listCacheHas2;
    ListCache2.prototype.set = listCacheSet2;
    function MapCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache2, "MapCache");
    function mapCacheClear2() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map3 || ListCache2)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear2, "mapCacheClear");
    function mapCacheDelete2(key) {
      return getMapData2(this, key)["delete"](key);
    }
    __name(mapCacheDelete2, "mapCacheDelete");
    function mapCacheGet2(key) {
      return getMapData2(this, key).get(key);
    }
    __name(mapCacheGet2, "mapCacheGet");
    function mapCacheHas2(key) {
      return getMapData2(this, key).has(key);
    }
    __name(mapCacheHas2, "mapCacheHas");
    function mapCacheSet2(key, value) {
      getMapData2(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet2, "mapCacheSet");
    MapCache2.prototype.clear = mapCacheClear2;
    MapCache2.prototype["delete"] = mapCacheDelete2;
    MapCache2.prototype.get = mapCacheGet2;
    MapCache2.prototype.has = mapCacheHas2;
    MapCache2.prototype.set = mapCacheSet2;
    function assocIndexOf2(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf2, "assocIndexOf");
    function getMapData2(map, key) {
      var data = map.__data__;
      return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData2, "getMapData");
    function getNative2(object, key) {
      var value = object[key];
      return isNative(value) ? value : void 0;
    }
    __name(getNative2, "getNative");
    function isKeyable2(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable2, "isKeyable");
    var stringToPath = memoize(function(string) {
      var result = [];
      toString2(string).replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString4.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource2, "toSource");
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache2)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache2;
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq2, "eq");
    function isFunction4(value) {
      var tag = isObject4(value) ? objectToString3.call(value) : "";
      return tag == funcTag3 || tag == genTag2;
    }
    __name(isFunction4, "isFunction");
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject4, "isObject");
    function isNative(value) {
      if (!isObject4(value)) {
        return false;
      }
      var pattern = isFunction4(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value));
    }
    __name(isNative, "isNative");
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString2, "toString");
    module2.exports = stringToPath;
  }
});

// node_modules/lodash._baseiteratee/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash._baseiteratee/index.js"(exports2, module2) {
    init_esm();
    var stringToPath = require_lodash3();
    var LARGE_ARRAY_SIZE2 = 200;
    var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER3 = 9007199254740991;
    var argsTag3 = "[object Arguments]";
    var arrayTag2 = "[object Array]";
    var boolTag2 = "[object Boolean]";
    var dateTag2 = "[object Date]";
    var errorTag2 = "[object Error]";
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var mapTag2 = "[object Map]";
    var numberTag2 = "[object Number]";
    var objectTag3 = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag2 = "[object RegExp]";
    var setTag2 = "[object Set]";
    var stringTag2 = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag2 = "[object WeakMap]";
    var arrayBufferTag2 = "[object ArrayBuffer]";
    var dataViewTag2 = "[object DataView]";
    var float32Tag2 = "[object Float32Array]";
    var float64Tag2 = "[object Float64Array]";
    var int8Tag2 = "[object Int8Array]";
    var int16Tag2 = "[object Int16Array]";
    var int32Tag2 = "[object Int32Array]";
    var uint8Tag2 = "[object Uint8Array]";
    var uint8ClampedTag2 = "[object Uint8ClampedArray]";
    var uint16Tag2 = "[object Uint16Array]";
    var uint32Tag2 = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag3] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag3] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag3] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports4 = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule4 = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal2 = checkGlobal(freeExports4 && freeModule4 && typeof global == "object" && global);
    var freeSelf2 = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal2 || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf2 || thisGlobal || Function("return this")();
    function arrayMap(array, iteratee) {
      var index = -1, length = array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arraySome(array, predicate) {
      var index = -1, length = array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    function baseTimes2(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes2, "baseTimes");
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    __name(baseToPairs, "baseToPairs");
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    __name(checkGlobal, "checkGlobal");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    __name(setToPairs, "setToPairs");
    var arrayProto2 = Array.prototype;
    var objectProto12 = Object.prototype;
    var funcToString4 = Function.prototype.toString;
    var hasOwnProperty10 = objectProto12.hasOwnProperty;
    var objectToString3 = objectProto12.toString;
    var reIsNative2 = RegExp(
      "^" + funcToString4.call(hasOwnProperty10).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol3 = root2.Symbol;
    var Uint8Array3 = root2.Uint8Array;
    var propertyIsEnumerable2 = objectProto12.propertyIsEnumerable;
    var splice2 = arrayProto2.splice;
    var nativeGetPrototype = Object.getPrototypeOf;
    var nativeKeys = Object.keys;
    var DataView2 = getNative2(root2, "DataView");
    var Map3 = getNative2(root2, "Map");
    var Promise2 = getNative2(root2, "Promise");
    var Set2 = getNative2(root2, "Set");
    var WeakMap2 = getNative2(root2, "WeakMap");
    var nativeCreate2 = getNative2(Object, "create");
    var dataViewCtorString = toSource2(DataView2);
    var mapCtorString = toSource2(Map3);
    var promiseCtorString = toSource2(Promise2);
    var setCtorString = toSource2(Set2);
    var weakMapCtorString = toSource2(WeakMap2);
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear2() {
      this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    }
    __name(hashClear2, "hashClear");
    function hashDelete2(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete2, "hashDelete");
    function hashGet2(key) {
      var data = this.__data__;
      if (nativeCreate2) {
        var result = data[key];
        return result === HASH_UNDEFINED3 ? void 0 : result;
      }
      return hasOwnProperty10.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet2, "hashGet");
    function hashHas2(key) {
      var data = this.__data__;
      return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
    }
    __name(hashHas2, "hashHas");
    function hashSet2(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED3 : value;
      return this;
    }
    __name(hashSet2, "hashSet");
    Hash2.prototype.clear = hashClear2;
    Hash2.prototype["delete"] = hashDelete2;
    Hash2.prototype.get = hashGet2;
    Hash2.prototype.has = hashHas2;
    Hash2.prototype.set = hashSet2;
    function ListCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache2, "ListCache");
    function listCacheClear2() {
      this.__data__ = [];
    }
    __name(listCacheClear2, "listCacheClear");
    function listCacheDelete2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice2.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete2, "listCacheDelete");
    function listCacheGet2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet2, "listCacheGet");
    function listCacheHas2(key) {
      return assocIndexOf2(this.__data__, key) > -1;
    }
    __name(listCacheHas2, "listCacheHas");
    function listCacheSet2(key, value) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet2, "listCacheSet");
    ListCache2.prototype.clear = listCacheClear2;
    ListCache2.prototype["delete"] = listCacheDelete2;
    ListCache2.prototype.get = listCacheGet2;
    ListCache2.prototype.has = listCacheHas2;
    ListCache2.prototype.set = listCacheSet2;
    function MapCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache2, "MapCache");
    function mapCacheClear2() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map3 || ListCache2)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear2, "mapCacheClear");
    function mapCacheDelete2(key) {
      return getMapData2(this, key)["delete"](key);
    }
    __name(mapCacheDelete2, "mapCacheDelete");
    function mapCacheGet2(key) {
      return getMapData2(this, key).get(key);
    }
    __name(mapCacheGet2, "mapCacheGet");
    function mapCacheHas2(key) {
      return getMapData2(this, key).has(key);
    }
    __name(mapCacheHas2, "mapCacheHas");
    function mapCacheSet2(key, value) {
      getMapData2(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet2, "mapCacheSet");
    MapCache2.prototype.clear = mapCacheClear2;
    MapCache2.prototype["delete"] = mapCacheDelete2;
    MapCache2.prototype.get = mapCacheGet2;
    MapCache2.prototype.has = mapCacheHas2;
    MapCache2.prototype.set = mapCacheSet2;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache2();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED3);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack2(entries3) {
      this.__data__ = new ListCache2(entries3);
    }
    __name(Stack2, "Stack");
    function stackClear2() {
      this.__data__ = new ListCache2();
    }
    __name(stackClear2, "stackClear");
    function stackDelete2(key) {
      return this.__data__["delete"](key);
    }
    __name(stackDelete2, "stackDelete");
    function stackGet2(key) {
      return this.__data__.get(key);
    }
    __name(stackGet2, "stackGet");
    function stackHas2(key) {
      return this.__data__.has(key);
    }
    __name(stackHas2, "stackHas");
    function stackSet2(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache2 && cache.__data__.length == LARGE_ARRAY_SIZE2) {
        cache = this.__data__ = new MapCache2(cache.__data__);
      }
      cache.set(key, value);
      return this;
    }
    __name(stackSet2, "stackSet");
    Stack2.prototype.clear = stackClear2;
    Stack2.prototype["delete"] = stackDelete2;
    Stack2.prototype.get = stackGet2;
    Stack2.prototype.has = stackHas2;
    Stack2.prototype.set = stackSet2;
    function assocIndexOf2(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf2, "assocIndexOf");
    function baseGet(object, path2) {
      path2 = isKey(path2, object) ? [path2] : castPath(path2);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    function baseHas(object, key) {
      return hasOwnProperty10.call(object, key) || typeof object == "object" && key in object && getPrototype2(object) === null;
    }
    __name(baseHas, "baseHas");
    function baseHasIn(object, key) {
      return key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject4(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = arrayTag2, othTag = arrayTag2;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag3 ? objectTag3 : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag3 ? objectTag3 : othTag;
      }
      var objIsObj = objTag == objectTag3 && !isHostObject(object), othIsObj = othTag == objectTag3 && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack2());
        return objIsArr || isTypedArray3(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty10.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty10.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack2());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack2());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack2();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity2;
      }
      if (typeof value == "object") {
        return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    __name(baseKeys, "baseKeys");
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    function castPath(value) {
      return isArray3(value) ? value : stringToPath(value);
    }
    __name(castPath, "castPath");
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag2) {
          return mapToArray(object);
        }
        if (tag == setTag2) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }
    __name(createToPairs, "createToPairs");
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      return result;
    }
    __name(equalArrays, "equalArrays");
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag2:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag2:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
            return false;
          }
          return true;
        case boolTag2:
        case dateTag2:
          return +object == +other;
        case errorTag2:
          return object.name == other.name && object.message == other.message;
        case numberTag2:
          return object != +object ? other != +other : object == +other;
        case regexpTag2:
        case stringTag2:
          return object == other + "";
        case mapTag2:
          var convert = mapToArray;
        case setTag2:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : baseHas(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      return result;
    }
    __name(equalObjects, "equalObjects");
    var getLength = baseProperty("length");
    function getMapData2(map, key) {
      var data = map.__data__;
      return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData2, "getMapData");
    function getMatchData(object) {
      var result = toPairs(object), length = result.length;
      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    function getNative2(object, key) {
      var value = object[key];
      return isNative(value) ? value : void 0;
    }
    __name(getNative2, "getNative");
    function getPrototype2(value) {
      return nativeGetPrototype(Object(value));
    }
    __name(getPrototype2, "getPrototype");
    function getTag(value) {
      return objectToString3.call(value);
    }
    __name(getTag, "getTag");
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map3 && getTag(new Map3()) != mapTag2 || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag2 || WeakMap2 && getTag(new WeakMap2()) != weakMapTag2) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = objectToString3.call(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag2;
            case mapCtorString:
              return mapTag2;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag2;
            case weakMapCtorString:
              return weakMapTag2;
          }
        }
        return result;
      }, "getTag");
    }
    function hasPath(object, path2, hasFunc) {
      path2 = isKey(path2, object) ? [path2] : castPath(path2);
      var result, index = -1, length = path2.length;
      while (++index < length) {
        var key = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength2(length) && isIndex2(key, length) && (isArray3(object) || isString2(object) || isArguments2(object));
    }
    __name(hasPath, "hasPath");
    function indexKeys(object) {
      var length = object ? object.length : void 0;
      if (isLength2(length) && (isArray3(object) || isString2(object) || isArguments2(object))) {
        return baseTimes2(length, String);
      }
      return null;
    }
    __name(indexKeys, "indexKeys");
    function isIndex2(value, length) {
      length = length == null ? MAX_SAFE_INTEGER3 : length;
      return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex2, "isIndex");
    function isKey(value, object) {
      if (isArray3(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    function isKeyable2(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable2, "isKeyable");
    function isPrototype2(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto12;
      return value === proto;
    }
    __name(isPrototype2, "isPrototype");
    function isStrictComparable(value) {
      return value === value && !isObject4(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    function toKey(value) {
      if (typeof value == "string" || isSymbol2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString4.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource2, "toSource");
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq2, "eq");
    function isArguments2(value) {
      return isArrayLikeObject2(value) && hasOwnProperty10.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString3.call(value) == argsTag3);
    }
    __name(isArguments2, "isArguments");
    var isArray3 = Array.isArray;
    function isArrayLike3(value) {
      return value != null && isLength2(getLength(value)) && !isFunction4(value);
    }
    __name(isArrayLike3, "isArrayLike");
    function isArrayLikeObject2(value) {
      return isObjectLike2(value) && isArrayLike3(value);
    }
    __name(isArrayLikeObject2, "isArrayLikeObject");
    function isFunction4(value) {
      var tag = isObject4(value) ? objectToString3.call(value) : "";
      return tag == funcTag3 || tag == genTag2;
    }
    __name(isFunction4, "isFunction");
    function isLength2(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
    }
    __name(isLength2, "isLength");
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject4, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isNative(value) {
      if (!isObject4(value)) {
        return false;
      }
      var pattern = isFunction4(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value));
    }
    __name(isNative, "isNative");
    function isString2(value) {
      return typeof value == "string" || !isArray3(value) && isObjectLike2(value) && objectToString3.call(value) == stringTag2;
    }
    __name(isString2, "isString");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString3.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function isTypedArray3(value) {
      return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[objectToString3.call(value)];
    }
    __name(isTypedArray3, "isTypedArray");
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    __name(get, "get");
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    __name(hasIn, "hasIn");
    function keys(object) {
      var isProto = isPrototype2(object);
      if (!(isProto || isArrayLike3(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
      for (var key in object) {
        if (baseHas(object, key) && !(skipIndexes && (key == "length" || isIndex2(key, length))) && !(isProto && key == "constructor")) {
          result.push(key);
        }
      }
      return result;
    }
    __name(keys, "keys");
    var toPairs = createToPairs(keys);
    function identity2(value) {
      return value;
    }
    __name(identity2, "identity");
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    __name(property, "property");
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash._createset/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash._createset/index.js"(exports2, module2) {
    init_esm();
    var INFINITY = 1 / 0;
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports4 = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule4 = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal2 = checkGlobal(freeExports4 && freeModule4 && typeof global == "object" && global);
    var freeSelf2 = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal2 || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf2 || thisGlobal || Function("return this")();
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    __name(checkGlobal, "checkGlobal");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var objectProto12 = Object.prototype;
    var funcToString4 = Function.prototype.toString;
    var hasOwnProperty10 = objectProto12.hasOwnProperty;
    var objectToString3 = objectProto12.toString;
    var reIsNative2 = RegExp(
      "^" + funcToString4.call(hasOwnProperty10).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Set2 = getNative2(root2, "Set");
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop4 : function(values) {
      return new Set2(values);
    };
    function getNative2(object, key) {
      var value = object[key];
      return isNative(value) ? value : void 0;
    }
    __name(getNative2, "getNative");
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString4.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource2, "toSource");
    function isFunction4(value) {
      var tag = isObject4(value) ? objectToString3.call(value) : "";
      return tag == funcTag3 || tag == genTag2;
    }
    __name(isFunction4, "isFunction");
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject4, "isObject");
    function isNative(value) {
      if (!isObject4(value)) {
        return false;
      }
      var pattern = isFunction4(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value));
    }
    __name(isNative, "isNative");
    function noop4() {
    }
    __name(noop4, "noop");
    module2.exports = createSet;
  }
});

// node_modules/lodash._root/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash._root/index.js"(exports2, module2) {
    init_esm();
    var objectTypes = {
      "function": true,
      "object": true
    };
    var freeExports4 = objectTypes[typeof exports2] && exports2 && !exports2.nodeType ? exports2 : void 0;
    var freeModule4 = objectTypes[typeof module2] && module2 && !module2.nodeType ? module2 : void 0;
    var freeGlobal2 = checkGlobal(freeExports4 && freeModule4 && typeof global == "object" && global);
    var freeSelf2 = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof exports2] && exports2);
    var root2 = freeGlobal2 || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf2 || thisGlobal || Function("return this")();
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }
    __name(checkGlobal, "checkGlobal");
    module2.exports = root2;
  }
});

// node_modules/lodash._baseuniq/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash._baseuniq/index.js"(exports2, module2) {
    init_esm();
    var createSet = require_lodash5();
    var root2 = require_lodash6();
    var LARGE_ARRAY_SIZE2 = 200;
    var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    function arrayIncludes(array, value) {
      return !!array.length && baseIndexOf(array, value, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return indexOfNaN(array, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(baseIndexOf, "baseIndexOf");
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    __name(cacheHas, "cacheHas");
    function indexOfNaN(array, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
      while (fromRight ? index-- : ++index < length) {
        var other = array[index];
        if (other !== other) {
          return index;
        }
      }
      return -1;
    }
    __name(indexOfNaN, "indexOfNaN");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto2 = Array.prototype;
    var objectProto12 = Object.prototype;
    var funcToString4 = Function.prototype.toString;
    var hasOwnProperty10 = objectProto12.hasOwnProperty;
    var objectToString3 = objectProto12.toString;
    var reIsNative2 = RegExp(
      "^" + funcToString4.call(hasOwnProperty10).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice2 = arrayProto2.splice;
    var Map3 = getNative2(root2, "Map");
    var nativeCreate2 = getNative2(Object, "create");
    function Hash2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear2() {
      this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    }
    __name(hashClear2, "hashClear");
    function hashDelete2(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete2, "hashDelete");
    function hashGet2(key) {
      var data = this.__data__;
      if (nativeCreate2) {
        var result = data[key];
        return result === HASH_UNDEFINED3 ? void 0 : result;
      }
      return hasOwnProperty10.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet2, "hashGet");
    function hashHas2(key) {
      var data = this.__data__;
      return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
    }
    __name(hashHas2, "hashHas");
    function hashSet2(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED3 : value;
      return this;
    }
    __name(hashSet2, "hashSet");
    Hash2.prototype.clear = hashClear2;
    Hash2.prototype["delete"] = hashDelete2;
    Hash2.prototype.get = hashGet2;
    Hash2.prototype.has = hashHas2;
    Hash2.prototype.set = hashSet2;
    function ListCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache2, "ListCache");
    function listCacheClear2() {
      this.__data__ = [];
    }
    __name(listCacheClear2, "listCacheClear");
    function listCacheDelete2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice2.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete2, "listCacheDelete");
    function listCacheGet2(key) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet2, "listCacheGet");
    function listCacheHas2(key) {
      return assocIndexOf2(this.__data__, key) > -1;
    }
    __name(listCacheHas2, "listCacheHas");
    function listCacheSet2(key, value) {
      var data = this.__data__, index = assocIndexOf2(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet2, "listCacheSet");
    ListCache2.prototype.clear = listCacheClear2;
    ListCache2.prototype["delete"] = listCacheDelete2;
    ListCache2.prototype.get = listCacheGet2;
    ListCache2.prototype.has = listCacheHas2;
    ListCache2.prototype.set = listCacheSet2;
    function MapCache2(entries3) {
      var index = -1, length = entries3 ? entries3.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries3[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache2, "MapCache");
    function mapCacheClear2() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map3 || ListCache2)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear2, "mapCacheClear");
    function mapCacheDelete2(key) {
      return getMapData2(this, key)["delete"](key);
    }
    __name(mapCacheDelete2, "mapCacheDelete");
    function mapCacheGet2(key) {
      return getMapData2(this, key).get(key);
    }
    __name(mapCacheGet2, "mapCacheGet");
    function mapCacheHas2(key) {
      return getMapData2(this, key).has(key);
    }
    __name(mapCacheHas2, "mapCacheHas");
    function mapCacheSet2(key, value) {
      getMapData2(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet2, "mapCacheSet");
    MapCache2.prototype.clear = mapCacheClear2;
    MapCache2.prototype["delete"] = mapCacheDelete2;
    MapCache2.prototype.get = mapCacheGet2;
    MapCache2.prototype.has = mapCacheHas2;
    MapCache2.prototype.set = mapCacheSet2;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache2();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED3);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf2(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf2, "assocIndexOf");
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE2) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    __name(baseUniq, "baseUniq");
    function getMapData2(map, key) {
      var data = map.__data__;
      return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData2, "getMapData");
    function getNative2(object, key) {
      var value = object[key];
      return isNative(value) ? value : void 0;
    }
    __name(getNative2, "getNative");
    function isKeyable2(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable2, "isKeyable");
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString4.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource2, "toSource");
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq2, "eq");
    function isFunction4(value) {
      var tag = isObject4(value) ? objectToString3.call(value) : "";
      return tag == funcTag3 || tag == genTag2;
    }
    __name(isFunction4, "isFunction");
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject4, "isObject");
    function isNative(value) {
      if (!isObject4(value)) {
        return false;
      }
      var pattern = isFunction4(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value));
    }
    __name(isNative, "isNative");
    module2.exports = baseUniq;
  }
});

// node_modules/lodash.uniqby/index.js
var require_lodash8 = __commonJS({
  "node_modules/lodash.uniqby/index.js"(exports2, module2) {
    init_esm();
    var baseIteratee = require_lodash4();
    var baseUniq = require_lodash7();
    function uniqBy(array, iteratee) {
      return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];
    }
    __name(uniqBy, "uniqBy");
    module2.exports = uniqBy;
  }
});

// node_modules/combine-errors/index.js
var require_combine_errors = __commonJS({
  "node_modules/combine-errors/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var Custom = require_custom_error_instance();
    var uniq = require_lodash8();
    var MultiError = Custom("MultiError");
    module2.exports = error;
    function error(errors) {
      if (!(this instanceof error)) return new error(errors);
      errors = Array.isArray(errors) ? errors : [errors];
      errors = uniq(errors, function(err) {
        return err.stack;
      });
      if (errors.length === 1) return errors[0];
      var multierror = new MultiError({
        message: errors.map(function(err) {
          return err.message;
        }).join("; "),
        errors: errors.reduce(function(errs, err) {
          return errs.concat(err.errors || err);
        }, [])
      });
      multierror.__defineGetter__("stack", function() {
        return errors.map(function(err) {
          return err.stack;
        }).join("\n\n");
      });
      multierror.__defineSetter__("stack", function(value) {
        return [value].concat(multierror.stack).join("\n\n");
      });
      return multierror;
    }
    __name(error, "error");
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    init_esm();
    var constants2 = __require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path2, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path2, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, /* @__PURE__ */ __name(function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            }, "CB"));
          }
          __name(rename, "rename");
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = /* @__PURE__ */ __name(function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            }, "callback");
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        __name(read, "read");
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path2, mode, callback) {
          fs2.open(
            path2,
            constants2.O_WRONLY | constants2.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path2, mode) {
          var fd = fs2.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      __name(patchLchmod, "patchLchmod");
      function patchLutimes(fs2) {
        if (constants2.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path2, at, mt, cb) {
            fs2.open(path2, constants2.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path2, at, mt) {
            var fd = fs2.openSync(path2, constants2.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      __name(patchLutimes, "patchLutimes");
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      __name(chmodFix, "chmodFix");
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      __name(chmodFixSync, "chmodFixSync");
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      __name(chownFix, "chownFix");
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      __name(chownFixSync, "chownFixSync");
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          __name(callback, "callback");
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      __name(statFix, "statFix");
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      __name(statFixSync, "statFixSync");
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
      __name(chownErOk, "chownErOk");
    }
    __name(patch, "patch");
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    init_esm();
    var Stream = __require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path2, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path2, options);
        Stream.call(this);
        var self2 = this;
        this.path = path2;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      __name(ReadStream, "ReadStream");
      function WriteStream(path2, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path2, options);
        Stream.call(this);
        this.path = path2;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
      __name(WriteStream, "WriteStream");
    }
    __name(legacy, "legacy");
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    init_esm();
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
    __name(clone, "clone");
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    init_esm();
    var fs = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop4() {
    }
    __name(noop4, "noop");
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: /* @__PURE__ */ __name(function() {
          return queue2;
        }, "get")
      });
    }
    __name(publishQueue, "publishQueue");
    var debug3 = noop4;
    if (util.debuglog)
      debug3 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug3 = /* @__PURE__ */ __name(function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      }, "debug");
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        __name(close, "close");
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        __name(closeSync, "closeSync");
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug3(fs[gracefulQueue]);
          __require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream2;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path2, options, cb);
        function go$readFile(path3, options2, cb2, startTime) {
          return fs$readFile(path3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
        __name(go$readFile, "go$readFile");
      }
      __name(readFile, "readFile");
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path2, data, options, cb);
        function go$writeFile(path3, data2, options2, cb2, startTime) {
          return fs$writeFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
        __name(go$writeFile, "go$writeFile");
      }
      __name(writeFile, "writeFile");
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path2, data, options, cb);
        function go$appendFile(path3, data2, options2, cb2, startTime) {
          return fs$appendFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
        __name(go$appendFile, "go$appendFile");
      }
      __name(appendFile, "appendFile");
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
        __name(go$copyFile, "go$copyFile");
      }
      __name(copyFile, "copyFile");
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? /* @__PURE__ */ __name(function go$readdir2(path3, options2, cb2, startTime) {
          return fs$readdir(path3, fs$readdirCallback(
            path3,
            options2,
            cb2,
            startTime
          ));
        }, "go$readdir") : /* @__PURE__ */ __name(function go$readdir2(path3, options2, cb2, startTime) {
          return fs$readdir(path3, options2, fs$readdirCallback(
            path3,
            options2,
            cb2,
            startTime
          ));
        }, "go$readdir");
        return go$readdir(path2, options, cb);
        function fs$readdirCallback(path3, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path3, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
        __name(fs$readdirCallback, "fs$readdirCallback");
      }
      __name(readdir, "readdir");
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: /* @__PURE__ */ __name(function() {
          return ReadStream;
        }, "get"),
        set: /* @__PURE__ */ __name(function(val) {
          ReadStream = val;
        }, "set"),
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: /* @__PURE__ */ __name(function() {
          return WriteStream;
        }, "get"),
        set: /* @__PURE__ */ __name(function(val) {
          WriteStream = val;
        }, "set"),
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: /* @__PURE__ */ __name(function() {
          return FileReadStream;
        }, "get"),
        set: /* @__PURE__ */ __name(function(val) {
          FileReadStream = val;
        }, "set"),
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: /* @__PURE__ */ __name(function() {
          return FileWriteStream;
        }, "get"),
        set: /* @__PURE__ */ __name(function(val) {
          FileWriteStream = val;
        }, "set"),
        enumerable: true,
        configurable: true
      });
      function ReadStream(path2, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      __name(ReadStream, "ReadStream");
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      __name(ReadStream$open, "ReadStream$open");
      function WriteStream(path2, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      __name(WriteStream, "WriteStream");
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      __name(WriteStream$open, "WriteStream$open");
      function createReadStream2(path2, options) {
        return new fs2.ReadStream(path2, options);
      }
      __name(createReadStream2, "createReadStream");
      function createWriteStream(path2, options) {
        return new fs2.WriteStream(path2, options);
      }
      __name(createWriteStream, "createWriteStream");
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path2, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path2, flags, mode, cb);
        function go$open(path3, flags2, mode2, cb2, startTime) {
          return fs$open(path3, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
        __name(go$open, "go$open");
      }
      __name(open, "open");
      return fs2;
    }
    __name(patch, "patch");
    function enqueue(elem) {
      debug3("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    __name(enqueue, "enqueue");
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i2 = 0; i2 < fs[gracefulQueue].length; ++i2) {
        if (fs[gracefulQueue][i2].length > 2) {
          fs[gracefulQueue][i2][3] = now;
          fs[gracefulQueue][i2][4] = now;
        }
      }
      retry();
    }
    __name(resetQueue, "resetQueue");
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug3("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug3("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug3("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
    __name(retry, "retry");
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    init_esm();
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer2 = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer2.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error = this._errors[i2];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    init_esm();
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i2 = 0; i2 < opts.retries; i2++) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      timeouts.sort(function(a2, b) {
        return a2 - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i2 = 0; i2 < methods.length; i2++) {
        var method = methods[i2];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    init_esm();
    module2.exports = require_retry();
  }
});

// node_modules/proper-lockfile/node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/proper-lockfile/node_modules/signal-exit/signals.js"(exports2, module2) {
    init_esm();
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/proper-lockfile/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/proper-lockfile/node_modules/signal-exit/index.js"(exports2, module2) {
    init_esm();
    var process4 = global.process;
    var processOk = /* @__PURE__ */ __name(function(process5) {
      return process5 && typeof process5 === "object" && typeof process5.removeListener === "function" && typeof process5.emit === "function" && typeof process5.reallyExit === "function" && typeof process5.listeners === "function" && typeof process5.kill === "function" && typeof process5.pid === "number" && typeof process5.on === "function";
    }, "processOk");
    if (!processOk(process4)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert3 = __require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process4.platform);
      EE = __require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process4.__signal_exit_emitter__) {
        emitter = process4.__signal_exit_emitter__;
      } else {
        emitter = process4.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert3.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = /* @__PURE__ */ __name(function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        }, "remove");
        emitter.on(ev, cb);
        return remove;
      };
      unload = /* @__PURE__ */ __name(function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process4.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process4.emit = originalProcessEmit;
        process4.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      }, "unload");
      module2.exports.unload = unload;
      emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      }, "emit");
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process4.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process4.kill(process4.pid, sig);
          }
        }, "listener");
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = /* @__PURE__ */ __name(function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process4.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process4.emit = processEmit;
        process4.reallyExit = processReallyExit;
      }, "load");
      module2.exports.load = load;
      originalProcessReallyExit = process4.reallyExit;
      processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process4.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process4.exitCode, null);
        emit("afterexit", process4.exitCode, null);
        originalProcessReallyExit.call(process4, process4.exitCode);
      }, "processReallyExit");
      originalProcessEmit = process4.emit;
      processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process4.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process4.exitCode, null);
          emit("afterexit", process4.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      }, "processEmit");
    }
    var assert3;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/proper-lockfile/lib/mtime-precision.js
var require_mtime_precision = __commonJS({
  "node_modules/proper-lockfile/lib/mtime-precision.js"(exports2, module2) {
    "use strict";
    init_esm();
    var cacheSymbol = Symbol();
    function probe(file, fs, callback) {
      const cachedPrecision = fs[cacheSymbol];
      if (cachedPrecision) {
        return fs.stat(file, (err, stat3) => {
          if (err) {
            return callback(err);
          }
          callback(null, stat3.mtime, cachedPrecision);
        });
      }
      const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
      fs.utimes(file, mtime, mtime, (err) => {
        if (err) {
          return callback(err);
        }
        fs.stat(file, (err2, stat3) => {
          if (err2) {
            return callback(err2);
          }
          const precision = stat3.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
          Object.defineProperty(fs, cacheSymbol, { value: precision });
          callback(null, stat3.mtime, precision);
        });
      });
    }
    __name(probe, "probe");
    function getMtime(precision) {
      let now = Date.now();
      if (precision === "s") {
        now = Math.ceil(now / 1e3) * 1e3;
      }
      return new Date(now);
    }
    __name(getMtime, "getMtime");
    module2.exports.probe = probe;
    module2.exports.getMtime = getMtime;
  }
});

// node_modules/proper-lockfile/lib/lockfile.js
var require_lockfile = __commonJS({
  "node_modules/proper-lockfile/lib/lockfile.js"(exports2, module2) {
    "use strict";
    init_esm();
    var path2 = __require("path");
    var fs = require_graceful_fs();
    var retry = require_retry2();
    var onExit = require_signal_exit();
    var mtimePrecision = require_mtime_precision();
    var locks = {};
    function getLockFile(file, options) {
      return options.lockfilePath || `${file}.lock`;
    }
    __name(getLockFile, "getLockFile");
    function resolveCanonicalPath(file, options, callback) {
      if (!options.realpath) {
        return callback(null, path2.resolve(file));
      }
      options.fs.realpath(file, callback);
    }
    __name(resolveCanonicalPath, "resolveCanonicalPath");
    function acquireLock(file, options, callback) {
      const lockfilePath = getLockFile(file, options);
      options.fs.mkdir(lockfilePath, (err) => {
        if (!err) {
          return mtimePrecision.probe(lockfilePath, options.fs, (err2, mtime, mtimePrecision2) => {
            if (err2) {
              options.fs.rmdir(lockfilePath, () => {
              });
              return callback(err2);
            }
            callback(null, mtime, mtimePrecision2);
          });
        }
        if (err.code !== "EEXIST") {
          return callback(err);
        }
        if (options.stale <= 0) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        options.fs.stat(lockfilePath, (err2, stat3) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return acquireLock(file, { ...options, stale: 0 }, callback);
            }
            return callback(err2);
          }
          if (!isLockStale(stat3, options)) {
            return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
          }
          removeLock(file, options, (err3) => {
            if (err3) {
              return callback(err3);
            }
            acquireLock(file, { ...options, stale: 0 }, callback);
          });
        });
      });
    }
    __name(acquireLock, "acquireLock");
    function isLockStale(stat3, options) {
      return stat3.mtime.getTime() < Date.now() - options.stale;
    }
    __name(isLockStale, "isLockStale");
    function removeLock(file, options, callback) {
      options.fs.rmdir(getLockFile(file, options), (err) => {
        if (err && err.code !== "ENOENT") {
          return callback(err);
        }
        callback();
      });
    }
    __name(removeLock, "removeLock");
    function updateLock(file, options) {
      const lock2 = locks[file];
      if (lock2.updateTimeout) {
        return;
      }
      lock2.updateDelay = lock2.updateDelay || options.update;
      lock2.updateTimeout = setTimeout(() => {
        lock2.updateTimeout = null;
        options.fs.stat(lock2.lockfilePath, (err, stat3) => {
          const isOverThreshold = lock2.lastUpdate + options.stale < Date.now();
          if (err) {
            if (err.code === "ENOENT" || isOverThreshold) {
              return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options);
          }
          const isMtimeOurs = lock2.mtime.getTime() === stat3.mtime.getTime();
          if (!isMtimeOurs) {
            return setLockAsCompromised(
              file,
              lock2,
              Object.assign(
                new Error("Unable to update lock within the stale threshold"),
                { code: "ECOMPROMISED" }
              )
            );
          }
          const mtime = mtimePrecision.getMtime(lock2.mtimePrecision);
          options.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
            const isOverThreshold2 = lock2.lastUpdate + options.stale < Date.now();
            if (lock2.released) {
              return;
            }
            if (err2) {
              if (err2.code === "ENOENT" || isOverThreshold2) {
                return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
              }
              lock2.updateDelay = 1e3;
              return updateLock(file, options);
            }
            lock2.mtime = mtime;
            lock2.lastUpdate = Date.now();
            lock2.updateDelay = null;
            updateLock(file, options);
          });
        });
      }, lock2.updateDelay);
      if (lock2.updateTimeout.unref) {
        lock2.updateTimeout.unref();
      }
    }
    __name(updateLock, "updateLock");
    function setLockAsCompromised(file, lock2, err) {
      lock2.released = true;
      if (lock2.updateTimeout) {
        clearTimeout(lock2.updateTimeout);
      }
      if (locks[file] === lock2) {
        delete locks[file];
      }
      lock2.options.onCompromised(err);
    }
    __name(setLockAsCompromised, "setLockAsCompromised");
    function lock(file, options, callback) {
      options = {
        stale: 1e4,
        update: null,
        realpath: true,
        retries: 0,
        fs,
        onCompromised: /* @__PURE__ */ __name((err) => {
          throw err;
        }, "onCompromised"),
        ...options
      };
      options.retries = options.retries || 0;
      options.retries = typeof options.retries === "number" ? { retries: options.retries } : options.retries;
      options.stale = Math.max(options.stale || 0, 2e3);
      options.update = options.update == null ? options.stale / 2 : options.update || 0;
      options.update = Math.max(Math.min(options.update, options.stale / 2), 1e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const operation = retry.operation(options.retries);
        operation.attempt(() => {
          acquireLock(file2, options, (err2, mtime, mtimePrecision2) => {
            if (operation.retry(err2)) {
              return;
            }
            if (err2) {
              return callback(operation.mainError());
            }
            const lock2 = locks[file2] = {
              lockfilePath: getLockFile(file2, options),
              mtime,
              mtimePrecision: mtimePrecision2,
              options,
              lastUpdate: Date.now()
            };
            updateLock(file2, options);
            callback(null, (releasedCallback) => {
              if (lock2.released) {
                return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
              }
              unlock(file2, { ...options, realpath: false }, releasedCallback);
            });
          });
        });
      });
    }
    __name(lock, "lock");
    function unlock(file, options, callback) {
      options = {
        fs,
        realpath: true,
        ...options
      };
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const lock2 = locks[file2];
        if (!lock2) {
          return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
        }
        lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
        lock2.released = true;
        delete locks[file2];
        removeLock(file2, options, callback);
      });
    }
    __name(unlock, "unlock");
    function check(file, options, callback) {
      options = {
        stale: 1e4,
        realpath: true,
        fs,
        ...options
      };
      options.stale = Math.max(options.stale || 0, 2e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        options.fs.stat(getLockFile(file2, options), (err2, stat3) => {
          if (err2) {
            return err2.code === "ENOENT" ? callback(null, false) : callback(err2);
          }
          return callback(null, !isLockStale(stat3, options));
        });
      });
    }
    __name(check, "check");
    function getLocks() {
      return locks;
    }
    __name(getLocks, "getLocks");
    onExit(() => {
      for (const file in locks) {
        const options = locks[file].options;
        try {
          options.fs.rmdirSync(getLockFile(file, options));
        } catch (e) {
        }
      }
    });
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.check = check;
    module2.exports.getLocks = getLocks;
  }
});

// node_modules/proper-lockfile/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/proper-lockfile/lib/adapter.js"(exports2, module2) {
    "use strict";
    init_esm();
    var fs = require_graceful_fs();
    function createSyncFs(fs2) {
      const methods = ["mkdir", "realpath", "stat", "rmdir", "utimes"];
      const newFs = { ...fs2 };
      methods.forEach((method) => {
        newFs[method] = (...args) => {
          const callback = args.pop();
          let ret;
          try {
            ret = fs2[`${method}Sync`](...args);
          } catch (err) {
            return callback(err);
          }
          callback(null, ret);
        };
      });
      return newFs;
    }
    __name(createSyncFs, "createSyncFs");
    function toPromise(method) {
      return (...args) => new Promise((resolve, reject) => {
        args.push((err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
        method(...args);
      });
    }
    __name(toPromise, "toPromise");
    function toSync(method) {
      return (...args) => {
        let err;
        let result;
        args.push((_err, _result) => {
          err = _err;
          result = _result;
        });
        method(...args);
        if (err) {
          throw err;
        }
        return result;
      };
    }
    __name(toSync, "toSync");
    function toSyncOptions(options) {
      options = { ...options };
      options.fs = createSyncFs(options.fs || fs);
      if (typeof options.retries === "number" && options.retries > 0 || options.retries && typeof options.retries.retries === "number" && options.retries.retries > 0) {
        throw Object.assign(new Error("Cannot use retries with the sync api"), { code: "ESYNC" });
      }
      return options;
    }
    __name(toSyncOptions, "toSyncOptions");
    module2.exports = {
      toPromise,
      toSync,
      toSyncOptions
    };
  }
});

// node_modules/proper-lockfile/index.js
var require_proper_lockfile = __commonJS({
  "node_modules/proper-lockfile/index.js"(exports2, module2) {
    "use strict";
    init_esm();
    var lockfile = require_lockfile();
    var { toPromise, toSync, toSyncOptions } = require_adapter();
    async function lock(file, options) {
      const release = await toPromise(lockfile.lock)(file, options);
      return toPromise(release);
    }
    __name(lock, "lock");
    function lockSync(file, options) {
      const release = toSync(lockfile.lock)(file, toSyncOptions(options));
      return toSync(release);
    }
    __name(lockSync, "lockSync");
    function unlock(file, options) {
      return toPromise(lockfile.unlock)(file, options);
    }
    __name(unlock, "unlock");
    function unlockSync(file, options) {
      return toSync(lockfile.unlock)(file, toSyncOptions(options));
    }
    __name(unlockSync, "unlockSync");
    function check(file, options) {
      return toPromise(lockfile.check)(file, options);
    }
    __name(check, "check");
    function checkSync(file, options) {
      return toSync(lockfile.check)(file, toSyncOptions(options));
    }
    __name(checkSync, "checkSync");
    module2.exports = lock;
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.lockSync = lockSync;
    module2.exports.unlockSync = unlockSync;
    module2.exports.check = check;
    module2.exports.checkSync = checkSync;
  }
});

// node_modules/tus-js-client/lib.es5/node/urlStorage.js
var require_urlStorage = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/urlStorage.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.canStoreURLs = exports2.FileUrlStorage = void 0;
    var _fs = __require("fs");
    var _combineErrors = _interopRequireDefault(require_combine_errors());
    var lockfile = _interopRequireWildcard(require_proper_lockfile());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(e2) {
        return e2 ? t : r;
      }, "_getRequireWildcardCache"))(e);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u2 in e) if ("default" !== u2 && {}.hasOwnProperty.call(e, u2)) {
        var i2 = a2 ? Object.getOwnPropertyDescriptor(e, u2) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e[u2];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var canStoreURLs = exports2.canStoreURLs = true;
    var FileUrlStorage = exports2.FileUrlStorage = /* @__PURE__ */ function() {
      function FileUrlStorage2(filePath) {
        _classCallCheck(this, FileUrlStorage2);
        this.path = filePath;
      }
      __name(FileUrlStorage2, "FileUrlStorage");
      return _createClass(FileUrlStorage2, [{
        key: "findAllUploads",
        value: /* @__PURE__ */ __name(function findAllUploads() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this._getItems("tus::", function(err, results) {
              if (err) reject(err);
              else resolve(results);
            });
          });
        }, "findAllUploads")
      }, {
        key: "findUploadsByFingerprint",
        value: /* @__PURE__ */ __name(function findUploadsByFingerprint(fingerprint) {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            _this2._getItems("tus::".concat(fingerprint), function(err, results) {
              if (err) reject(err);
              else resolve(results);
            });
          });
        }, "findUploadsByFingerprint")
      }, {
        key: "removeUpload",
        value: /* @__PURE__ */ __name(function removeUpload(urlStorageKey) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            _this3._removeItem(urlStorageKey, function(err) {
              if (err) reject(err);
              else resolve();
            });
          });
        }, "removeUpload")
      }, {
        key: "addUpload",
        value: /* @__PURE__ */ __name(function addUpload(fingerprint, upload) {
          var _this4 = this;
          var id = Math.round(Math.random() * 1e12);
          var key = "tus::".concat(fingerprint, "::").concat(id);
          return new Promise(function(resolve, reject) {
            _this4._setItem(key, upload, function(err) {
              if (err) reject(err);
              else resolve(key);
            });
          });
        }, "addUpload")
      }, {
        key: "_setItem",
        value: /* @__PURE__ */ __name(function _setItem(key, value, cb) {
          var _this5 = this;
          lockfile.lock(this.path, this._lockfileOptions()).then(function(release) {
            cb = _this5._releaseAndCb(release, cb);
            _this5._getData(function(err, data) {
              if (err) {
                cb(err);
                return;
              }
              data[key] = value;
              _this5._writeData(data, function(err2) {
                return cb(err2);
              });
            });
          })["catch"](cb);
        }, "_setItem")
      }, {
        key: "_getItems",
        value: /* @__PURE__ */ __name(function _getItems(prefix, cb) {
          this._getData(function(err, data) {
            if (err) {
              cb(err);
              return;
            }
            var results = Object.keys(data).filter(function(key) {
              return key.startsWith(prefix);
            }).map(function(key) {
              var obj = data[key];
              obj.urlStorageKey = key;
              return obj;
            });
            cb(null, results);
          });
        }, "_getItems")
      }, {
        key: "_removeItem",
        value: /* @__PURE__ */ __name(function _removeItem(key, cb) {
          var _this6 = this;
          lockfile.lock(this.path, this._lockfileOptions()).then(function(release) {
            cb = _this6._releaseAndCb(release, cb);
            _this6._getData(function(err, data) {
              if (err) {
                cb(err);
                return;
              }
              delete data[key];
              _this6._writeData(data, function(err2) {
                return cb(err2);
              });
            });
          })["catch"](cb);
        }, "_removeItem")
      }, {
        key: "_lockfileOptions",
        value: /* @__PURE__ */ __name(function _lockfileOptions() {
          return {
            realpath: false,
            retries: {
              retries: 5,
              minTimeout: 20
            }
          };
        }, "_lockfileOptions")
      }, {
        key: "_releaseAndCb",
        value: /* @__PURE__ */ __name(function _releaseAndCb(release, cb) {
          return function(err) {
            if (err) {
              release().then(function() {
                return cb(err);
              })["catch"](function(releaseErr) {
                return cb((0, _combineErrors.default)([err, releaseErr]));
              });
              return;
            }
            release().then(cb)["catch"](cb);
          };
        }, "_releaseAndCb")
      }, {
        key: "_writeData",
        value: /* @__PURE__ */ __name(function _writeData(data, cb) {
          var opts = {
            encoding: "utf8",
            mode: 432,
            flag: "w"
          };
          (0, _fs.writeFile)(this.path, JSON.stringify(data), opts, function(err) {
            return cb(err);
          });
        }, "_writeData")
      }, {
        key: "_getData",
        value: /* @__PURE__ */ __name(function _getData(cb) {
          (0, _fs.readFile)(this.path, "utf8", function(err, data) {
            if (err) {
              if (err.code === "ENOENT") cb(null, {});
              else cb(err);
              return;
            }
            try {
              data = !data.trim().length ? {} : JSON.parse(data);
            } catch (error) {
              cb(error);
              return;
            }
            cb(null, data);
          });
        }, "_getData")
      }]);
    }();
  }
});

// node_modules/tus-js-client/lib.es5/node/index.js
var require_node2 = __commonJS({
  "node_modules/tus-js-client/lib.es5/node/index.js"(exports2) {
    "use strict";
    init_esm();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DefaultHttpStack", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _httpStack.default;
      }, "get")
    });
    Object.defineProperty(exports2, "DetailedError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _error.default;
      }, "get")
    });
    Object.defineProperty(exports2, "FileUrlStorage", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _urlStorage.FileUrlStorage;
      }, "get")
    });
    Object.defineProperty(exports2, "StreamSource", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _StreamSource.default;
      }, "get")
    });
    exports2.Upload = void 0;
    Object.defineProperty(exports2, "canStoreURLs", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _urlStorage.canStoreURLs;
      }, "get")
    });
    exports2.defaultOptions = void 0;
    Object.defineProperty(exports2, "enableDebugLog", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _logger.enableDebugLog;
      }, "get")
    });
    exports2.isSupported = void 0;
    var _error = _interopRequireDefault(require_error());
    var _logger = require_logger();
    var _noopUrlStorage = _interopRequireDefault(require_noopUrlStorage());
    var _upload = _interopRequireDefault(require_upload());
    var _fileReader = _interopRequireDefault(require_fileReader());
    var _fileSignature = _interopRequireDefault(require_fileSignature());
    var _httpStack = _interopRequireDefault(require_httpStack());
    var _StreamSource = _interopRequireDefault(require_StreamSource());
    var _urlStorage = require_urlStorage();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    __name(_typeof, "_typeof");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _callSuper(t, o2, e) {
      return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
    }
    __name(_callSuper, "_callSuper");
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    __name(_possibleConstructorReturn, "_possibleConstructorReturn");
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    __name(_assertThisInitialized, "_assertThisInitialized");
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
        return !!t;
      }, "_isNativeReflectConstruct"))();
    }
    __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, "_getPrototypeOf");
      return _getPrototypeOf(o2);
    }
    __name(_getPrototypeOf, "_getPrototypeOf");
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    __name(_inherits, "_inherits");
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      }, "_setPrototypeOf");
      return _setPrototypeOf(o2, p);
    }
    __name(_setPrototypeOf, "_setPrototypeOf");
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e);
        r && (o2 = o2.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o2);
      }
      return t;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(t) {
      var i2 = _toPrimitive(t, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t, r || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    __name(_toPrimitive, "_toPrimitive");
    var defaultOptions2 = exports2.defaultOptions = _objectSpread(_objectSpread({}, _upload.default.defaultOptions), {}, {
      httpStack: new _httpStack.default(),
      fileReader: new _fileReader.default(),
      urlStorage: new _noopUrlStorage.default(),
      fingerprint: _fileSignature.default
    });
    var Upload2 = exports2.Upload = /* @__PURE__ */ function(_BaseUpload) {
      function Upload3() {
        var file = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Upload3);
        options = _objectSpread(_objectSpread({}, defaultOptions2), options);
        return _callSuper(this, Upload3, [file, options]);
      }
      __name(Upload3, "Upload");
      _inherits(Upload3, _BaseUpload);
      return _createClass(Upload3, null, [{
        key: "terminate",
        value: /* @__PURE__ */ __name(function terminate(url) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          options = _objectSpread(_objectSpread({}, defaultOptions2), options);
          return _upload.default.terminate(url, options);
        }, "terminate")
      }]);
    }(_upload.default);
    var isSupported = exports2.isSupported = true;
  }
});

// node_modules/transloadit/dist/Transloadit.js
init_esm();
import * as assert2 from "node:assert";
import { randomUUID } from "node:crypto";
import { constants, createReadStream } from "node:fs";
import { access, stat as stat2 } from "node:fs/promises";
import { basename as basename2 } from "node:path";
import { setTimeout as delay2 } from "node:timers/promises";

// node_modules/@transloadit/utils/dist/node.js
init_esm();
import { createHmac } from "node:crypto";
var signParamsSync = /* @__PURE__ */ __name((paramsString, authSecret, algorithm = "sha384") => {
  const signature = createHmac(algorithm, authSecret).update(Buffer.from(paramsString, "utf-8")).digest("hex");
  return `${algorithm}:${signature}`;
}, "signParamsSync");
var getSignedSmartCdnUrl = /* @__PURE__ */ __name((opts) => {
  if (opts.workspace == null || opts.workspace === "")
    throw new TypeError("workspace is required");
  if (opts.template == null || opts.template === "")
    throw new TypeError("template is required");
  if (opts.input == null)
    throw new TypeError("input is required");
  const workspaceSlug = encodeURIComponent(opts.workspace);
  const templateSlug = encodeURIComponent(opts.template);
  const inputField = encodeURIComponent(opts.input);
  const expiresAt = opts.expiresAt || Date.now() + 60 * 60 * 1e3;
  const queryParams = new URLSearchParams();
  for (const [key, value] of Object.entries(opts.urlParams || {})) {
    if (Array.isArray(value)) {
      for (const val of value) {
        queryParams.append(key, `${val}`);
      }
    } else {
      queryParams.append(key, `${value}`);
    }
  }
  queryParams.set("auth_key", opts.authKey);
  queryParams.set("exp", `${expiresAt}`);
  queryParams.sort();
  const stringToSign = `${workspaceSlug}/${templateSlug}/${inputField}?${queryParams}`;
  const signature = createHmac("sha256", opts.authSecret).update(stringToSign).digest("hex");
  queryParams.set("sig", `sha256:${signature}`);
  return `https://${workspaceSlug}.tlcdn.com/${templateSlug}/${inputField}?${queryParams}`;
}, "getSignedSmartCdnUrl");

// node_modules/transloadit/dist/Transloadit.js
var import_debug2 = __toESM(require_src(), 1);
var import_form_data = __toESM(require_form_data(), 1);

// node_modules/got/dist/source/index.js
init_esm();

// node_modules/got/dist/source/create.js
init_esm();
import { setTimeout as delay } from "node:timers/promises";

// node_modules/@sindresorhus/is/distribution/index.js
init_esm();

// node_modules/@sindresorhus/is/distribution/utilities.js
init_esm();
function keysOf(value) {
  return Object.keys(value);
}
__name(keysOf, "keysOf");

// node_modules/@sindresorhus/is/distribution/index.js
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function isTypedArrayName(name) {
  return typedArrayTypeNames.includes(name);
}
__name(isTypedArrayName, "isTypedArrayName");
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
function isObjectTypeName(name) {
  return objectTypeNames.includes(name);
}
__name(isObjectTypeName, "isObjectTypeName");
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
function isPrimitiveTypeName(name) {
  return primitiveTypeNames.includes(name);
}
__name(isPrimitiveTypeName, "isPrimitiveTypeName");
var assertionTypeDescriptions = [
  "positive number",
  "negative number",
  "Class",
  "string with a number",
  "null or undefined",
  "Iterable",
  "AsyncIterable",
  "native Promise",
  "EnumCase",
  "string with a URL",
  "truthy",
  "falsy",
  "primitive",
  "integer",
  "plain object",
  "TypedArray",
  "array-like",
  "tuple-like",
  "Node.js Stream",
  "infinite number",
  "empty array",
  "non-empty array",
  "empty string",
  "empty string or whitespace",
  "non-empty string",
  "non-empty string and not whitespace",
  "empty object",
  "non-empty object",
  "empty set",
  "non-empty set",
  "empty map",
  "non-empty map",
  "PropertyKey",
  "even integer",
  "odd integer",
  "T",
  "in range",
  "predicate returns truthy for any value",
  "predicate returns truthy for all values",
  "valid Date",
  "valid length",
  "whitespace string",
  ...objectTypeNames,
  ...primitiveTypeNames
];
var getObjectType = /* @__PURE__ */ __name((value) => {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && isHtmlElement(value)) {
    return "HTMLElement";
  }
  if (isObjectTypeName(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}, "getObjectType");
function detect(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "undefined": {
      return "undefined";
    }
    case "string": {
      return "string";
    }
    case "number": {
      return Number.isNaN(value) ? "NaN" : "number";
    }
    case "boolean": {
      return "boolean";
    }
    case "function": {
      return "Function";
    }
    case "bigint": {
      return "bigint";
    }
    case "symbol": {
      return "symbol";
    }
    default:
  }
  if (isObservable(value)) {
    return "Observable";
  }
  if (isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const tagType = getObjectType(value);
  if (tagType && tagType !== "Object") {
    return tagType;
  }
  if (hasPromiseApi(value)) {
    return "Promise";
  }
  if (value instanceof String || value instanceof Boolean || value instanceof Number) {
    throw new TypeError("Please don't use object wrappers for primitive types");
  }
  return "Object";
}
__name(detect, "detect");
function hasPromiseApi(value) {
  return isFunction(value?.then) && isFunction(value?.catch);
}
__name(hasPromiseApi, "hasPromiseApi");
var is = Object.assign(detect, {
  all: isAll,
  any: isAny,
  array: isArray,
  arrayBuffer: isArrayBuffer,
  arrayLike: isArrayLike,
  asyncFunction: isAsyncFunction,
  asyncGenerator: isAsyncGenerator,
  asyncGeneratorFunction: isAsyncGeneratorFunction,
  asyncIterable: isAsyncIterable,
  bigint: isBigint,
  bigInt64Array: isBigInt64Array,
  bigUint64Array: isBigUint64Array,
  blob: isBlob,
  boolean: isBoolean,
  boundFunction: isBoundFunction,
  buffer: isBuffer,
  class: isClass,
  dataView: isDataView,
  date: isDate,
  detect,
  directInstanceOf: isDirectInstanceOf,
  emptyArray: isEmptyArray,
  emptyMap: isEmptyMap,
  emptyObject: isEmptyObject,
  emptySet: isEmptySet,
  emptyString: isEmptyString,
  emptyStringOrWhitespace: isEmptyStringOrWhitespace,
  enumCase: isEnumCase,
  error: isError,
  evenInteger: isEvenInteger,
  falsy: isFalsy,
  float32Array: isFloat32Array,
  float64Array: isFloat64Array,
  formData: isFormData,
  function: isFunction,
  generator: isGenerator,
  generatorFunction: isGeneratorFunction,
  htmlElement: isHtmlElement,
  infinite: isInfinite,
  inRange: isInRange,
  int16Array: isInt16Array,
  int32Array: isInt32Array,
  int8Array: isInt8Array,
  integer: isInteger,
  iterable: isIterable,
  map: isMap,
  nan: isNan,
  nativePromise: isNativePromise,
  negativeNumber: isNegativeNumber,
  nodeStream: isNodeStream,
  nonEmptyArray: isNonEmptyArray,
  nonEmptyMap: isNonEmptyMap,
  nonEmptyObject: isNonEmptyObject,
  nonEmptySet: isNonEmptySet,
  nonEmptyString: isNonEmptyString,
  nonEmptyStringAndNotWhitespace: isNonEmptyStringAndNotWhitespace,
  null: isNull,
  nullOrUndefined: isNullOrUndefined,
  number: isNumber,
  numericString: isNumericString,
  object: isObject,
  observable: isObservable,
  oddInteger: isOddInteger,
  plainObject: isPlainObject,
  positiveNumber: isPositiveNumber,
  primitive: isPrimitive,
  promise: isPromise,
  propertyKey: isPropertyKey,
  regExp: isRegExp,
  safeInteger: isSafeInteger,
  set: isSet,
  sharedArrayBuffer: isSharedArrayBuffer,
  string: isString,
  symbol: isSymbol,
  truthy: isTruthy,
  tupleLike: isTupleLike,
  typedArray: isTypedArray,
  uint16Array: isUint16Array,
  uint32Array: isUint32Array,
  uint8Array: isUint8Array,
  uint8ClampedArray: isUint8ClampedArray,
  undefined: isUndefined,
  urlInstance: isUrlInstance,
  urlSearchParams: isUrlSearchParams,
  urlString: isUrlString,
  optional: isOptional,
  validDate: isValidDate,
  validLength: isValidLength,
  weakMap: isWeakMap,
  weakRef: isWeakRef,
  weakSet: isWeakSet,
  whitespaceString: isWhitespaceString
});
function isAbsoluteModule2(remainder) {
  return (value) => isInteger(value) && Math.abs(value % 2) === remainder;
}
__name(isAbsoluteModule2, "isAbsoluteModule2");
function validatePredicateArray(predicateArray, allowEmpty) {
  if (predicateArray.length === 0) {
    if (allowEmpty) {
    } else {
      throw new TypeError("Invalid predicate array");
    }
    return;
  }
  for (const predicate of predicateArray) {
    if (!isFunction(predicate)) {
      throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
  }
}
__name(validatePredicateArray, "validatePredicateArray");
function isAll(predicate, ...values) {
  if (Array.isArray(predicate)) {
    const predicateArray = predicate;
    validatePredicateArray(predicateArray, values.length === 0);
    const combinedPredicate = /* @__PURE__ */ __name((value) => predicateArray.every((singlePredicate) => singlePredicate(value)), "combinedPredicate");
    if (values.length === 0) {
      return combinedPredicate;
    }
    return predicateOnArray(Array.prototype.every, combinedPredicate, values);
  }
  return predicateOnArray(Array.prototype.every, predicate, values);
}
__name(isAll, "isAll");
function isAny(predicate, ...values) {
  if (Array.isArray(predicate)) {
    const predicateArray = predicate;
    validatePredicateArray(predicateArray, values.length === 0);
    const combinedPredicate = /* @__PURE__ */ __name((value) => predicateArray.some((singlePredicate) => singlePredicate(value)), "combinedPredicate");
    if (values.length === 0) {
      return combinedPredicate;
    }
    return predicateOnArray(Array.prototype.some, combinedPredicate, values);
  }
  return predicateOnArray(Array.prototype.some, predicate, values);
}
__name(isAny, "isAny");
function isOptional(value, predicate) {
  return isUndefined(value) || predicate(value);
}
__name(isOptional, "isOptional");
function isArray(value, assertion) {
  if (!Array.isArray(value)) {
    return false;
  }
  if (!isFunction(assertion)) {
    return true;
  }
  return value.every((element) => assertion(element));
}
__name(isArray, "isArray");
function isArrayBuffer(value) {
  return getObjectType(value) === "ArrayBuffer";
}
__name(isArrayBuffer, "isArrayBuffer");
function isArrayLike(value) {
  return !isNullOrUndefined(value) && !isFunction(value) && isValidLength(value.length);
}
__name(isArrayLike, "isArrayLike");
function isAsyncFunction(value) {
  return getObjectType(value) === "AsyncFunction";
}
__name(isAsyncFunction, "isAsyncFunction");
function isAsyncGenerator(value) {
  return isAsyncIterable(value) && isFunction(value.next) && isFunction(value.throw);
}
__name(isAsyncGenerator, "isAsyncGenerator");
function isAsyncGeneratorFunction(value) {
  return getObjectType(value) === "AsyncGeneratorFunction";
}
__name(isAsyncGeneratorFunction, "isAsyncGeneratorFunction");
function isAsyncIterable(value) {
  return isFunction(value?.[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");
function isBigint(value) {
  return typeof value === "bigint";
}
__name(isBigint, "isBigint");
function isBigInt64Array(value) {
  return getObjectType(value) === "BigInt64Array";
}
__name(isBigInt64Array, "isBigInt64Array");
function isBigUint64Array(value) {
  return getObjectType(value) === "BigUint64Array";
}
__name(isBigUint64Array, "isBigUint64Array");
function isBlob(value) {
  return getObjectType(value) === "Blob";
}
__name(isBlob, "isBlob");
function isBoolean(value) {
  return value === true || value === false;
}
__name(isBoolean, "isBoolean");
function isBoundFunction(value) {
  return isFunction(value) && !Object.hasOwn(value, "prototype");
}
__name(isBoundFunction, "isBoundFunction");
function isBuffer(value) {
  return value?.constructor?.isBuffer?.(value) ?? false;
}
__name(isBuffer, "isBuffer");
function isClass(value) {
  return isFunction(value) && /^class(\s+|{)/.test(value.toString());
}
__name(isClass, "isClass");
function isDataView(value) {
  return getObjectType(value) === "DataView";
}
__name(isDataView, "isDataView");
function isDate(value) {
  return getObjectType(value) === "Date";
}
__name(isDate, "isDate");
function isDirectInstanceOf(instance, class_) {
  if (instance === void 0 || instance === null) {
    return false;
  }
  return Object.getPrototypeOf(instance) === class_.prototype;
}
__name(isDirectInstanceOf, "isDirectInstanceOf");
function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
__name(isEmptyArray, "isEmptyArray");
function isEmptyMap(value) {
  return isMap(value) && value.size === 0;
}
__name(isEmptyMap, "isEmptyMap");
function isEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
__name(isEmptyObject, "isEmptyObject");
function isEmptySet(value) {
  return isSet(value) && value.size === 0;
}
__name(isEmptySet, "isEmptySet");
function isEmptyString(value) {
  return isString(value) && value.length === 0;
}
__name(isEmptyString, "isEmptyString");
function isEmptyStringOrWhitespace(value) {
  return isEmptyString(value) || isWhitespaceString(value);
}
__name(isEmptyStringOrWhitespace, "isEmptyStringOrWhitespace");
function isEnumCase(value, targetEnum) {
  return Object.values(targetEnum).includes(value);
}
__name(isEnumCase, "isEnumCase");
function isError(value) {
  return getObjectType(value) === "Error";
}
__name(isError, "isError");
function isEvenInteger(value) {
  return isAbsoluteModule2(0)(value);
}
__name(isEvenInteger, "isEvenInteger");
function isFalsy(value) {
  return !value;
}
__name(isFalsy, "isFalsy");
function isFloat32Array(value) {
  return getObjectType(value) === "Float32Array";
}
__name(isFloat32Array, "isFloat32Array");
function isFloat64Array(value) {
  return getObjectType(value) === "Float64Array";
}
__name(isFloat64Array, "isFloat64Array");
function isFormData(value) {
  return getObjectType(value) === "FormData";
}
__name(isFormData, "isFormData");
function isFunction(value) {
  return typeof value === "function";
}
__name(isFunction, "isFunction");
function isGenerator(value) {
  return isIterable(value) && isFunction(value?.next) && isFunction(value?.throw);
}
__name(isGenerator, "isGenerator");
function isGeneratorFunction(value) {
  return getObjectType(value) === "GeneratorFunction";
}
__name(isGeneratorFunction, "isGeneratorFunction");
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
function isHtmlElement(value) {
  return isObject(value) && value.nodeType === NODE_TYPE_ELEMENT && isString(value.nodeName) && !isPlainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
}
__name(isHtmlElement, "isHtmlElement");
function isInfinite(value) {
  return value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
}
__name(isInfinite, "isInfinite");
function isInRange(value, range) {
  if (isNumber(range)) {
    return value >= Math.min(0, range) && value <= Math.max(range, 0);
  }
  if (isArray(range) && range.length === 2) {
    return value >= Math.min(...range) && value <= Math.max(...range);
  }
  throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
}
__name(isInRange, "isInRange");
function isInt16Array(value) {
  return getObjectType(value) === "Int16Array";
}
__name(isInt16Array, "isInt16Array");
function isInt32Array(value) {
  return getObjectType(value) === "Int32Array";
}
__name(isInt32Array, "isInt32Array");
function isInt8Array(value) {
  return getObjectType(value) === "Int8Array";
}
__name(isInt8Array, "isInt8Array");
function isInteger(value) {
  return Number.isInteger(value);
}
__name(isInteger, "isInteger");
function isIterable(value) {
  return isFunction(value?.[Symbol.iterator]);
}
__name(isIterable, "isIterable");
function isMap(value) {
  return getObjectType(value) === "Map";
}
__name(isMap, "isMap");
function isNan(value) {
  return Number.isNaN(value);
}
__name(isNan, "isNan");
function isNativePromise(value) {
  return getObjectType(value) === "Promise";
}
__name(isNativePromise, "isNativePromise");
function isNegativeNumber(value) {
  return isNumber(value) && value < 0;
}
__name(isNegativeNumber, "isNegativeNumber");
function isNodeStream(value) {
  return isObject(value) && isFunction(value.pipe) && !isObservable(value);
}
__name(isNodeStream, "isNodeStream");
function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
__name(isNonEmptyArray, "isNonEmptyArray");
function isNonEmptyMap(value) {
  return isMap(value) && value.size > 0;
}
__name(isNonEmptyMap, "isNonEmptyMap");
function isNonEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length > 0;
}
__name(isNonEmptyObject, "isNonEmptyObject");
function isNonEmptySet(value) {
  return isSet(value) && value.size > 0;
}
__name(isNonEmptySet, "isNonEmptySet");
function isNonEmptyString(value) {
  return isString(value) && value.length > 0;
}
__name(isNonEmptyString, "isNonEmptyString");
function isNonEmptyStringAndNotWhitespace(value) {
  return isString(value) && !isEmptyStringOrWhitespace(value);
}
__name(isNonEmptyStringAndNotWhitespace, "isNonEmptyStringAndNotWhitespace");
function isNull(value) {
  return value === null;
}
__name(isNull, "isNull");
function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
__name(isNullOrUndefined, "isNullOrUndefined");
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
__name(isNumber, "isNumber");
function isNumericString(value) {
  return isString(value) && !isEmptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
}
__name(isNumericString, "isNumericString");
function isObject(value) {
  return !isNull(value) && (typeof value === "object" || isFunction(value));
}
__name(isObject, "isObject");
function isObservable(value) {
  if (!value) {
    return false;
  }
  if (Symbol.observable !== void 0 && value === value[Symbol.observable]?.()) {
    return true;
  }
  if (value === value["@@observable"]?.()) {
    return true;
  }
  return false;
}
__name(isObservable, "isObservable");
function isOddInteger(value) {
  return isAbsoluteModule2(1)(value);
}
__name(isOddInteger, "isOddInteger");
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
__name(isPlainObject, "isPlainObject");
function isPositiveNumber(value) {
  return isNumber(value) && value > 0;
}
__name(isPositiveNumber, "isPositiveNumber");
function isPrimitive(value) {
  return isNull(value) || isPrimitiveTypeName(typeof value);
}
__name(isPrimitive, "isPrimitive");
function isPromise(value) {
  return isNativePromise(value) || hasPromiseApi(value);
}
__name(isPromise, "isPromise");
function isPropertyKey(value) {
  return isAny([isString, isNumber, isSymbol], value);
}
__name(isPropertyKey, "isPropertyKey");
function isRegExp(value) {
  return getObjectType(value) === "RegExp";
}
__name(isRegExp, "isRegExp");
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
__name(isSafeInteger, "isSafeInteger");
function isSet(value) {
  return getObjectType(value) === "Set";
}
__name(isSet, "isSet");
function isSharedArrayBuffer(value) {
  return getObjectType(value) === "SharedArrayBuffer";
}
__name(isSharedArrayBuffer, "isSharedArrayBuffer");
function isString(value) {
  return typeof value === "string";
}
__name(isString, "isString");
function isSymbol(value) {
  return typeof value === "symbol";
}
__name(isSymbol, "isSymbol");
function isTruthy(value) {
  return Boolean(value);
}
__name(isTruthy, "isTruthy");
function isTupleLike(value, guards) {
  if (isArray(guards) && isArray(value) && guards.length === value.length) {
    return guards.every((guard, index) => guard(value[index]));
  }
  return false;
}
__name(isTupleLike, "isTupleLike");
function isTypedArray(value) {
  return isTypedArrayName(getObjectType(value));
}
__name(isTypedArray, "isTypedArray");
function isUint16Array(value) {
  return getObjectType(value) === "Uint16Array";
}
__name(isUint16Array, "isUint16Array");
function isUint32Array(value) {
  return getObjectType(value) === "Uint32Array";
}
__name(isUint32Array, "isUint32Array");
function isUint8Array(value) {
  return getObjectType(value) === "Uint8Array";
}
__name(isUint8Array, "isUint8Array");
function isUint8ClampedArray(value) {
  return getObjectType(value) === "Uint8ClampedArray";
}
__name(isUint8ClampedArray, "isUint8ClampedArray");
function isUndefined(value) {
  return value === void 0;
}
__name(isUndefined, "isUndefined");
function isUrlInstance(value) {
  return getObjectType(value) === "URL";
}
__name(isUrlInstance, "isUrlInstance");
function isUrlSearchParams(value) {
  return getObjectType(value) === "URLSearchParams";
}
__name(isUrlSearchParams, "isUrlSearchParams");
function isUrlString(value) {
  if (!isString(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
}
__name(isUrlString, "isUrlString");
function isValidDate(value) {
  return isDate(value) && !isNan(Number(value));
}
__name(isValidDate, "isValidDate");
function isValidLength(value) {
  return isSafeInteger(value) && value >= 0;
}
__name(isValidLength, "isValidLength");
function isWeakMap(value) {
  return getObjectType(value) === "WeakMap";
}
__name(isWeakMap, "isWeakMap");
function isWeakRef(value) {
  return getObjectType(value) === "WeakRef";
}
__name(isWeakRef, "isWeakRef");
function isWeakSet(value) {
  return getObjectType(value) === "WeakSet";
}
__name(isWeakSet, "isWeakSet");
function isWhitespaceString(value) {
  return isString(value) && /^\s+$/.test(value);
}
__name(isWhitespaceString, "isWhitespaceString");
function predicateOnArray(method, predicate, values) {
  if (!isFunction(predicate)) {
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  }
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  return method.call(values, predicate);
}
__name(predicateOnArray, "predicateOnArray");
function typeErrorMessage(description, value) {
  return `Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`;
}
__name(typeErrorMessage, "typeErrorMessage");
function unique(values) {
  return Array.from(new Set(values));
}
__name(unique, "unique");
var andFormatter = new Intl.ListFormat("en", { style: "long", type: "conjunction" });
var orFormatter = new Intl.ListFormat("en", { style: "long", type: "disjunction" });
function typeErrorMessageMultipleValues(expectedType, values) {
  const uniqueExpectedTypes = unique((isArray(expectedType) ? expectedType : [expectedType]).map((value) => `\`${value}\``));
  const uniqueValueTypes = unique(values.map((value) => `\`${is(value)}\``));
  return `Expected values which are ${orFormatter.format(uniqueExpectedTypes)}. Received values of type${uniqueValueTypes.length > 1 ? "s" : ""} ${andFormatter.format(uniqueValueTypes)}.`;
}
__name(typeErrorMessageMultipleValues, "typeErrorMessageMultipleValues");
var assert = {
  all: assertAll,
  any: assertAny,
  optional: assertOptional,
  array: assertArray,
  arrayBuffer: assertArrayBuffer,
  arrayLike: assertArrayLike,
  asyncFunction: assertAsyncFunction,
  asyncGenerator: assertAsyncGenerator,
  asyncGeneratorFunction: assertAsyncGeneratorFunction,
  asyncIterable: assertAsyncIterable,
  bigint: assertBigint,
  bigInt64Array: assertBigInt64Array,
  bigUint64Array: assertBigUint64Array,
  blob: assertBlob,
  boolean: assertBoolean,
  boundFunction: assertBoundFunction,
  buffer: assertBuffer,
  class: assertClass,
  dataView: assertDataView,
  date: assertDate,
  directInstanceOf: assertDirectInstanceOf,
  emptyArray: assertEmptyArray,
  emptyMap: assertEmptyMap,
  emptyObject: assertEmptyObject,
  emptySet: assertEmptySet,
  emptyString: assertEmptyString,
  emptyStringOrWhitespace: assertEmptyStringOrWhitespace,
  enumCase: assertEnumCase,
  error: assertError,
  evenInteger: assertEvenInteger,
  falsy: assertFalsy,
  float32Array: assertFloat32Array,
  float64Array: assertFloat64Array,
  formData: assertFormData,
  function: assertFunction,
  generator: assertGenerator,
  generatorFunction: assertGeneratorFunction,
  htmlElement: assertHtmlElement,
  infinite: assertInfinite,
  inRange: assertInRange,
  int16Array: assertInt16Array,
  int32Array: assertInt32Array,
  int8Array: assertInt8Array,
  integer: assertInteger,
  iterable: assertIterable,
  map: assertMap,
  nan: assertNan,
  nativePromise: assertNativePromise,
  negativeNumber: assertNegativeNumber,
  nodeStream: assertNodeStream,
  nonEmptyArray: assertNonEmptyArray,
  nonEmptyMap: assertNonEmptyMap,
  nonEmptyObject: assertNonEmptyObject,
  nonEmptySet: assertNonEmptySet,
  nonEmptyString: assertNonEmptyString,
  nonEmptyStringAndNotWhitespace: assertNonEmptyStringAndNotWhitespace,
  null: assertNull,
  nullOrUndefined: assertNullOrUndefined,
  number: assertNumber,
  numericString: assertNumericString,
  object: assertObject,
  observable: assertObservable,
  oddInteger: assertOddInteger,
  plainObject: assertPlainObject,
  positiveNumber: assertPositiveNumber,
  primitive: assertPrimitive,
  promise: assertPromise,
  propertyKey: assertPropertyKey,
  regExp: assertRegExp,
  safeInteger: assertSafeInteger,
  set: assertSet,
  sharedArrayBuffer: assertSharedArrayBuffer,
  string: assertString,
  symbol: assertSymbol,
  truthy: assertTruthy,
  tupleLike: assertTupleLike,
  typedArray: assertTypedArray,
  uint16Array: assertUint16Array,
  uint32Array: assertUint32Array,
  uint8Array: assertUint8Array,
  uint8ClampedArray: assertUint8ClampedArray,
  undefined: assertUndefined,
  urlInstance: assertUrlInstance,
  urlSearchParams: assertUrlSearchParams,
  urlString: assertUrlString,
  validDate: assertValidDate,
  validLength: assertValidLength,
  weakMap: assertWeakMap,
  weakRef: assertWeakRef,
  weakSet: assertWeakSet,
  whitespaceString: assertWhitespaceString
};
var methodTypeMap = {
  isArray: "Array",
  isArrayBuffer: "ArrayBuffer",
  isArrayLike: "array-like",
  isAsyncFunction: "AsyncFunction",
  isAsyncGenerator: "AsyncGenerator",
  isAsyncGeneratorFunction: "AsyncGeneratorFunction",
  isAsyncIterable: "AsyncIterable",
  isBigint: "bigint",
  isBigInt64Array: "BigInt64Array",
  isBigUint64Array: "BigUint64Array",
  isBlob: "Blob",
  isBoolean: "boolean",
  isBoundFunction: "Function",
  isBuffer: "Buffer",
  isClass: "Class",
  isDataView: "DataView",
  isDate: "Date",
  isDirectInstanceOf: "T",
  isEmptyArray: "empty array",
  isEmptyMap: "empty map",
  isEmptyObject: "empty object",
  isEmptySet: "empty set",
  isEmptyString: "empty string",
  isEmptyStringOrWhitespace: "empty string or whitespace",
  isEnumCase: "EnumCase",
  isError: "Error",
  isEvenInteger: "even integer",
  isFalsy: "falsy",
  isFloat32Array: "Float32Array",
  isFloat64Array: "Float64Array",
  isFormData: "FormData",
  isFunction: "Function",
  isGenerator: "Generator",
  isGeneratorFunction: "GeneratorFunction",
  isHtmlElement: "HTMLElement",
  isInfinite: "infinite number",
  isInRange: "in range",
  isInt16Array: "Int16Array",
  isInt32Array: "Int32Array",
  isInt8Array: "Int8Array",
  isInteger: "integer",
  isIterable: "Iterable",
  isMap: "Map",
  isNan: "NaN",
  isNativePromise: "native Promise",
  isNegativeNumber: "negative number",
  isNodeStream: "Node.js Stream",
  isNonEmptyArray: "non-empty array",
  isNonEmptyMap: "non-empty map",
  isNonEmptyObject: "non-empty object",
  isNonEmptySet: "non-empty set",
  isNonEmptyString: "non-empty string",
  isNonEmptyStringAndNotWhitespace: "non-empty string and not whitespace",
  isNull: "null",
  isNullOrUndefined: "null or undefined",
  isNumber: "number",
  isNumericString: "string with a number",
  isObject: "Object",
  isObservable: "Observable",
  isOddInteger: "odd integer",
  isPlainObject: "plain object",
  isPositiveNumber: "positive number",
  isPrimitive: "primitive",
  isPromise: "Promise",
  isPropertyKey: "PropertyKey",
  isRegExp: "RegExp",
  isSafeInteger: "integer",
  isSet: "Set",
  isSharedArrayBuffer: "SharedArrayBuffer",
  isString: "string",
  isSymbol: "symbol",
  isTruthy: "truthy",
  isTupleLike: "tuple-like",
  isTypedArray: "TypedArray",
  isUint16Array: "Uint16Array",
  isUint32Array: "Uint32Array",
  isUint8Array: "Uint8Array",
  isUint8ClampedArray: "Uint8ClampedArray",
  isUndefined: "undefined",
  isUrlInstance: "URL",
  isUrlSearchParams: "URLSearchParams",
  isUrlString: "string with a URL",
  isValidDate: "valid Date",
  isValidLength: "valid length",
  isWeakMap: "WeakMap",
  isWeakRef: "WeakRef",
  isWeakSet: "WeakSet",
  isWhitespaceString: "whitespace string"
};
var isMethodNames = keysOf(methodTypeMap);
function isIsMethodName(value) {
  return isMethodNames.includes(value);
}
__name(isIsMethodName, "isIsMethodName");
function assertAll(predicate, ...values) {
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  if (!isAll(predicate, ...values)) {
    const predicateFunction = predicate;
    const expectedType = !Array.isArray(predicate) && isIsMethodName(predicateFunction.name) ? methodTypeMap[predicateFunction.name] : "predicate returns truthy for all values";
    throw new TypeError(typeErrorMessageMultipleValues(expectedType, values));
  }
}
__name(assertAll, "assertAll");
function assertAny(predicate, ...values) {
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  if (!isAny(predicate, ...values)) {
    const predicates = Array.isArray(predicate) ? predicate : [predicate];
    const expectedTypes = predicates.map((singlePredicate) => isIsMethodName(singlePredicate.name) ? methodTypeMap[singlePredicate.name] : "predicate returns truthy for any value");
    throw new TypeError(typeErrorMessageMultipleValues(expectedTypes, values));
  }
}
__name(assertAny, "assertAny");
function assertOptional(value, assertion, message) {
  if (!isUndefined(value)) {
    assertion(value, message);
  }
}
__name(assertOptional, "assertOptional");
function assertArray(value, assertion, message) {
  if (!isArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("Array", value));
  }
  if (assertion) {
    for (const element of value) {
      assertion(element, message);
    }
  }
}
__name(assertArray, "assertArray");
function assertArrayBuffer(value, message) {
  if (!isArrayBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("ArrayBuffer", value));
  }
}
__name(assertArrayBuffer, "assertArrayBuffer");
function assertArrayLike(value, message) {
  if (!isArrayLike(value)) {
    throw new TypeError(message ?? typeErrorMessage("array-like", value));
  }
}
__name(assertArrayLike, "assertArrayLike");
function assertAsyncFunction(value, message) {
  if (!isAsyncFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncFunction", value));
  }
}
__name(assertAsyncFunction, "assertAsyncFunction");
function assertAsyncGenerator(value, message) {
  if (!isAsyncGenerator(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncGenerator", value));
  }
}
__name(assertAsyncGenerator, "assertAsyncGenerator");
function assertAsyncGeneratorFunction(value, message) {
  if (!isAsyncGeneratorFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncGeneratorFunction", value));
  }
}
__name(assertAsyncGeneratorFunction, "assertAsyncGeneratorFunction");
function assertAsyncIterable(value, message) {
  if (!isAsyncIterable(value)) {
    throw new TypeError(message ?? typeErrorMessage("AsyncIterable", value));
  }
}
__name(assertAsyncIterable, "assertAsyncIterable");
function assertBigint(value, message) {
  if (!isBigint(value)) {
    throw new TypeError(message ?? typeErrorMessage("bigint", value));
  }
}
__name(assertBigint, "assertBigint");
function assertBigInt64Array(value, message) {
  if (!isBigInt64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("BigInt64Array", value));
  }
}
__name(assertBigInt64Array, "assertBigInt64Array");
function assertBigUint64Array(value, message) {
  if (!isBigUint64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("BigUint64Array", value));
  }
}
__name(assertBigUint64Array, "assertBigUint64Array");
function assertBlob(value, message) {
  if (!isBlob(value)) {
    throw new TypeError(message ?? typeErrorMessage("Blob", value));
  }
}
__name(assertBlob, "assertBlob");
function assertBoolean(value, message) {
  if (!isBoolean(value)) {
    throw new TypeError(message ?? typeErrorMessage("boolean", value));
  }
}
__name(assertBoolean, "assertBoolean");
function assertBoundFunction(value, message) {
  if (!isBoundFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("Function", value));
  }
}
__name(assertBoundFunction, "assertBoundFunction");
function assertBuffer(value, message) {
  if (!isBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("Buffer", value));
  }
}
__name(assertBuffer, "assertBuffer");
function assertClass(value, message) {
  if (!isClass(value)) {
    throw new TypeError(message ?? typeErrorMessage("Class", value));
  }
}
__name(assertClass, "assertClass");
function assertDataView(value, message) {
  if (!isDataView(value)) {
    throw new TypeError(message ?? typeErrorMessage("DataView", value));
  }
}
__name(assertDataView, "assertDataView");
function assertDate(value, message) {
  if (!isDate(value)) {
    throw new TypeError(message ?? typeErrorMessage("Date", value));
  }
}
__name(assertDate, "assertDate");
function assertDirectInstanceOf(instance, class_, message) {
  if (!isDirectInstanceOf(instance, class_)) {
    throw new TypeError(message ?? typeErrorMessage("T", instance));
  }
}
__name(assertDirectInstanceOf, "assertDirectInstanceOf");
function assertEmptyArray(value, message) {
  if (!isEmptyArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty array", value));
  }
}
__name(assertEmptyArray, "assertEmptyArray");
function assertEmptyMap(value, message) {
  if (!isEmptyMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty map", value));
  }
}
__name(assertEmptyMap, "assertEmptyMap");
function assertEmptyObject(value, message) {
  if (!isEmptyObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty object", value));
  }
}
__name(assertEmptyObject, "assertEmptyObject");
function assertEmptySet(value, message) {
  if (!isEmptySet(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty set", value));
  }
}
__name(assertEmptySet, "assertEmptySet");
function assertEmptyString(value, message) {
  if (!isEmptyString(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty string", value));
  }
}
__name(assertEmptyString, "assertEmptyString");
function assertEmptyStringOrWhitespace(value, message) {
  if (!isEmptyStringOrWhitespace(value)) {
    throw new TypeError(message ?? typeErrorMessage("empty string or whitespace", value));
  }
}
__name(assertEmptyStringOrWhitespace, "assertEmptyStringOrWhitespace");
function assertEnumCase(value, targetEnum, message) {
  if (!isEnumCase(value, targetEnum)) {
    throw new TypeError(message ?? typeErrorMessage("EnumCase", value));
  }
}
__name(assertEnumCase, "assertEnumCase");
function assertError(value, message) {
  if (!isError(value)) {
    throw new TypeError(message ?? typeErrorMessage("Error", value));
  }
}
__name(assertError, "assertError");
function assertEvenInteger(value, message) {
  if (!isEvenInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("even integer", value));
  }
}
__name(assertEvenInteger, "assertEvenInteger");
function assertFalsy(value, message) {
  if (!isFalsy(value)) {
    throw new TypeError(message ?? typeErrorMessage("falsy", value));
  }
}
__name(assertFalsy, "assertFalsy");
function assertFloat32Array(value, message) {
  if (!isFloat32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Float32Array", value));
  }
}
__name(assertFloat32Array, "assertFloat32Array");
function assertFloat64Array(value, message) {
  if (!isFloat64Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Float64Array", value));
  }
}
__name(assertFloat64Array, "assertFloat64Array");
function assertFormData(value, message) {
  if (!isFormData(value)) {
    throw new TypeError(message ?? typeErrorMessage("FormData", value));
  }
}
__name(assertFormData, "assertFormData");
function assertFunction(value, message) {
  if (!isFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("Function", value));
  }
}
__name(assertFunction, "assertFunction");
function assertGenerator(value, message) {
  if (!isGenerator(value)) {
    throw new TypeError(message ?? typeErrorMessage("Generator", value));
  }
}
__name(assertGenerator, "assertGenerator");
function assertGeneratorFunction(value, message) {
  if (!isGeneratorFunction(value)) {
    throw new TypeError(message ?? typeErrorMessage("GeneratorFunction", value));
  }
}
__name(assertGeneratorFunction, "assertGeneratorFunction");
function assertHtmlElement(value, message) {
  if (!isHtmlElement(value)) {
    throw new TypeError(message ?? typeErrorMessage("HTMLElement", value));
  }
}
__name(assertHtmlElement, "assertHtmlElement");
function assertInfinite(value, message) {
  if (!isInfinite(value)) {
    throw new TypeError(message ?? typeErrorMessage("infinite number", value));
  }
}
__name(assertInfinite, "assertInfinite");
function assertInRange(value, range, message) {
  if (!isInRange(value, range)) {
    throw new TypeError(message ?? typeErrorMessage("in range", value));
  }
}
__name(assertInRange, "assertInRange");
function assertInt16Array(value, message) {
  if (!isInt16Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int16Array", value));
  }
}
__name(assertInt16Array, "assertInt16Array");
function assertInt32Array(value, message) {
  if (!isInt32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int32Array", value));
  }
}
__name(assertInt32Array, "assertInt32Array");
function assertInt8Array(value, message) {
  if (!isInt8Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Int8Array", value));
  }
}
__name(assertInt8Array, "assertInt8Array");
function assertInteger(value, message) {
  if (!isInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("integer", value));
  }
}
__name(assertInteger, "assertInteger");
function assertIterable(value, message) {
  if (!isIterable(value)) {
    throw new TypeError(message ?? typeErrorMessage("Iterable", value));
  }
}
__name(assertIterable, "assertIterable");
function assertMap(value, message) {
  if (!isMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("Map", value));
  }
}
__name(assertMap, "assertMap");
function assertNan(value, message) {
  if (!isNan(value)) {
    throw new TypeError(message ?? typeErrorMessage("NaN", value));
  }
}
__name(assertNan, "assertNan");
function assertNativePromise(value, message) {
  if (!isNativePromise(value)) {
    throw new TypeError(message ?? typeErrorMessage("native Promise", value));
  }
}
__name(assertNativePromise, "assertNativePromise");
function assertNegativeNumber(value, message) {
  if (!isNegativeNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("negative number", value));
  }
}
__name(assertNegativeNumber, "assertNegativeNumber");
function assertNodeStream(value, message) {
  if (!isNodeStream(value)) {
    throw new TypeError(message ?? typeErrorMessage("Node.js Stream", value));
  }
}
__name(assertNodeStream, "assertNodeStream");
function assertNonEmptyArray(value, message) {
  if (!isNonEmptyArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty array", value));
  }
}
__name(assertNonEmptyArray, "assertNonEmptyArray");
function assertNonEmptyMap(value, message) {
  if (!isNonEmptyMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty map", value));
  }
}
__name(assertNonEmptyMap, "assertNonEmptyMap");
function assertNonEmptyObject(value, message) {
  if (!isNonEmptyObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty object", value));
  }
}
__name(assertNonEmptyObject, "assertNonEmptyObject");
function assertNonEmptySet(value, message) {
  if (!isNonEmptySet(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty set", value));
  }
}
__name(assertNonEmptySet, "assertNonEmptySet");
function assertNonEmptyString(value, message) {
  if (!isNonEmptyString(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty string", value));
  }
}
__name(assertNonEmptyString, "assertNonEmptyString");
function assertNonEmptyStringAndNotWhitespace(value, message) {
  if (!isNonEmptyStringAndNotWhitespace(value)) {
    throw new TypeError(message ?? typeErrorMessage("non-empty string and not whitespace", value));
  }
}
__name(assertNonEmptyStringAndNotWhitespace, "assertNonEmptyStringAndNotWhitespace");
function assertNull(value, message) {
  if (!isNull(value)) {
    throw new TypeError(message ?? typeErrorMessage("null", value));
  }
}
__name(assertNull, "assertNull");
function assertNullOrUndefined(value, message) {
  if (!isNullOrUndefined(value)) {
    throw new TypeError(message ?? typeErrorMessage("null or undefined", value));
  }
}
__name(assertNullOrUndefined, "assertNullOrUndefined");
function assertNumber(value, message) {
  if (!isNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("number", value));
  }
}
__name(assertNumber, "assertNumber");
function assertNumericString(value, message) {
  if (!isNumericString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string with a number", value));
  }
}
__name(assertNumericString, "assertNumericString");
function assertObject(value, message) {
  if (!isObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("Object", value));
  }
}
__name(assertObject, "assertObject");
function assertObservable(value, message) {
  if (!isObservable(value)) {
    throw new TypeError(message ?? typeErrorMessage("Observable", value));
  }
}
__name(assertObservable, "assertObservable");
function assertOddInteger(value, message) {
  if (!isOddInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("odd integer", value));
  }
}
__name(assertOddInteger, "assertOddInteger");
function assertPlainObject(value, message) {
  if (!isPlainObject(value)) {
    throw new TypeError(message ?? typeErrorMessage("plain object", value));
  }
}
__name(assertPlainObject, "assertPlainObject");
function assertPositiveNumber(value, message) {
  if (!isPositiveNumber(value)) {
    throw new TypeError(message ?? typeErrorMessage("positive number", value));
  }
}
__name(assertPositiveNumber, "assertPositiveNumber");
function assertPrimitive(value, message) {
  if (!isPrimitive(value)) {
    throw new TypeError(message ?? typeErrorMessage("primitive", value));
  }
}
__name(assertPrimitive, "assertPrimitive");
function assertPromise(value, message) {
  if (!isPromise(value)) {
    throw new TypeError(message ?? typeErrorMessage("Promise", value));
  }
}
__name(assertPromise, "assertPromise");
function assertPropertyKey(value, message) {
  if (!isPropertyKey(value)) {
    throw new TypeError(message ?? typeErrorMessage("PropertyKey", value));
  }
}
__name(assertPropertyKey, "assertPropertyKey");
function assertRegExp(value, message) {
  if (!isRegExp(value)) {
    throw new TypeError(message ?? typeErrorMessage("RegExp", value));
  }
}
__name(assertRegExp, "assertRegExp");
function assertSafeInteger(value, message) {
  if (!isSafeInteger(value)) {
    throw new TypeError(message ?? typeErrorMessage("integer", value));
  }
}
__name(assertSafeInteger, "assertSafeInteger");
function assertSet(value, message) {
  if (!isSet(value)) {
    throw new TypeError(message ?? typeErrorMessage("Set", value));
  }
}
__name(assertSet, "assertSet");
function assertSharedArrayBuffer(value, message) {
  if (!isSharedArrayBuffer(value)) {
    throw new TypeError(message ?? typeErrorMessage("SharedArrayBuffer", value));
  }
}
__name(assertSharedArrayBuffer, "assertSharedArrayBuffer");
function assertString(value, message) {
  if (!isString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string", value));
  }
}
__name(assertString, "assertString");
function assertSymbol(value, message) {
  if (!isSymbol(value)) {
    throw new TypeError(message ?? typeErrorMessage("symbol", value));
  }
}
__name(assertSymbol, "assertSymbol");
function assertTruthy(value, message) {
  if (!isTruthy(value)) {
    throw new TypeError(message ?? typeErrorMessage("truthy", value));
  }
}
__name(assertTruthy, "assertTruthy");
function assertTupleLike(value, guards, message) {
  if (!isTupleLike(value, guards)) {
    throw new TypeError(message ?? typeErrorMessage("tuple-like", value));
  }
}
__name(assertTupleLike, "assertTupleLike");
function assertTypedArray(value, message) {
  if (!isTypedArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("TypedArray", value));
  }
}
__name(assertTypedArray, "assertTypedArray");
function assertUint16Array(value, message) {
  if (!isUint16Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint16Array", value));
  }
}
__name(assertUint16Array, "assertUint16Array");
function assertUint32Array(value, message) {
  if (!isUint32Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint32Array", value));
  }
}
__name(assertUint32Array, "assertUint32Array");
function assertUint8Array(value, message) {
  if (!isUint8Array(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint8Array", value));
  }
}
__name(assertUint8Array, "assertUint8Array");
function assertUint8ClampedArray(value, message) {
  if (!isUint8ClampedArray(value)) {
    throw new TypeError(message ?? typeErrorMessage("Uint8ClampedArray", value));
  }
}
__name(assertUint8ClampedArray, "assertUint8ClampedArray");
function assertUndefined(value, message) {
  if (!isUndefined(value)) {
    throw new TypeError(message ?? typeErrorMessage("undefined", value));
  }
}
__name(assertUndefined, "assertUndefined");
function assertUrlInstance(value, message) {
  if (!isUrlInstance(value)) {
    throw new TypeError(message ?? typeErrorMessage("URL", value));
  }
}
__name(assertUrlInstance, "assertUrlInstance");
function assertUrlSearchParams(value, message) {
  if (!isUrlSearchParams(value)) {
    throw new TypeError(message ?? typeErrorMessage("URLSearchParams", value));
  }
}
__name(assertUrlSearchParams, "assertUrlSearchParams");
function assertUrlString(value, message) {
  if (!isUrlString(value)) {
    throw new TypeError(message ?? typeErrorMessage("string with a URL", value));
  }
}
__name(assertUrlString, "assertUrlString");
function assertValidDate(value, message) {
  if (!isValidDate(value)) {
    throw new TypeError(message ?? typeErrorMessage("valid Date", value));
  }
}
__name(assertValidDate, "assertValidDate");
function assertValidLength(value, message) {
  if (!isValidLength(value)) {
    throw new TypeError(message ?? typeErrorMessage("valid length", value));
  }
}
__name(assertValidLength, "assertValidLength");
function assertWeakMap(value, message) {
  if (!isWeakMap(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakMap", value));
  }
}
__name(assertWeakMap, "assertWeakMap");
function assertWeakRef(value, message) {
  if (!isWeakRef(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakRef", value));
  }
}
__name(assertWeakRef, "assertWeakRef");
function assertWeakSet(value, message) {
  if (!isWeakSet(value)) {
    throw new TypeError(message ?? typeErrorMessage("WeakSet", value));
  }
}
__name(assertWeakSet, "assertWeakSet");
function assertWhitespaceString(value, message) {
  if (!isWhitespaceString(value)) {
    throw new TypeError(message ?? typeErrorMessage("whitespace string", value));
  }
}
__name(assertWhitespaceString, "assertWhitespaceString");
var distribution_default = is;

// node_modules/got/dist/source/as-promise/index.js
init_esm();
import { EventEmitter as EventEmitter2 } from "node:events";

// node_modules/p-cancelable/index.js
init_esm();
var CancelError = class extends Error {
  static {
    __name(this, "CancelError");
  }
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
};
var promiseState = Object.freeze({
  pending: Symbol("pending"),
  canceled: Symbol("canceled"),
  resolved: Symbol("resolved"),
  rejected: Symbol("rejected")
});
var PCancelable = class _PCancelable {
  static {
    __name(this, "PCancelable");
  }
  static fn(userFunction) {
    return (...arguments_) => new _PCancelable((resolve, reject, onCancel) => {
      arguments_.push(onCancel);
      userFunction(...arguments_).then(resolve, reject);
    });
  }
  #cancelHandlers = [];
  #rejectOnCancel = true;
  #state = promiseState.pending;
  #promise;
  #reject;
  constructor(executor) {
    this.#promise = new Promise((resolve, reject) => {
      this.#reject = reject;
      const onResolve = /* @__PURE__ */ __name((value) => {
        if (this.#state !== promiseState.canceled || !onCancel.shouldReject) {
          resolve(value);
          this.#setState(promiseState.resolved);
        }
      }, "onResolve");
      const onReject = /* @__PURE__ */ __name((error) => {
        if (this.#state !== promiseState.canceled || !onCancel.shouldReject) {
          reject(error);
          this.#setState(promiseState.rejected);
        }
      }, "onReject");
      const onCancel = /* @__PURE__ */ __name((handler) => {
        if (this.#state !== promiseState.pending) {
          throw new Error(`The \`onCancel\` handler was attached after the promise ${this.#state.description}.`);
        }
        this.#cancelHandlers.push(handler);
      }, "onCancel");
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: /* @__PURE__ */ __name(() => this.#rejectOnCancel, "get"),
          set: /* @__PURE__ */ __name((boolean) => {
            this.#rejectOnCancel = boolean;
          }, "set")
        }
      });
      executor(onResolve, onReject, onCancel);
    });
  }
  // eslint-disable-next-line unicorn/no-thenable
  then(onFulfilled, onRejected) {
    return this.#promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this.#promise.catch(onRejected);
  }
  finally(onFinally) {
    return this.#promise.finally(onFinally);
  }
  cancel(reason) {
    if (this.#state !== promiseState.pending) {
      return;
    }
    this.#setState(promiseState.canceled);
    if (this.#cancelHandlers.length > 0) {
      try {
        for (const handler of this.#cancelHandlers) {
          handler();
        }
      } catch (error) {
        this.#reject(error);
        return;
      }
    }
    if (this.#rejectOnCancel) {
      this.#reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this.#state === promiseState.canceled;
  }
  #setState(state) {
    if (this.#state === promiseState.pending) {
      this.#state = state;
    }
  }
};
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// node_modules/got/dist/source/core/errors.js
init_esm();
function isRequest(x) {
  return distribution_default.object(x) && "_onResponse" in x;
}
__name(isRequest, "isRequest");
var RequestError = class extends Error {
  static {
    __name(this, "RequestError");
  }
  input;
  code;
  stack;
  response;
  request;
  timings;
  constructor(message, error, self2) {
    super(message, { cause: error });
    Error.captureStackTrace(this, this.constructor);
    this.name = "RequestError";
    this.code = error.code ?? "ERR_GOT_REQUEST_ERROR";
    this.input = error.input;
    if (isRequest(self2)) {
      Object.defineProperty(this, "request", {
        enumerable: false,
        value: self2
      });
      Object.defineProperty(this, "response", {
        enumerable: false,
        value: self2.response
      });
      this.options = self2.options;
    } else {
      this.options = self2;
    }
    this.timings = this.request?.timings;
    if (distribution_default.string(error.stack) && distribution_default.string(this.stack)) {
      const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
      const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
      const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
      while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
        thisStackTrace.shift();
      }
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
    }
  }
};
var MaxRedirectsError = class extends RequestError {
  static {
    __name(this, "MaxRedirectsError");
  }
  constructor(request) {
    super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
    this.name = "MaxRedirectsError";
    this.code = "ERR_TOO_MANY_REDIRECTS";
  }
};
var HTTPError = class extends RequestError {
  static {
    __name(this, "HTTPError");
  }
  constructor(response) {
    super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
    this.name = "HTTPError";
    this.code = "ERR_NON_2XX_3XX_RESPONSE";
  }
};
var CacheError = class extends RequestError {
  static {
    __name(this, "CacheError");
  }
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "CacheError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
  }
};
var UploadError = class extends RequestError {
  static {
    __name(this, "UploadError");
  }
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "UploadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
  }
};
var TimeoutError = class extends RequestError {
  static {
    __name(this, "TimeoutError");
  }
  timings;
  event;
  constructor(error, timings, request) {
    super(error.message, error, request);
    this.name = "TimeoutError";
    this.event = error.event;
    this.timings = timings;
  }
};
var ReadError = class extends RequestError {
  static {
    __name(this, "ReadError");
  }
  constructor(error, request) {
    super(error.message, error, request);
    this.name = "ReadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
  }
};
var RetryError = class extends RequestError {
  static {
    __name(this, "RetryError");
  }
  constructor(request) {
    super("Retrying", {}, request);
    this.name = "RetryError";
    this.code = "ERR_RETRYING";
  }
};
var AbortError = class extends RequestError {
  static {
    __name(this, "AbortError");
  }
  constructor(request) {
    super("This operation was aborted.", {}, request);
    this.code = "ERR_ABORTED";
    this.name = "AbortError";
  }
};

// node_modules/got/dist/source/core/index.js
init_esm();
import process3 from "node:process";
import { Buffer as Buffer3 } from "node:buffer";
import { Duplex } from "node:stream";
import http2, { ServerResponse } from "node:http";

// node_modules/@szmarczak/http-timer/dist/source/index.js
init_esm();
var import_defer_to_connect = __toESM(require_source(), 1);
import { errorMonitor } from "events";
import { types } from "util";
var timer = /* @__PURE__ */ __name((request) => {
  if (request.timings) {
    return request.timings;
  }
  const timings = {
    start: Date.now(),
    socket: void 0,
    lookup: void 0,
    connect: void 0,
    secureConnect: void 0,
    upload: void 0,
    response: void 0,
    end: void 0,
    error: void 0,
    abort: void 0,
    phases: {
      wait: void 0,
      dns: void 0,
      tcp: void 0,
      tls: void 0,
      request: void 0,
      firstByte: void 0,
      download: void 0,
      total: void 0
    }
  };
  request.timings = timings;
  const handleError = /* @__PURE__ */ __name((origin) => {
    origin.once(errorMonitor, () => {
      timings.error = Date.now();
      timings.phases.total = timings.error - timings.start;
    });
  }, "handleError");
  handleError(request);
  const onAbort = /* @__PURE__ */ __name(() => {
    timings.abort = Date.now();
    timings.phases.total = timings.abort - timings.start;
  }, "onAbort");
  request.prependOnceListener("abort", onAbort);
  const onSocket = /* @__PURE__ */ __name((socket) => {
    timings.socket = Date.now();
    timings.phases.wait = timings.socket - timings.start;
    if (types.isProxy(socket)) {
      return;
    }
    const lookupListener = /* @__PURE__ */ __name(() => {
      timings.lookup = Date.now();
      timings.phases.dns = timings.lookup - timings.socket;
    }, "lookupListener");
    socket.prependOnceListener("lookup", lookupListener);
    (0, import_defer_to_connect.default)(socket, {
      connect: /* @__PURE__ */ __name(() => {
        timings.connect = Date.now();
        if (timings.lookup === void 0) {
          socket.removeListener("lookup", lookupListener);
          timings.lookup = timings.connect;
          timings.phases.dns = timings.lookup - timings.socket;
        }
        timings.phases.tcp = timings.connect - timings.lookup;
      }, "connect"),
      secureConnect: /* @__PURE__ */ __name(() => {
        timings.secureConnect = Date.now();
        timings.phases.tls = timings.secureConnect - timings.connect;
      }, "secureConnect")
    });
  }, "onSocket");
  if (request.socket) {
    onSocket(request.socket);
  } else {
    request.prependOnceListener("socket", onSocket);
  }
  const onUpload = /* @__PURE__ */ __name(() => {
    timings.upload = Date.now();
    timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
  }, "onUpload");
  if (request.writableFinished) {
    onUpload();
  } else {
    request.prependOnceListener("finish", onUpload);
  }
  request.prependOnceListener("response", (response) => {
    timings.response = Date.now();
    timings.phases.firstByte = timings.response - timings.upload;
    response.timings = timings;
    handleError(response);
    response.prependOnceListener("end", () => {
      request.off("abort", onAbort);
      response.off("aborted", onAbort);
      if (timings.phases.total) {
        return;
      }
      timings.end = Date.now();
      timings.phases.download = timings.end - timings.response;
      timings.phases.total = timings.end - timings.start;
    });
    response.prependOnceListener("aborted", onAbort);
  });
  return timings;
}, "timer");
var source_default = timer;

// node_modules/cacheable-request/dist/index.js
init_esm();
import EventEmitter from "node:events";
import urlLib from "node:url";
import crypto from "node:crypto";
import stream, { PassThrough as PassThroughStream } from "node:stream";

// node_modules/normalize-url/index.js
init_esm();
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = /* @__PURE__ */ __name((name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name), "testParameter");
var supportedProtocols = /* @__PURE__ */ new Set([
  "https:",
  "http:",
  "file:"
]);
var hasCustomProtocol = /* @__PURE__ */ __name((urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
}, "hasCustomProtocol");
var normalizeDataURL = /* @__PURE__ */ __name((urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  const { type, data, hash } = match.groups;
  const mediaType = type.split(";");
  const isBase64 = mediaType.at(-1) === "base64";
  if (isBase64) {
    mediaType.pop();
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [...attributes];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  const hashPart = stripHash || !hash ? "" : `#${hash}`;
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hashPart}`;
}, "normalizeDataURL");
function normalizeUrl(urlString, options) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    removePath: false,
    transformPath: false,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (; ; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname).replace(/\\/g, "%5C");
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    const pathComponents = urlObject.pathname.split("/").filter(Boolean);
    const lastComponent = pathComponents.at(-1);
    if (lastComponent && testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents.pop();
      urlObject.pathname = pathComponents.length > 0 ? `/${pathComponents.join("/")}/` : "/";
    }
  }
  if (options.removePath) {
    urlObject.pathname = "/";
  }
  if (options.transformPath && typeof options.transformPath === "function") {
    const pathComponents = urlObject.pathname.split("/").filter(Boolean);
    const newComponents = options.transformPath(pathComponents);
    urlObject.pathname = newComponents?.length > 0 ? `/${newComponents.join("/")}` : "/";
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    const originalSearch = urlObject.search;
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
    const partsWithoutEquals = originalSearch.slice(1).split("&").filter((p) => p && !p.includes("="));
    for (const part of partsWithoutEquals) {
      const decoded = decodeURIComponent(part);
      urlObject.search = urlObject.search.replace(`?${decoded}=`, `?${decoded}`).replace(`&${decoded}=`, `&${decoded}`);
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}
__name(normalizeUrl, "normalizeUrl");

// node_modules/cacheable-request/node_modules/get-stream/source/index.js
init_esm();
import { on } from "node:events";
import { finished } from "node:stream/promises";

// node_modules/cacheable-request/node_modules/get-stream/source/stream.js
init_esm();

// node_modules/cacheable-request/node_modules/is-stream/index.js
init_esm();
function isStream(stream2, { checkOpen = true } = {}) {
  return stream2 !== null && typeof stream2 === "object" && (stream2.writable || stream2.readable || !checkOpen || stream2.writable === void 0 && stream2.readable === void 0) && typeof stream2.pipe === "function";
}
__name(isStream, "isStream");
function isReadableStream(stream2, { checkOpen = true } = {}) {
  return isStream(stream2, { checkOpen }) && (stream2.readable || !checkOpen) && typeof stream2.read === "function" && typeof stream2.readable === "boolean" && typeof stream2.readableObjectMode === "boolean" && typeof stream2.destroy === "function" && typeof stream2.destroyed === "boolean";
}
__name(isReadableStream, "isReadableStream");

// node_modules/@sec-ant/readable-stream/dist/ponyfill/index.js
init_esm();

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
init_esm();
var a = Object.getPrototypeOf(
  Object.getPrototypeOf(
    /* istanbul ignore next */
    async function* () {
    }
  ).prototype
);
var c = class {
  static {
    __name(this, "c");
  }
  #t;
  #n;
  #r = false;
  #e = void 0;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = /* @__PURE__ */ __name(() => this.#s(), "e");
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = /* @__PURE__ */ __name(() => this.#i(e), "t");
    return this.#e ? this.#e.then(t, t) : t();
  }
  async #s() {
    if (this.#r)
      return {
        done: true,
        value: void 0
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = void 0, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = void 0, this.#r = true, this.#t.releaseLock()), e;
  }
  async #i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
};
var n = Symbol();
function i() {
  return this[n].next();
}
__name(i, "i");
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
__name(o, "o");
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(
    e,
    r
  ), s = Object.create(u);
  return s[n] = t, s;
}
__name(h, "h");

// node_modules/@sec-ant/readable-stream/dist/ponyfill/fromAnyIterable.js
init_esm();

// node_modules/cacheable-request/node_modules/get-stream/source/stream.js
var getAsyncIterable = /* @__PURE__ */ __name((stream2) => {
  if (isReadableStream(stream2, { checkOpen: false }) && nodeImports.on !== void 0) {
    return getStreamIterable(stream2);
  }
  if (typeof stream2?.[Symbol.asyncIterator] === "function") {
    return stream2;
  }
  if (toString.call(stream2) === "[object ReadableStream]") {
    return h.call(stream2);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
}, "getAsyncIterable");
var { toString } = Object.prototype;
var getStreamIterable = /* @__PURE__ */ __name(async function* (stream2) {
  const controller = new AbortController();
  const state = {};
  handleStreamEnd(stream2, controller, state);
  try {
    for await (const [chunk2] of nodeImports.on(stream2, "data", { signal: controller.signal })) {
      yield chunk2;
    }
  } catch (error) {
    if (state.error !== void 0) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream2.destroy();
  }
}, "getStreamIterable");
var handleStreamEnd = /* @__PURE__ */ __name(async (stream2, controller, state) => {
  try {
    await nodeImports.finished(stream2, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
}, "handleStreamEnd");
var nodeImports = {};

// node_modules/cacheable-request/node_modules/get-stream/source/exports.js
init_esm();

// node_modules/cacheable-request/node_modules/get-stream/source/contents.js
init_esm();
var getStreamContents = /* @__PURE__ */ __name(async (stream2, { init: init2, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream2);
  const state = init2();
  state.length = 0;
  try {
    for await (const chunk2 of asyncIterable) {
      const chunkType = getChunkType(chunk2);
      const convertedChunk = convertChunk[chunkType](chunk2, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
}, "getStreamContents");
var appendFinalChunk = /* @__PURE__ */ __name(({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== void 0) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
}, "appendFinalChunk");
var appendChunk = /* @__PURE__ */ __name(({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== void 0) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError();
}, "appendChunk");
var addNewChunk = /* @__PURE__ */ __name((convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
}, "addNewChunk");
var getChunkType = /* @__PURE__ */ __name((chunk2) => {
  const typeOfChunk = typeof chunk2;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk2 === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk2)) {
    return "buffer";
  }
  const prototypeName = objectToString.call(chunk2);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk2.byteLength) && Number.isInteger(chunk2.byteOffset) && objectToString.call(chunk2.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
}, "getChunkType");
var { toString: objectToString } = Object.prototype;
var MaxBufferError = class extends Error {
  static {
    __name(this, "MaxBufferError");
  }
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
};

// node_modules/cacheable-request/node_modules/get-stream/source/utils.js
init_esm();
var noop = /* @__PURE__ */ __name(() => void 0, "noop");
var throwObjectStream = /* @__PURE__ */ __name((chunk2) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk2)}`);
}, "throwObjectStream");
var getLengthProperty = /* @__PURE__ */ __name((convertedChunk) => convertedChunk.length, "getLengthProperty");

// node_modules/cacheable-request/node_modules/get-stream/source/array-buffer.js
init_esm();
async function getStreamAsArrayBuffer(stream2, options) {
  return getStreamContents(stream2, arrayBufferMethods, options);
}
__name(getStreamAsArrayBuffer, "getStreamAsArrayBuffer");
var initArrayBuffer = /* @__PURE__ */ __name(() => ({ contents: new ArrayBuffer(0) }), "initArrayBuffer");
var useTextEncoder = /* @__PURE__ */ __name((chunk2) => textEncoder.encode(chunk2), "useTextEncoder");
var textEncoder = new TextEncoder();
var useUint8Array = /* @__PURE__ */ __name((chunk2) => new Uint8Array(chunk2), "useUint8Array");
var useUint8ArrayWithOffset = /* @__PURE__ */ __name((chunk2) => new Uint8Array(chunk2.buffer, chunk2.byteOffset, chunk2.byteLength), "useUint8ArrayWithOffset");
var truncateArrayBufferChunk = /* @__PURE__ */ __name((convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize), "truncateArrayBufferChunk");
var addArrayBufferChunk = /* @__PURE__ */ __name((convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
}, "addArrayBufferChunk");
var resizeArrayBufferSlow = /* @__PURE__ */ __name((contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
}, "resizeArrayBufferSlow");
var resizeArrayBuffer = /* @__PURE__ */ __name((contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
}, "resizeArrayBuffer");
var getNewContentsLength = /* @__PURE__ */ __name((length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR)), "getNewContentsLength");
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = /* @__PURE__ */ __name(({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length), "finalizeArrayBuffer");
var hasArrayBufferResize = /* @__PURE__ */ __name(() => "resize" in ArrayBuffer.prototype, "hasArrayBufferResize");
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop,
  finalize: finalizeArrayBuffer
};

// node_modules/cacheable-request/node_modules/get-stream/source/buffer.js
init_esm();
async function getStreamAsBuffer(stream2, options) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream2, options));
  } catch (error) {
    if (error.bufferedData !== void 0) {
      error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
    }
    throw error;
  }
}
__name(getStreamAsBuffer, "getStreamAsBuffer");
var arrayBufferToNodeBuffer = /* @__PURE__ */ __name((arrayBuffer) => globalThis.Buffer.from(arrayBuffer), "arrayBufferToNodeBuffer");

// node_modules/cacheable-request/node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on, finished });

// node_modules/cacheable-request/dist/index.js
var import_http_cache_semantics = __toESM(require_http_cache_semantics(), 1);

// node_modules/responselike/index.js
init_esm();
import { Readable as ReadableStream2 } from "node:stream";

// node_modules/lowercase-keys/index.js
init_esm();
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}
__name(lowercaseKeys, "lowercaseKeys");

// node_modules/responselike/index.js
var Response = class extends ReadableStream2 {
  static {
    __name(this, "Response");
  }
  statusCode;
  headers;
  body;
  url;
  constructor({ statusCode, headers, body, url }) {
    if (typeof statusCode !== "number") {
      throw new TypeError("Argument `statusCode` should be a number");
    }
    if (typeof headers !== "object") {
      throw new TypeError("Argument `headers` should be an object");
    }
    if (!(body instanceof Uint8Array)) {
      throw new TypeError("Argument `body` should be a buffer");
    }
    if (typeof url !== "string") {
      throw new TypeError("Argument `url` should be a string");
    }
    super({
      read() {
        this.push(body);
        this.push(null);
      }
    });
    this.statusCode = statusCode;
    this.headers = lowercaseKeys(headers);
    this.body = body;
    this.url = url;
  }
};

// node_modules/cacheable-request/dist/index.js
var import_keyv = __toESM(require_src2(), 1);

// node_modules/mimic-response/index.js
init_esm();
var knownProperties = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy) {
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  }
  const fromProperties = /* @__PURE__ */ new Set([...Object.keys(fromStream), ...knownProperties]);
  const properties = {};
  for (const property of fromProperties) {
    if (property in toStream) {
      continue;
    }
    properties[property] = {
      get() {
        const value = fromStream[property];
        const isFunction4 = typeof value === "function";
        return isFunction4 ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: true,
      configurable: false
    };
  }
  Object.defineProperties(toStream, properties);
  fromStream.once("aborted", () => {
    toStream.destroy();
    toStream.emit("aborted");
  });
  fromStream.once("close", () => {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once("end", () => {
          toStream.emit("close");
        });
      } else {
        toStream.emit("close");
      }
    } else {
      toStream.emit("close");
    }
  });
  return toStream;
}
__name(mimicResponse, "mimicResponse");

// node_modules/cacheable-request/dist/types.js
init_esm();
var RequestError2 = class extends Error {
  static {
    __name(this, "RequestError");
  }
  constructor(error) {
    super(error.message);
    Object.assign(this, error);
  }
};
var CacheError2 = class extends Error {
  static {
    __name(this, "CacheError");
  }
  constructor(error) {
    super(error.message);
    Object.assign(this, error);
  }
};

// node_modules/cacheable-request/dist/index.js
var CacheableRequest = class {
  static {
    __name(this, "CacheableRequest");
  }
  constructor(cacheRequest, cacheAdapter) {
    this.hooks = /* @__PURE__ */ new Map();
    this.request = () => (options, callback) => {
      let url;
      if (typeof options === "string") {
        url = normalizeUrlObject(urlLib.parse(options));
        options = {};
      } else if (options instanceof urlLib.URL) {
        url = normalizeUrlObject(urlLib.parse(options.toString()));
        options = {};
      } else {
        const [pathname, ...searchParts] = (options.path ?? "").split("?");
        const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url = normalizeUrlObject({ ...options, pathname, search });
      }
      options = {
        headers: {},
        method: "GET",
        cache: true,
        strictTtl: false,
        automaticFailover: false,
        ...options,
        ...urlObjectToRequestOptions(url)
      };
      options.headers = Object.fromEntries(entries(options.headers).map(([key2, value]) => [key2.toLowerCase(), value]));
      const ee = new EventEmitter();
      const normalizedUrlString = normalizeUrl(urlLib.format(url), {
        stripWWW: false,
        // eslint-disable-line @typescript-eslint/naming-convention
        removeTrailingSlash: false,
        stripAuthentication: false
      });
      let key = `${options.method}:${normalizedUrlString}`;
      if (options.body && options.method !== void 0 && ["POST", "PATCH", "PUT"].includes(options.method)) {
        if (options.body instanceof stream.Readable) {
          options.cache = false;
        } else {
          key += `:${crypto.createHash("md5").update(options.body).digest("hex")}`;
        }
      }
      let revalidate = false;
      let madeRequest = false;
      const makeRequest = /* @__PURE__ */ __name((options_) => {
        madeRequest = true;
        let requestErrored = false;
        let requestErrorCallback = /* @__PURE__ */ __name(() => {
        }, "requestErrorCallback");
        const requestErrorPromise = new Promise((resolve) => {
          requestErrorCallback = /* @__PURE__ */ __name(() => {
            if (!requestErrored) {
              requestErrored = true;
              resolve();
            }
          }, "requestErrorCallback");
        });
        const handler = /* @__PURE__ */ __name(async (response) => {
          if (revalidate) {
            response.status = response.statusCode;
            const revalidatedPolicy = import_http_cache_semantics.default.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
            if (!revalidatedPolicy.modified) {
              response.resume();
              await new Promise((resolve) => {
                response.once("end", resolve);
              });
              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
              response = new Response({
                statusCode: revalidate.statusCode,
                headers,
                body: revalidate.body,
                url: revalidate.url
              });
              response.cachePolicy = revalidatedPolicy.policy;
              response.fromCache = true;
            }
          }
          if (!response.fromCache) {
            response.cachePolicy = new import_http_cache_semantics.default(options_, response, options_);
            response.fromCache = false;
          }
          let clonedResponse;
          if (options_.cache && response.cachePolicy.storable()) {
            clonedResponse = cloneResponse(response);
            (async () => {
              try {
                const bodyPromise = getStreamAsBuffer(response);
                await Promise.race([
                  requestErrorPromise,
                  new Promise((resolve) => response.once("end", resolve)),
                  // eslint-disable-line no-promise-executor-return
                  new Promise((resolve) => response.once("close", resolve))
                  // eslint-disable-line no-promise-executor-return
                ]);
                const body = await bodyPromise;
                let value = {
                  url: response.url,
                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                  body,
                  cachePolicy: response.cachePolicy.toObject()
                };
                let ttl2 = options_.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                if (options_.maxTtl) {
                  ttl2 = ttl2 ? Math.min(ttl2, options_.maxTtl) : options_.maxTtl;
                }
                if (this.hooks.size > 0) {
                  for (const key_ of this.hooks.keys()) {
                    value = await this.runHook(key_, value, response);
                  }
                }
                await this.cache.set(key, value, ttl2);
              } catch (error) {
                ee.emit("error", new CacheError2(error));
              }
            })();
          } else if (options_.cache && revalidate) {
            (async () => {
              try {
                await this.cache.delete(key);
              } catch (error) {
                ee.emit("error", new CacheError2(error));
              }
            })();
          }
          ee.emit("response", clonedResponse ?? response);
          if (typeof callback === "function") {
            callback(clonedResponse ?? response);
          }
        }, "handler");
        try {
          const request_ = this.cacheRequest(options_, handler);
          request_.once("error", requestErrorCallback);
          request_.once("abort", requestErrorCallback);
          request_.once("destroy", requestErrorCallback);
          ee.emit("request", request_);
        } catch (error) {
          ee.emit("error", new RequestError2(error));
        }
      }, "makeRequest");
      (async () => {
        const get = /* @__PURE__ */ __name(async (options_) => {
          await Promise.resolve();
          const cacheEntry = options_.cache ? await this.cache.get(key) : void 0;
          if (cacheEntry === void 0 && !options_.forceRefresh) {
            makeRequest(options_);
            return;
          }
          const policy = import_http_cache_semantics.default.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
            const headers = convertHeaders(policy.responseHeaders());
            const response = new Response({
              statusCode: cacheEntry.statusCode,
              headers,
              body: cacheEntry.body,
              url: cacheEntry.url
            });
            response.cachePolicy = policy;
            response.fromCache = true;
            ee.emit("response", response);
            if (typeof callback === "function") {
              callback(response);
            }
          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
            await this.cache.delete(key);
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          } else {
            revalidate = cacheEntry;
            options_.headers = policy.revalidationHeaders(options_);
            makeRequest(options_);
          }
        }, "get");
        const errorHandler = /* @__PURE__ */ __name((error) => ee.emit("error", new CacheError2(error)), "errorHandler");
        if (this.cache instanceof import_keyv.default) {
          const cachek = this.cache;
          cachek.once("error", errorHandler);
          ee.on("error", () => cachek.removeListener("error", errorHandler));
          ee.on("response", () => cachek.removeListener("error", errorHandler));
        }
        try {
          await get(options);
        } catch (error) {
          if (options.automaticFailover && !madeRequest) {
            makeRequest(options);
          }
          ee.emit("error", new CacheError2(error));
        }
      })();
      return ee;
    };
    this.addHook = (name, function_) => {
      if (!this.hooks.has(name)) {
        this.hooks.set(name, function_);
      }
    };
    this.removeHook = (name) => this.hooks.delete(name);
    this.getHook = (name) => this.hooks.get(name);
    this.runHook = async (name, ...arguments_) => this.hooks.get(name)?.(...arguments_);
    if (cacheAdapter instanceof import_keyv.default) {
      this.cache = cacheAdapter;
    } else if (typeof cacheAdapter === "string") {
      this.cache = new import_keyv.default({
        uri: cacheAdapter,
        namespace: "cacheable-request"
      });
    } else {
      this.cache = new import_keyv.default({
        store: cacheAdapter,
        namespace: "cacheable-request"
      });
    }
    this.request = this.request.bind(this);
    this.cacheRequest = cacheRequest;
  }
};
var entries = Object.entries;
var cloneResponse = /* @__PURE__ */ __name((response) => {
  const clone = new PassThroughStream({ autoDestroy: false });
  mimicResponse(response, clone);
  return response.pipe(clone);
}, "cloneResponse");
var urlObjectToRequestOptions = /* @__PURE__ */ __name((url) => {
  const options = { ...url };
  options.path = `${url.pathname || "/"}${url.search || ""}`;
  delete options.pathname;
  delete options.search;
  return options;
}, "urlObjectToRequestOptions");
var normalizeUrlObject = /* @__PURE__ */ __name((url) => (
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  {
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || "localhost",
    port: url.port,
    pathname: url.pathname,
    search: url.search
  }
), "normalizeUrlObject");
var convertHeaders = /* @__PURE__ */ __name((headers) => {
  const result = [];
  for (const name of Object.keys(headers)) {
    result[name.toLowerCase()] = headers[name];
  }
  return result;
}, "convertHeaders");
var dist_default = CacheableRequest;

// node_modules/got/dist/source/core/index.js
var import_decompress_response = __toESM(require_decompress_response(), 1);

// node_modules/got/node_modules/form-data-encoder/lib/index.js
init_esm();
var __typeError = /* @__PURE__ */ __name((msg) => {
  throw TypeError(msg);
}, "__typeError");
var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
var __privateAdd = /* @__PURE__ */ __name((obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), "__privateAdd");
var __privateSet = /* @__PURE__ */ __name((obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), "__privateSet");
var __privateMethod = /* @__PURE__ */ __name((obj, member, method) => (__accessCheck(obj, member, "access private method"), method), "__privateMethod");
var MAX_CHUNK_SIZE = 65536;
function* chunk(value) {
  if (value.byteLength <= MAX_CHUNK_SIZE) {
    yield value;
    return;
  }
  let offset = 0;
  while (offset < value.byteLength) {
    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);
    const buffer = value.buffer.slice(offset, offset + size);
    offset += buffer.byteLength;
    yield new Uint8Array(buffer);
  }
}
__name(chunk, "chunk");
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}
__name(createBoundary, "createBoundary");
var escapeName = /* @__PURE__ */ __name((name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22"), "escapeName");
var isFunction2 = /* @__PURE__ */ __name((value) => typeof value === "function", "isFunction");
var isReadableStreamFallback = /* @__PURE__ */ __name((value) => !!value && typeof value === "object" && !Array.isArray(value) && isFunction2(value.getReader), "isReadableStreamFallback");
var isAsyncIterable2 = /* @__PURE__ */ __name((value) => isFunction2(value[Symbol.asyncIterator]), "isAsyncIterable");
async function* readStream(readable) {
  const reader = readable.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    yield value;
  }
}
__name(readStream, "readStream");
async function* chunkStream(stream2) {
  for await (const value of stream2) {
    yield* chunk(value);
  }
}
__name(chunkStream, "chunkStream");
var getStreamIterator = /* @__PURE__ */ __name((source) => {
  if (isAsyncIterable2(source)) {
    return chunkStream(source);
  }
  if (isReadableStreamFallback(source)) {
    return chunkStream(readStream(source));
  }
  throw new TypeError(
    "Unsupported data source: Expected either ReadableStream or async iterable."
  );
}, "getStreamIterator");
var isFile = /* @__PURE__ */ __name((value) => Boolean(
  value && typeof value === "object" && isFunction2(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction2(value.stream) && value.name != null
), "isFile");
var isFormData2 = /* @__PURE__ */ __name((value) => Boolean(
  value && isFunction2(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction2(value.append) && isFunction2(value.getAll) && isFunction2(value.entries) && isFunction2(value[Symbol.iterator])
), "isFormData");
var getType = /* @__PURE__ */ __name((value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase(), "getType");
function isPlainObject2(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  return pp.constructor?.toString?.() === Object.toString();
}
__name(isPlainObject2, "isPlainObject");
var normalizeValue = /* @__PURE__ */ __name((value) => String(value).replace(/\r|\n/g, (match, i2, str) => {
  if (match === "\r" && str[i2 + 1] !== "\n" || match === "\n" && str[i2 - 1] !== "\r") {
    return "\r\n";
  }
  return match;
}), "normalizeValue");
function getProperty(target, prop) {
  if (typeof prop === "string") {
    for (const [name, value] of Object.entries(target)) {
      if (prop.toLowerCase() === name.toLowerCase()) {
        return value;
      }
    }
  }
  return void 0;
}
__name(getProperty, "getProperty");
var proxyHeaders = /* @__PURE__ */ __name((object) => new Proxy(
  object,
  {
    get: /* @__PURE__ */ __name((target, prop) => getProperty(target, prop), "get"),
    has: /* @__PURE__ */ __name((target, prop) => getProperty(target, prop) !== void 0, "has")
  }
), "proxyHeaders");
var defaultOptions = {
  enableAdditionalHeaders: false
};
var readonlyProp = { writable: false, configurable: false };
var _CRLF;
var _CRLF_BYTES;
var _CRLF_BYTES_LENGTH;
var _DASHES;
var _encoder;
var _footer;
var _form;
var _options;
var _FormDataEncoder_instances;
var getFieldHeader_fn;
var getContentLength_fn;
var FormDataEncoder = class {
  static {
    __name(this, "FormDataEncoder");
  }
  constructor(form, boundaryOrOptions, options) {
    __privateAdd(this, _FormDataEncoder_instances);
    __privateAdd(this, _CRLF, "\r\n");
    __privateAdd(this, _CRLF_BYTES);
    __privateAdd(this, _CRLF_BYTES_LENGTH);
    __privateAdd(this, _DASHES, "-".repeat(2));
    __privateAdd(this, _encoder, new TextEncoder());
    __privateAdd(this, _footer);
    __privateAdd(this, _form);
    __privateAdd(this, _options);
    if (!isFormData2(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject2(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = `form-data-encoder-${createBoundary()}`;
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject2(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __privateSet(this, _form, Array.from(form.entries()));
    __privateSet(this, _options, { ...defaultOptions, ...options });
    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));
    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);
    this.boundary = boundary;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __privateSet(this, _footer, __privateGet(this, _encoder).encode(
      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`
    ));
    const headers = {
      "Content-Type": this.contentType
    };
    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);
    if (contentLength) {
      this.contentLength = contentLength;
      headers["Content-Length"] = contentLength;
    }
    this.headers = proxyHeaders(Object.freeze(headers));
    Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  /**
   * Creates an iterator allowing to go through form-data parts (with metadata).
   * This method **will not** read the files and **will not** split values big into smaller chunks.
   *
   * Using this method, you can convert form-data content into Blob:
   *
   * @example
   *
   * ```ts
   * import {Readable} from "stream"
   *
   * import {FormDataEncoder} from "form-data-encoder"
   *
   * import {FormData} from "formdata-polyfill/esm-min.js"
   * import {fileFrom} from "fetch-blob/form.js"
   * import {File} from "fetch-blob/file.js"
   * import {Blob} from "fetch-blob"
   *
   * import fetch from "node-fetch"
   *
   * const form = new FormData()
   *
   * form.set("field", "Just a random string")
   * form.set("file", new File(["Using files is class amazing"]))
   * form.set("fileFromPath", await fileFrom("path/to/a/file.txt"))
   *
   * const encoder = new FormDataEncoder(form)
   *
   * const options = {
   *   method: "post",
   *   body: new Blob(encoder, {type: encoder.contentType})
   * }
   *
   * const response = await fetch("https://httpbin.org/post", options)
   *
   * console.log(await response.json())
   * ```
   */
  *values() {
    for (const [name, raw] of __privateGet(this, _form)) {
      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);
      yield value;
      yield __privateGet(this, _CRLF_BYTES);
    }
    yield __privateGet(this, _footer);
  }
  /**
   * Creates an async iterator allowing to perform the encoding by portions.
   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).
   *
   * @example
   *
   * ```ts
   * import {Readable} from "stream"
   *
   * import {FormData, File, fileFromPath} from "formdata-node"
   * import {FormDataEncoder} from "form-data-encoder"
   *
   * import fetch from "node-fetch"
   *
   * const form = new FormData()
   *
   * form.set("field", "Just a random string")
   * form.set("file", new File(["Using files is class amazing"], "file.txt"))
   * form.set("fileFromPath", await fileFromPath("path/to/a/file.txt"))
   *
   * const encoder = new FormDataEncoder(form)
   *
   * const options = {
   *   method: "post",
   *   headers: encoder.headers,
   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)
   * }
   *
   * const response = await fetch("https://httpbin.org/post", options)
   *
   * console.log(await response.json())
   * ```
   */
  async *encode() {
    for (const part of this.values()) {
      if (isFile(part)) {
        yield* getStreamIterator(part.stream());
      } else {
        yield* chunk(part);
      }
    }
  }
  /**
   * Creates an iterator allowing to read through the encoder data using for...of loops
   */
  [Symbol.iterator]() {
    return this.values();
  }
  /**
   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops
   */
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};
_CRLF = /* @__PURE__ */ new WeakMap();
_CRLF_BYTES = /* @__PURE__ */ new WeakMap();
_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap();
_DASHES = /* @__PURE__ */ new WeakMap();
_encoder = /* @__PURE__ */ new WeakMap();
_footer = /* @__PURE__ */ new WeakMap();
_form = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_FormDataEncoder_instances = /* @__PURE__ */ new WeakSet();
getFieldHeader_fn = /* @__PURE__ */ __name(function(name, value) {
  let header = "";
  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;
  header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
  if (isFile(value)) {
    header += `; filename="${escapeName(value.name)}"${__privateGet(this, _CRLF)}`;
    header += `Content-Type: ${value.type || "application/octet-stream"}`;
  }
  if (__privateGet(this, _options).enableAdditionalHeaders === true) {
    const size = isFile(value) ? value.size : value.byteLength;
    if (size != null && !isNaN(size)) {
      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;
    }
  }
  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);
}, "getFieldHeader_fn");
getContentLength_fn = /* @__PURE__ */ __name(function() {
  let length = 0;
  for (const [name, raw] of __privateGet(this, _form)) {
    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
    const size = isFile(value) ? value.size : value.byteLength;
    if (size == null || isNaN(size)) {
      return void 0;
    }
    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;
    length += size;
    length += __privateGet(this, _CRLF_BYTES_LENGTH);
  }
  return String(length + __privateGet(this, _footer).byteLength);
}, "getContentLength_fn");

// node_modules/got/dist/source/core/utils/get-body-size.js
init_esm();
import { Buffer as Buffer2 } from "node:buffer";
import { promisify } from "node:util";

// node_modules/got/dist/source/core/utils/is-form-data.js
init_esm();
function isFormData3(body) {
  return distribution_default.nodeStream(body) && distribution_default.function(body.getBoundary);
}
__name(isFormData3, "isFormData");

// node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && "content-length" in headers) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (distribution_default.string(body)) {
    return Buffer2.byteLength(body);
  }
  if (distribution_default.buffer(body)) {
    return body.length;
  }
  if (isFormData3(body)) {
    return promisify(body.getLength.bind(body))();
  }
  return void 0;
}
__name(getBodySize, "getBodySize");

// node_modules/got/dist/source/core/utils/proxy-events.js
init_esm();
function proxyEvents(from, to, events) {
  const eventFunctions = {};
  for (const event of events) {
    const eventFunction = /* @__PURE__ */ __name((...arguments_) => {
      to.emit(event, ...arguments_);
    }, "eventFunction");
    eventFunctions[event] = eventFunction;
    from.on(event, eventFunction);
  }
  return () => {
    for (const [event, eventFunction] of Object.entries(eventFunctions)) {
      from.off(event, eventFunction);
    }
  };
}
__name(proxyEvents, "proxyEvents");

// node_modules/got/dist/source/core/timed-out.js
init_esm();
import net from "node:net";

// node_modules/got/dist/source/core/utils/unhandle.js
init_esm();
function unhandle() {
  const handlers = [];
  return {
    once(origin, event, function_) {
      origin.once(event, function_);
      handlers.push({ origin, event, fn: function_ });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}
__name(unhandle, "unhandle");

// node_modules/got/dist/source/core/timed-out.js
var reentry = Symbol("reentry");
var noop2 = /* @__PURE__ */ __name(() => {
}, "noop");
var TimeoutError2 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  event;
  code;
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    this.event = event;
    this.name = "TimeoutError";
    this.code = "ETIMEDOUT";
  }
};
function timedOut(request, delays, options) {
  if (reentry in request) {
    return noop2;
  }
  request[reentry] = true;
  const cancelers = [];
  const { once, unhandleAll } = unhandle();
  const handled = /* @__PURE__ */ new Map();
  const addTimeout = /* @__PURE__ */ __name((delay3, callback, event) => {
    const timeout = setTimeout(callback, delay3, delay3, event);
    timeout.unref?.();
    const cancel = /* @__PURE__ */ __name(() => {
      handled.set(event, true);
      clearTimeout(timeout);
    }, "cancel");
    cancelers.push(cancel);
    return cancel;
  }, "addTimeout");
  const { host, hostname } = options;
  const timeoutHandler = /* @__PURE__ */ __name((delay3, event) => {
    setTimeout(() => {
      if (!handled.has(event)) {
        request.destroy(new TimeoutError2(delay3, event));
      }
    }, 0);
  }, "timeoutHandler");
  const cancelTimeouts = /* @__PURE__ */ __name(() => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  }, "cancelTimeouts");
  request.once("error", (error) => {
    cancelTimeouts();
    if (request.listenerCount("error") === 0) {
      throw error;
    }
  });
  if (delays.request !== void 0) {
    const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (delays.socket !== void 0) {
    const { socket } = delays;
    const socketTimeoutHandler = /* @__PURE__ */ __name(() => {
      timeoutHandler(socket, "socket");
    }, "socketTimeoutHandler");
    request.setTimeout(socket, socketTimeoutHandler);
    cancelers.push(() => {
      request.removeListener("timeout", socketTimeoutHandler);
    });
  }
  const hasLookup = delays.lookup !== void 0;
  const hasConnect = delays.connect !== void 0;
  const hasSecureConnect = delays.secureConnect !== void 0;
  const hasSend = delays.send !== void 0;
  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
    once(request, "socket", (socket) => {
      const { socketPath } = request;
      if (socket.connecting) {
        const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? "") !== 0);
        if (hasLookup && !hasPath && socket.address().address === void 0) {
          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
          once(socket, "lookup", cancelTimeout);
        }
        if (hasConnect) {
          const timeConnect = /* @__PURE__ */ __name(() => addTimeout(delays.connect, timeoutHandler, "connect"), "timeConnect");
          if (hasPath) {
            once(socket, "connect", timeConnect());
          } else {
            once(socket, "lookup", (error) => {
              if (error === null) {
                once(socket, "connect", timeConnect());
              }
            });
          }
        }
        if (hasSecureConnect && options.protocol === "https:") {
          once(socket, "connect", () => {
            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
            once(socket, "secureConnect", cancelTimeout);
          });
        }
      }
      if (hasSend) {
        const timeRequest = /* @__PURE__ */ __name(() => addTimeout(delays.send, timeoutHandler, "send"), "timeRequest");
        if (socket.connecting) {
          once(socket, "connect", () => {
            once(request, "upload-complete", timeRequest());
          });
        } else {
          once(request, "upload-complete", timeRequest());
        }
      }
    });
  }
  if (delays.response !== void 0) {
    once(request, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once(request, "response", cancelTimeout);
    });
  }
  if (delays.read !== void 0) {
    once(request, "response", (response) => {
      const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
      once(response, "end", cancelTimeout);
    });
  }
  return cancelTimeouts;
}
__name(timedOut, "timedOut");

// node_modules/got/dist/source/core/utils/url-to-options.js
init_esm();
function urlToOptions(url) {
  url = url;
  const options = {
    protocol: url.protocol,
    hostname: distribution_default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: `${url.pathname || ""}${url.search || ""}`
  };
  if (distribution_default.string(url.port) && url.port.length > 0) {
    options.port = Number(url.port);
  }
  if (url.username || url.password) {
    options.auth = `${url.username || ""}:${url.password || ""}`;
  }
  return options;
}
__name(urlToOptions, "urlToOptions");

// node_modules/got/dist/source/core/utils/weakable-map.js
init_esm();
var WeakableMap = class {
  static {
    __name(this, "WeakableMap");
  }
  weakMap;
  map;
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
    this.map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
};

// node_modules/got/dist/source/core/calculate-retry-delay.js
init_esm();
var calculateRetryDelay = /* @__PURE__ */ __name(({ attemptCount, retryOptions, error, retryAfter, computedValue }) => {
  if (error.name === "RetryError") {
    return 1;
  }
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error.code);
  const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error.response) {
    if (retryAfter) {
      if (retryAfter > computedValue) {
        return 0;
      }
      return retryAfter;
    }
    if (error.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1e3, retryOptions.backoffLimit) + noise;
}, "calculateRetryDelay");
var calculate_retry_delay_default = calculateRetryDelay;

// node_modules/got/dist/source/core/options.js
init_esm();
import process2 from "node:process";
import { promisify as promisify3, inspect } from "node:util";
import { checkServerIdentity } from "node:tls";
import https from "node:https";
import http from "node:http";

// node_modules/cacheable-lookup/source/index.js
init_esm();
import {
  V4MAPPED,
  ADDRCONFIG,
  ALL,
  promises as dnsPromises,
  lookup as dnsLookup
} from "node:dns";
import { promisify as promisify2 } from "node:util";
import os from "node:os";
var { Resolver: AsyncResolver } = dnsPromises;
var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
var kExpires = Symbol("expires");
var supportsALL = typeof ALL === "number";
var verifyAgent = /* @__PURE__ */ __name((agent) => {
  if (!(agent && typeof agent.createConnection === "function")) {
    throw new Error("Expected an Agent instance as the first argument");
  }
}, "verifyAgent");
var map4to6 = /* @__PURE__ */ __name((entries3) => {
  for (const entry of entries3) {
    if (entry.family === 6) {
      continue;
    }
    entry.address = `::ffff:${entry.address}`;
    entry.family = 6;
  }
}, "map4to6");
var getIfaceInfo = /* @__PURE__ */ __name(() => {
  let has4 = false;
  let has6 = false;
  for (const device of Object.values(os.networkInterfaces())) {
    for (const iface of device) {
      if (iface.internal) {
        continue;
      }
      if (iface.family === "IPv6") {
        has6 = true;
      } else {
        has4 = true;
      }
      if (has4 && has6) {
        return { has4, has6 };
      }
    }
  }
  return { has4, has6 };
}, "getIfaceInfo");
var isIterable2 = /* @__PURE__ */ __name((map) => {
  return Symbol.iterator in map;
}, "isIterable");
var ignoreNoResultErrors = /* @__PURE__ */ __name((dnsPromise) => {
  return dnsPromise.catch((error) => {
    if (error.code === "ENODATA" || error.code === "ENOTFOUND" || error.code === "ENOENT") {
      return [];
    }
    throw error;
  });
}, "ignoreNoResultErrors");
var ttl = { ttl: true };
var all = { all: true };
var all4 = { all: true, family: 4 };
var all6 = { all: true, family: 6 };
var CacheableLookup = class {
  static {
    __name(this, "CacheableLookup");
  }
  constructor({
    cache = /* @__PURE__ */ new Map(),
    maxTtl = Infinity,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver(),
    lookup = dnsLookup
  } = {}) {
    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache;
    this._resolver = resolver;
    this._dnsLookup = lookup && promisify2(lookup);
    this.stats = {
      cache: 0,
      query: 0
    };
    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = promisify2(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = promisify2(this._resolver.resolve6.bind(this._resolver));
    }
    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = /* @__PURE__ */ new Set();
    this.fallbackDuration = fallbackDuration;
    if (fallbackDuration > 0) {
      const interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1e3);
      if (interval.unref) {
        interval.unref();
      }
      this._fallbackInterval = interval;
    }
    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear();
    this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (typeof options === "number") {
      options = {
        family: options
      };
    }
    if (!callback) {
      throw new Error("Callback must be a function.");
    }
    this.lookupAsync(hostname, options).then((result) => {
      if (options.all) {
        callback(null, result);
      } else {
        callback(null, result.address, result.family, result.expires, result.ttl, result.source);
      }
    }, callback);
  }
  async lookupAsync(hostname, options = {}) {
    if (typeof options === "number") {
      options = {
        family: options
      };
    }
    let cached = await this.query(hostname);
    if (options.family === 6) {
      const filtered = cached.filter((entry) => entry.family === 6);
      if (options.hints & V4MAPPED) {
        if (supportsALL && options.hints & ALL || filtered.length === 0) {
          map4to6(cached);
        } else {
          cached = filtered;
        }
      } else {
        cached = filtered;
      }
    } else if (options.family === 4) {
      cached = cached.filter((entry) => entry.family === 4);
    }
    if (options.hints & ADDRCONFIG) {
      const { _iface } = this;
      cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
      error.code = "ENOTFOUND";
      error.hostname = hostname;
      throw error;
    }
    if (options.all) {
      return cached;
    }
    return cached[0];
  }
  async query(hostname) {
    let source = "cache";
    let cached = await this._cache.get(hostname);
    if (cached) {
      this.stats.cache++;
    }
    if (!cached) {
      const pending = this._pending[hostname];
      if (pending) {
        this.stats.cache++;
        cached = await pending;
      } else {
        source = "query";
        const newPromise = this.queryAndCache(hostname);
        this._pending[hostname] = newPromise;
        this.stats.query++;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname];
        }
      }
    }
    cached = cached.map((entry) => {
      return { ...entry, source };
    });
    return cached;
  }
  async _resolve(hostname) {
    const [A, AAAA] = await Promise.all([
      ignoreNoResultErrors(this._resolve4(hostname, ttl)),
      ignoreNoResultErrors(this._resolve6(hostname, ttl))
    ]);
    let aTtl = 0;
    let aaaaTtl = 0;
    let cacheTtl = 0;
    const now = Date.now();
    for (const entry of A) {
      entry.family = 4;
      entry.expires = now + entry.ttl * 1e3;
      aTtl = Math.max(aTtl, entry.ttl);
    }
    for (const entry of AAAA) {
      entry.family = 6;
      entry.expires = now + entry.ttl * 1e3;
      aaaaTtl = Math.max(aaaaTtl, entry.ttl);
    }
    if (A.length > 0) {
      if (AAAA.length > 0) {
        cacheTtl = Math.min(aTtl, aaaaTtl);
      } else {
        cacheTtl = aTtl;
      }
    } else {
      cacheTtl = aaaaTtl;
    }
    return {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname) {
    try {
      const [A, AAAA] = await Promise.all([
        // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
        // See https://github.com/szmarczak/cacheable-lookup/issues/42
        ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
        ignoreNoResultErrors(this._dnsLookup(hostname, all6))
      ]);
      return {
        entries: [
          ...A,
          ...AAAA
        ],
        cacheTtl: 0
      };
    } catch {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
      data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname, data, cacheTtl);
      } catch (error) {
        this.lookupAsync = async () => {
          const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          cacheError.cause = error;
          throw cacheError;
        };
      }
      if (isIterable2(this._cache)) {
        this._tick(cacheTtl);
      }
    }
  }
  async queryAndCache(hostname) {
    if (this._hostnamesToFallback.has(hostname)) {
      return this._dnsLookup(hostname, all);
    }
    let query = await this._resolve(hostname);
    if (query.entries.length === 0 && this._dnsLookup) {
      query = await this._lookup(hostname);
      if (query.entries.length !== 0 && this.fallbackDuration > 0) {
        this._hostnamesToFallback.add(hostname);
      }
    }
    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
    await this._set(hostname, query.entries, cacheTtl);
    return query.entries;
  }
  _tick(ms) {
    const nextRemovalTime = this._nextRemovalTime;
    if (!nextRemovalTime || ms < nextRemovalTime) {
      clearTimeout(this._removalTimeout);
      this._nextRemovalTime = ms;
      this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = false;
        let nextExpiry = Infinity;
        const now = Date.now();
        for (const [hostname, entries3] of this._cache) {
          const expires = entries3[kExpires];
          if (now >= expires) {
            this._cache.delete(hostname);
          } else if (expires < nextExpiry) {
            nextExpiry = expires;
          }
        }
        if (nextExpiry !== Infinity) {
          this._tick(nextExpiry - now);
        }
      }, ms);
      if (this._removalTimeout.unref) {
        this._removalTimeout.unref();
      }
    }
  }
  install(agent) {
    verifyAgent(agent);
    if (kCacheableLookupCreateConnection in agent) {
      throw new Error("CacheableLookup has been already installed");
    }
    agent[kCacheableLookupCreateConnection] = agent.createConnection;
    agent[kCacheableLookupInstance] = this;
    agent.createConnection = (options, callback) => {
      if (!("lookup" in options)) {
        options.lookup = this.lookup;
      }
      return agent[kCacheableLookupCreateConnection](options, callback);
    };
  }
  uninstall(agent) {
    verifyAgent(agent);
    if (agent[kCacheableLookupCreateConnection]) {
      if (agent[kCacheableLookupInstance] !== this) {
        throw new Error("The agent is not owned by this CacheableLookup instance");
      }
      agent.createConnection = agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupCreateConnection];
      delete agent[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    const { _iface } = this;
    this._iface = getIfaceInfo();
    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
      this._cache.clear();
    }
  }
  clear(hostname) {
    if (hostname) {
      this._cache.delete(hostname);
      return;
    }
    this._cache.clear();
  }
};

// node_modules/got/dist/source/core/options.js
var import_http2_wrapper = __toESM(require_source2(), 1);

// node_modules/got/dist/source/core/parse-link-header.js
init_esm();
function parseLinkHeader(link) {
  const parsed = [];
  const items = link.split(",");
  for (const item of items) {
    const [rawUriReference, ...rawLinkParameters] = item.split(";");
    const trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference.at(-1) !== ">") {
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    }
    const reference = trimmedUriReference.slice(1, -1);
    const parameters = {};
    if (rawLinkParameters.length === 0) {
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    }
    for (const rawParameter of rawLinkParameters) {
      const trimmedRawParameter = rawParameter.trim();
      const center = trimmedRawParameter.indexOf("=");
      if (center === -1) {
        throw new Error(`Failed to parse Link header: ${link}`);
      }
      const name = trimmedRawParameter.slice(0, center).trim();
      const value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}
__name(parseLinkHeader, "parseLinkHeader");

// node_modules/got/dist/source/core/options.js
var [major, minor] = process2.versions.node.split(".").map(Number);
function validateSearchParameters(searchParameters) {
  for (const key in searchParameters) {
    const value = searchParameters[key];
    assert.any([distribution_default.string, distribution_default.number, distribution_default.boolean, distribution_default.null, distribution_default.undefined], value);
  }
}
__name(validateSearchParameters, "validateSearchParameters");
var globalCache = /* @__PURE__ */ new Map();
var globalDnsCache;
var getGlobalDnsCache = /* @__PURE__ */ __name(() => {
  if (globalDnsCache) {
    return globalDnsCache;
  }
  globalDnsCache = new CacheableLookup();
  return globalDnsCache;
}, "getGlobalDnsCache");
var defaultInternals = {
  request: void 0,
  agent: {
    http: void 0,
    https: void 0,
    http2: void 0
  },
  h2session: void 0,
  decompress: true,
  timeout: {
    connect: void 0,
    lookup: void 0,
    read: void 0,
    request: void 0,
    response: void 0,
    secureConnect: void 0,
    send: void 0,
    socket: void 0
  },
  prefixUrl: "",
  body: void 0,
  form: void 0,
  json: void 0,
  cookieJar: void 0,
  ignoreInvalidCookies: false,
  searchParams: void 0,
  dnsLookup: void 0,
  dnsCache: void 0,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    afterResponse: []
  },
  followRedirect: true,
  maxRedirects: 10,
  cache: void 0,
  throwHttpErrors: true,
  username: "",
  password: "",
  http2: false,
  allowGetBody: false,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: false,
  dnsLookupIpVersion: void 0,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: void 0,
    calculateDelay: /* @__PURE__ */ __name(({ computedValue }) => computedValue, "calculateDelay"),
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100
  },
  localAddress: void 0,
  method: "GET",
  createConnection: void 0,
  cacheOptions: {
    shared: void 0,
    cacheHeuristic: void 0,
    immutableMinTimeToLive: void 0,
    ignoreCargoCult: void 0
  },
  https: {
    alpnProtocols: void 0,
    rejectUnauthorized: void 0,
    checkServerIdentity: void 0,
    certificateAuthority: void 0,
    key: void 0,
    certificate: void 0,
    passphrase: void 0,
    pfx: void 0,
    ciphers: void 0,
    honorCipherOrder: void 0,
    minVersion: void 0,
    maxVersion: void 0,
    signatureAlgorithms: void 0,
    tlsSessionLifetime: void 0,
    dhparam: void 0,
    ecdhCurve: void 0,
    certificateRevocationLists: void 0
  },
  encoding: void 0,
  resolveBodyOnly: false,
  isStream: false,
  responseType: "text",
  url: void 0,
  pagination: {
    transform(response) {
      if (response.request.options.responseType === "json") {
        return response.body;
      }
      return JSON.parse(response.body);
    },
    paginate({ response }) {
      const rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") {
        return false;
      }
      const parsed = parseLinkHeader(rawLinkHeader);
      const next = parsed.find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      if (next) {
        return {
          url: new URL(next.reference, response.url)
        };
      }
      return false;
    },
    filter: /* @__PURE__ */ __name(() => true, "filter"),
    shouldContinue: /* @__PURE__ */ __name(() => true, "shouldContinue"),
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: false
  },
  setHost: true,
  maxHeaderSize: void 0,
  signal: void 0,
  enableUnixSockets: false
};
var cloneInternals = /* @__PURE__ */ __name((internals) => {
  const { hooks, retry } = internals;
  const result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : void 0,
    pagination: { ...internals.pagination }
  };
  if (result.url !== void 0) {
    result.prefixUrl = "";
  }
  return result;
}, "cloneInternals");
var cloneRaw = /* @__PURE__ */ __name((raw) => {
  const { hooks, retry } = raw;
  const result = { ...raw };
  if (distribution_default.object(raw.context)) {
    result.context = { ...raw.context };
  }
  if (distribution_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...raw.cacheOptions };
  }
  if (distribution_default.object(raw.https)) {
    result.https = { ...raw.https };
  }
  if (distribution_default.object(raw.cacheOptions)) {
    result.cacheOptions = { ...result.cacheOptions };
  }
  if (distribution_default.object(raw.agent)) {
    result.agent = { ...raw.agent };
  }
  if (distribution_default.object(raw.headers)) {
    result.headers = { ...raw.headers };
  }
  if (distribution_default.object(retry)) {
    result.retry = { ...retry };
    if (distribution_default.array(retry.errorCodes)) {
      result.retry.errorCodes = [...retry.errorCodes];
    }
    if (distribution_default.array(retry.methods)) {
      result.retry.methods = [...retry.methods];
    }
    if (distribution_default.array(retry.statusCodes)) {
      result.retry.statusCodes = [...retry.statusCodes];
    }
  }
  if (distribution_default.object(raw.timeout)) {
    result.timeout = { ...raw.timeout };
  }
  if (distribution_default.object(hooks)) {
    result.hooks = {
      ...hooks
    };
    if (distribution_default.array(hooks.init)) {
      result.hooks.init = [...hooks.init];
    }
    if (distribution_default.array(hooks.beforeRequest)) {
      result.hooks.beforeRequest = [...hooks.beforeRequest];
    }
    if (distribution_default.array(hooks.beforeError)) {
      result.hooks.beforeError = [...hooks.beforeError];
    }
    if (distribution_default.array(hooks.beforeRedirect)) {
      result.hooks.beforeRedirect = [...hooks.beforeRedirect];
    }
    if (distribution_default.array(hooks.beforeRetry)) {
      result.hooks.beforeRetry = [...hooks.beforeRetry];
    }
    if (distribution_default.array(hooks.afterResponse)) {
      result.hooks.afterResponse = [...hooks.afterResponse];
    }
  }
  if (distribution_default.object(raw.pagination)) {
    result.pagination = { ...raw.pagination };
  }
  return result;
}, "cloneRaw");
var getHttp2TimeoutOption = /* @__PURE__ */ __name((internals) => {
  const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay3) => typeof delay3 === "number");
  if (delays.length > 0) {
    return Math.min(...delays);
  }
  return void 0;
}, "getHttp2TimeoutOption");
var init = /* @__PURE__ */ __name((options, withOptions, self2) => {
  const initHooks = options.hooks?.init;
  if (initHooks) {
    for (const hook of initHooks) {
      hook(withOptions, self2);
    }
  }
}, "init");
var Options = class _Options {
  static {
    __name(this, "Options");
  }
  _unixOptions;
  _internals;
  _merging;
  _init;
  constructor(input, options, defaults2) {
    assert.any([distribution_default.string, distribution_default.urlInstance, distribution_default.object, distribution_default.undefined], input);
    assert.any([distribution_default.object, distribution_default.undefined], options);
    assert.any([distribution_default.object, distribution_default.undefined], defaults2);
    if (input instanceof _Options || options instanceof _Options) {
      throw new TypeError("The defaults must be passed as the third argument");
    }
    this._internals = cloneInternals(defaults2?._internals ?? defaults2 ?? defaultInternals);
    this._init = [...defaults2?._init ?? []];
    this._merging = false;
    this._unixOptions = void 0;
    try {
      if (distribution_default.plainObject(input)) {
        try {
          this.merge(input);
          this.merge(options);
        } finally {
          this.url = input.url;
        }
      } else {
        try {
          this.merge(options);
        } finally {
          if (options?.url !== void 0) {
            if (input === void 0) {
              this.url = options.url;
            } else {
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            }
          } else if (input !== void 0) {
            this.url = input;
          }
        }
      }
    } catch (error) {
      error.options = this;
      throw error;
    }
  }
  merge(options) {
    if (!options) {
      return;
    }
    if (options instanceof _Options) {
      const initArray = [...options._init];
      for (const init2 of initArray) {
        this.merge(init2);
      }
      return;
    }
    options = cloneRaw(options);
    init(this, options, this);
    init(options, options, this);
    this._merging = true;
    if ("isStream" in options) {
      this.isStream = options.isStream;
    }
    try {
      let push = false;
      for (const key in options) {
        if (key === "mutableDefaults" || key === "handlers") {
          continue;
        }
        if (key === "url") {
          continue;
        }
        if (!(key in this)) {
          throw new Error(`Unexpected option: ${key}`);
        }
        const value = options[key];
        if (value === void 0) {
          continue;
        }
        this[key] = value;
        push = true;
      }
      if (push) {
        this._init.push(options);
      }
    } finally {
      this._merging = false;
    }
  }
  /**
      Custom request function.
      The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
  
      @default http.request | https.request
      */
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assert.any([distribution_default.function, distribution_default.undefined], value);
    this._internals.request = value;
  }
  /**
      An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
      This is necessary because a request to one protocol might redirect to another.
      In such a scenario, Got will switch over to the right protocol agent for you.
  
      If a key is not present, it will default to a global agent.
  
      @example
      ```
      import got from 'got';
      import HttpAgent from 'agentkeepalive';
  
      const {HttpsAgent} = HttpAgent;
  
      await got('https://sindresorhus.com', {
          agent: {
              http: new HttpAgent(),
              https: new HttpsAgent()
          }
      });
      ```
      */
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.agent)) {
        throw new TypeError(`Unexpected agent option: ${key}`);
      }
      assert.any([distribution_default.object, distribution_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.agent, value);
    } else {
      this._internals.agent = { ...value };
    }
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  /**
      Decompress the response automatically.
  
      This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
  
      If this is disabled, a compressed response is returned as a `Buffer`.
      This may be useful if you want to handle decompression yourself or stream the raw compressed data.
  
      @default true
      */
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert.boolean(value);
    this._internals.decompress = value;
  }
  /**
      Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
      By default, there's no timeout.
  
      This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
  
      - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
          Does not apply when using a Unix domain socket.
      - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
      - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
      - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
      - `response` starts when the request has been written to the socket and ends when the response headers are received.
      - `send` starts when the socket is connected and ends with the request has been written to the socket.
      - `request` starts when the request is initiated and ends when the response's end event fires.
      */
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.timeout)) {
        throw new Error(`Unexpected timeout option: ${key}`);
      }
      assert.any([distribution_default.number, distribution_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.timeout, value);
    } else {
      this._internals.timeout = { ...value };
    }
  }
  /**
      When specified, `prefixUrl` will be prepended to `url`.
      The prefix can be any valid URL, either relative or absolute.
      A trailing slash `/` is optional - one will be added automatically.
  
      __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
  
      __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
      For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
      The latter is used by browsers.
  
      __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
  
      __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
      If the URL doesn't include it anymore, it will throw.
  
      @example
      ```
      import got from 'got';
  
      await got('unicorn', {prefixUrl: 'https://cats.com'});
      //=> 'https://cats.com/unicorn'
  
      const instance = got.extend({
          prefixUrl: 'https://google.com'
      });
  
      await instance('unicorn', {
          hooks: {
              beforeRequest: [
                  options => {
                      options.prefixUrl = 'https://cats.com';
                  }
              ]
          }
      });
      //=> 'https://cats.com/unicorn'
      ```
      */
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    assert.any([distribution_default.string, distribution_default.urlInstance], value);
    if (value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    value = value.toString();
    if (!value.endsWith("/")) {
      value += "/";
    }
    if (this._internals.prefixUrl && this._internals.url) {
      const { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  /**
      __Note #1__: The `body` option cannot be used with the `json` or `form` option.
  
      __Note #2__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
  
      __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
  
      The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
  
      Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
      */
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assert.any([distribution_default.string, distribution_default.buffer, distribution_default.nodeStream, distribution_default.generator, distribution_default.asyncGenerator, isFormData2, distribution_default.undefined], value);
    if (distribution_default.nodeStream(value)) {
      assert.truthy(value.readable);
    }
    if (value !== void 0) {
      assert.undefined(this._internals.form);
      assert.undefined(this._internals.json);
    }
    this._internals.body = value;
  }
  /**
      The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
  
      If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assert.any([distribution_default.plainObject, distribution_default.undefined], value);
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.json);
    }
    this._internals.form = value;
  }
  /**
      JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get json() {
    return this._internals.json;
  }
  set json(value) {
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.form);
    }
    this._internals.json = value;
  }
  /**
      The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
  
      Properties from `options` will override properties in the parsed `url`.
  
      If no protocol is specified, it will throw a `TypeError`.
  
      __Note__: The query string is **not** parsed as search params.
  
      @example
      ```
      await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
      await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
  
      // The query string is overridden by `searchParams`
      await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
      ```
      */
  get url() {
    return this._internals.url;
  }
  set url(value) {
    assert.any([distribution_default.string, distribution_default.urlInstance, distribution_default.undefined], value);
    if (value === void 0) {
      this._internals.url = void 0;
      return;
    }
    if (distribution_default.string(value) && value.startsWith("/")) {
      throw new Error("`url` must not start with a slash");
    }
    const urlString = `${this.prefixUrl}${value.toString()}`;
    const url = new URL(urlString);
    this._internals.url = url;
    if (url.protocol === "unix:") {
      url.href = `http://unix${url.pathname}${url.search}`;
    }
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      const error = new Error(`Unsupported protocol: ${url.protocol}`);
      error.code = "ERR_UNSUPPORTED_PROTOCOL";
      throw error;
    }
    if (this._internals.username) {
      url.username = this._internals.username;
      this._internals.username = "";
    }
    if (this._internals.password) {
      url.password = this._internals.password;
      this._internals.password = "";
    }
    if (this._internals.searchParams) {
      url.search = this._internals.searchParams.toString();
      this._internals.searchParams = void 0;
    }
    if (url.hostname === "unix") {
      if (!this._internals.enableUnixSockets) {
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      }
      const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
      if (matches?.groups) {
        const { socketPath, path: path2 } = matches.groups;
        this._unixOptions = {
          socketPath,
          path: path2,
          host: ""
        };
      } else {
        this._unixOptions = void 0;
      }
      return;
    }
    this._unixOptions = void 0;
  }
  /**
      Cookie support. You don't have to care about parsing or how to store them.
  
      __Note__: If you provide this option, `options.headers.cookie` will be overridden.
      */
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    assert.any([distribution_default.object, distribution_default.undefined], value);
    if (value === void 0) {
      this._internals.cookieJar = void 0;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert.function(setCookie);
    assert.function(getCookieString);
    if (setCookie.length === 4 && getCookieString.length === 0) {
      setCookie = promisify3(setCookie.bind(value));
      getCookieString = promisify3(getCookieString.bind(value));
      this._internals.cookieJar = {
        setCookie,
        getCookieString
      };
    } else {
      this._internals.cookieJar = value;
    }
  }
  /**
      You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
  
      @example
      ```
      import got from 'got';
  
      const abortController = new AbortController();
  
      const request = got('https://httpbin.org/anything', {
          signal: abortController.signal
      });
  
      setTimeout(() => {
          abortController.abort();
      }, 100);
      ```
      */
  get signal() {
    return this._internals.signal;
  }
  set signal(value) {
    assert.object(value);
    this._internals.signal = value;
  }
  /**
      Ignore invalid cookies instead of throwing an error.
      Only useful when the `cookieJar` option has been set. Not recommended.
  
      @default false
      */
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert.boolean(value);
    this._internals.ignoreInvalidCookies = value;
  }
  /**
      Query string that will be added to the request URL.
      This will override the query string in `url`.
  
      If you need to pass in an array, you can do it using a `URLSearchParams` instance.
  
      @example
      ```
      import got from 'got';
  
      const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
  
      await got('https://example.com', {searchParams});
  
      console.log(searchParams.toString());
      //=> 'key=a&key=b'
      ```
      */
  get searchParams() {
    if (this._internals.url) {
      return this._internals.url.searchParams;
    }
    if (this._internals.searchParams === void 0) {
      this._internals.searchParams = new URLSearchParams();
    }
    return this._internals.searchParams;
  }
  set searchParams(value) {
    assert.any([distribution_default.string, distribution_default.object, distribution_default.undefined], value);
    const url = this._internals.url;
    if (value === void 0) {
      this._internals.searchParams = void 0;
      if (url) {
        url.search = "";
      }
      return;
    }
    const searchParameters = this.searchParams;
    let updated;
    if (distribution_default.string(value)) {
      updated = new URLSearchParams(value);
    } else if (value instanceof URLSearchParams) {
      updated = value;
    } else {
      validateSearchParameters(value);
      updated = new URLSearchParams();
      for (const key in value) {
        const entry = value[key];
        if (entry === null) {
          updated.append(key, "");
        } else if (entry === void 0) {
          searchParameters.delete(key);
        } else {
          updated.append(key, entry);
        }
      }
    }
    if (this._merging) {
      for (const key of updated.keys()) {
        searchParameters.delete(key);
      }
      for (const [key, value2] of updated) {
        searchParameters.append(key, value2);
      }
    } else if (url) {
      url.search = searchParameters.toString();
    } else {
      this._internals.searchParams = searchParameters;
    }
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assert.any([distribution_default.function, distribution_default.undefined], value);
    this._internals.dnsLookup = value;
  }
  /**
      An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
      Useful when making lots of requests to different *public* hostnames.
  
      `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
  
      __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
  
      @default false
      */
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assert.any([distribution_default.object, distribution_default.boolean, distribution_default.undefined], value);
    if (value === true) {
      this._internals.dnsCache = getGlobalDnsCache();
    } else if (value === false) {
      this._internals.dnsCache = void 0;
    } else {
      this._internals.dnsCache = value;
    }
  }
  /**
      User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
  
      @example
      ```
      import got from 'got';
  
      const instance = got.extend({
          hooks: {
              beforeRequest: [
                  options => {
                      if (!options.context || !options.context.token) {
                          throw new Error('Token required');
                      }
  
                      options.headers.token = options.context.token;
                  }
              ]
          }
      });
  
      const context = {
          token: 'secret'
      };
  
      const response = await instance('https://httpbin.org/headers', {context});
  
      // Let's see the headers
      console.log(response.body);
      ```
      */
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.context, value);
    } else {
      this._internals.context = { ...value };
    }
  }
  /**
  Hooks allow modifications during the request lifecycle.
  Hook functions may be async and are run serially.
  */
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert.object(value);
    for (const knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks)) {
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      }
      const typedKnownHookEvent = knownHookEvent;
      const hooks = value[typedKnownHookEvent];
      assert.any([distribution_default.array, distribution_default.undefined], hooks);
      if (hooks) {
        for (const hook of hooks) {
          assert.function(hook);
        }
      }
      if (this._merging) {
        if (hooks) {
          this._internals.hooks[typedKnownHookEvent].push(...hooks);
        }
      } else {
        if (!hooks) {
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        }
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  /**
      Whether redirect responses should be followed automatically.
  
      Optionally, pass a function to dynamically decide based on the response object.
  
      Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
      This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
  
      @default true
      */
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assert.any([distribution_default.boolean, distribution_default.function], value);
    this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  /**
      If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
  
      @default 10
      */
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert.number(value);
    this._internals.maxRedirects = value;
  }
  /**
      A cache adapter instance for storing cached response data.
  
      @default false
      */
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assert.any([distribution_default.object, distribution_default.string, distribution_default.boolean, distribution_default.undefined], value);
    if (value === true) {
      this._internals.cache = globalCache;
    } else if (value === false) {
      this._internals.cache = void 0;
    } else {
      this._internals.cache = value;
    }
  }
  /**
      Determines if a `got.HTTPError` is thrown for unsuccessful responses.
  
      If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
      This may be useful if you are checking for resource availability and are expecting error responses.
  
      @default true
      */
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert.boolean(value);
    this._internals.throwHttpErrors = value;
  }
  get username() {
    const url = this._internals.url;
    const value = url ? url.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.username = fixedValue;
    } else {
      this._internals.username = fixedValue;
    }
  }
  get password() {
    const url = this._internals.url;
    const value = url ? url.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.password = fixedValue;
    } else {
      this._internals.password = fixedValue;
    }
  }
  /**
      If set to `true`, Got will additionally accept HTTP2 requests.
  
      It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
  
      __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
  
      __Note__: Overriding `options.request` will disable HTTP2 support.
  
      @default false
  
      @example
      ```
      import got from 'got';
  
      const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
  
      console.log(headers.via);
      //=> '2 nghttpx'
      ```
      */
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert.boolean(value);
    this._internals.http2 = value;
  }
  /**
      Set this to `true` to allow sending body for the `GET` method.
      However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
      This option is only meant to interact with non-compliant servers when you have no other choice.
  
      __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
  
      @default false
      */
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert.boolean(value);
    this._internals.allowGetBody = value;
  }
  /**
      Request headers.
  
      Existing headers will be overwritten. Headers set to `undefined` will be omitted.
  
      @default {}
      */
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assert.plainObject(value);
    if (this._merging) {
      Object.assign(this._internals.headers, lowercaseKeys(value));
    } else {
      this._internals.headers = lowercaseKeys(value);
    }
  }
  /**
      Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
  
      As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
      Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
  
      __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
  
      @default false
      */
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert.boolean(value);
    this._internals.methodRewriting = value;
  }
  /**
      Indicates which DNS record family to use.
  
      Values:
      - `undefined`: IPv4 (if present) or IPv6
      - `4`: Only IPv4
      - `6`: Only IPv6
  
      @default undefined
      */
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== void 0 && value !== 4 && value !== 6) {
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    }
    this._internals.dnsLookupIpVersion = value;
  }
  /**
      A function used to parse JSON responses.
  
      @example
      ```
      import got from 'got';
      import Bourne from '@hapi/bourne';
  
      const parsed = await got('https://example.com', {
          parseJson: text => Bourne.parse(text)
      }).json();
  
      console.log(parsed);
      ```
      */
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert.function(value);
    this._internals.parseJson = value;
  }
  /**
      A function used to stringify the body of JSON requests.
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (key.startsWith('_')) {
                  return;
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              _ignoreMe: 1234
          }
      });
      ```
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (typeof value === 'number') {
                  return value.toString();
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              number: 1
          }
      });
      ```
      */
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert.function(value);
    this._internals.stringifyJson = value;
  }
  /**
      An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
  
      Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
  
      The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
      The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
  
      __Note:__ When you provide `calculateDelay`, you take full control of retry decisions. The `limit` option is not automatically enforced - you must check `attemptCount` yourself or return `0` when `computedValue` is `0` to respect the default retry logic.
  
      By default, it retries *only* on the specified methods, status codes, and on these network errors:
  
      - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
      - `ECONNRESET`: Connection was forcibly closed by a peer.
      - `EADDRINUSE`: Could not bind to any free port.
      - `ECONNREFUSED`: Connection was refused by the server.
      - `EPIPE`: The remote side of the stream being written has been closed.
      - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
      - `ENETUNREACH`: No internet connection.
      - `EAI_AGAIN`: DNS lookup timed out.
  
      __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
      __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
      */
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    assert.plainObject(value);
    assert.any([distribution_default.function, distribution_default.undefined], value.calculateDelay);
    assert.any([distribution_default.number, distribution_default.undefined], value.maxRetryAfter);
    assert.any([distribution_default.number, distribution_default.undefined], value.limit);
    assert.any([distribution_default.array, distribution_default.undefined], value.methods);
    assert.any([distribution_default.array, distribution_default.undefined], value.statusCodes);
    assert.any([distribution_default.array, distribution_default.undefined], value.errorCodes);
    assert.any([distribution_default.number, distribution_default.undefined], value.noise);
    if (value.noise && Math.abs(value.noise) > 100) {
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    }
    for (const key in value) {
      if (!(key in this._internals.retry)) {
        throw new Error(`Unexpected retry option: ${key}`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.retry, value);
    } else {
      this._internals.retry = { ...value };
    }
    const { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))];
    retry.statusCodes = [...new Set(retry.statusCodes)];
    retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  /**
      From `http.RequestOptions`.
  
      The IP address used to send the request from.
      */
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assert.any([distribution_default.string, distribution_default.undefined], value);
    this._internals.localAddress = value;
  }
  /**
      The HTTP method used to make the request.
  
      @default 'GET'
      */
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert.string(value);
    this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assert.any([distribution_default.function, distribution_default.undefined], value);
    this._internals.createConnection = value;
  }
  /**
      From `http-cache-semantics`
  
      @default {}
      */
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assert.plainObject(value);
    assert.any([distribution_default.boolean, distribution_default.undefined], value.shared);
    assert.any([distribution_default.number, distribution_default.undefined], value.cacheHeuristic);
    assert.any([distribution_default.number, distribution_default.undefined], value.immutableMinTimeToLive);
    assert.any([distribution_default.boolean, distribution_default.undefined], value.ignoreCargoCult);
    for (const key in value) {
      if (!(key in this._internals.cacheOptions)) {
        throw new Error(`Cache option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.cacheOptions, value);
    } else {
      this._internals.cacheOptions = { ...value };
    }
  }
  /**
  Options for the advanced HTTPS API.
  */
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assert.plainObject(value);
    assert.any([distribution_default.boolean, distribution_default.undefined], value.rejectUnauthorized);
    assert.any([distribution_default.function, distribution_default.undefined], value.checkServerIdentity);
    assert.any([distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.certificateAuthority);
    assert.any([distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.key);
    assert.any([distribution_default.string, distribution_default.object, distribution_default.array, distribution_default.undefined], value.certificate);
    assert.any([distribution_default.string, distribution_default.undefined], value.passphrase);
    assert.any([distribution_default.string, distribution_default.buffer, distribution_default.array, distribution_default.undefined], value.pfx);
    assert.any([distribution_default.array, distribution_default.undefined], value.alpnProtocols);
    assert.any([distribution_default.string, distribution_default.undefined], value.ciphers);
    assert.any([distribution_default.string, distribution_default.buffer, distribution_default.undefined], value.dhparam);
    assert.any([distribution_default.string, distribution_default.undefined], value.signatureAlgorithms);
    assert.any([distribution_default.string, distribution_default.undefined], value.minVersion);
    assert.any([distribution_default.string, distribution_default.undefined], value.maxVersion);
    assert.any([distribution_default.boolean, distribution_default.undefined], value.honorCipherOrder);
    assert.any([distribution_default.number, distribution_default.undefined], value.tlsSessionLifetime);
    assert.any([distribution_default.string, distribution_default.undefined], value.ecdhCurve);
    assert.any([distribution_default.string, distribution_default.buffer, distribution_default.array, distribution_default.undefined], value.certificateRevocationLists);
    for (const key in value) {
      if (!(key in this._internals.https)) {
        throw new Error(`HTTPS option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.https, value);
    } else {
      this._internals.https = { ...value };
    }
  }
  /**
      [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
  
      To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
      Don't set this option to `null`.
  
      __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
  
      @default 'utf-8'
      */
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null) {
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    }
    assert.any([distribution_default.string, distribution_default.undefined], value);
    this._internals.encoding = value;
  }
  /**
      When set to `true` the promise will return the Response body instead of the Response object.
  
      @default false
      */
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert.boolean(value);
    this._internals.resolveBodyOnly = value;
  }
  /**
      Returns a `Stream` instead of a `Promise`.
      This is equivalent to calling `got.stream(url, options?)`.
  
      @default false
      */
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert.boolean(value);
    this._internals.isStream = value;
  }
  /**
      The parsing method.
  
      The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
  
      It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
  
      __Note__: When using streams, this option is ignored.
  
      @example
      ```
      const responsePromise = got(url);
      const bufferPromise = responsePromise.buffer();
      const jsonPromise = responsePromise.json();
  
      const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
      // `response` is an instance of Got Response
      // `buffer` is an instance of Buffer
      // `json` is an object
      ```
  
      @example
      ```
      // This
      const body = await got(url).json();
  
      // is semantically the same as this
      const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
      ```
      */
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === void 0) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json") {
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    }
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.pagination, value);
    } else {
      this._internals.pagination = value;
    }
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert.boolean(value);
    this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assert.any([distribution_default.number, distribution_default.undefined], value);
    this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert.boolean(value);
    this._internals.enableUnixSockets = value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toJSON() {
    return { ...this._internals };
  }
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return inspect(this._internals, options);
  }
  createNativeRequestOptions() {
    const internals = this._internals;
    const url = internals.url;
    let agent;
    if (url.protocol === "https:") {
      agent = internals.http2 ? internals.agent : internals.agent.https;
    } else {
      agent = internals.agent.http;
    }
    const { https: https2 } = internals;
    let { pfx } = https2;
    if (distribution_default.array(pfx) && distribution_default.plainObject(pfx[0])) {
      pfx = pfx.map((object) => ({
        buf: object.buffer,
        passphrase: object.passphrase
      }));
    }
    return {
      ...internals.cacheOptions,
      ...this._unixOptions,
      // HTTPS options
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ALPNProtocols: https2.alpnProtocols,
      ca: https2.certificateAuthority,
      cert: https2.certificate,
      key: https2.key,
      passphrase: https2.passphrase,
      pfx: https2.pfx,
      rejectUnauthorized: https2.rejectUnauthorized,
      checkServerIdentity: https2.checkServerIdentity ?? checkServerIdentity,
      ciphers: https2.ciphers,
      honorCipherOrder: https2.honorCipherOrder,
      minVersion: https2.minVersion,
      maxVersion: https2.maxVersion,
      sigalgs: https2.signatureAlgorithms,
      sessionTimeout: https2.tlsSessionLifetime,
      dhparam: https2.dhparam,
      ecdhCurve: https2.ecdhCurve,
      crl: https2.certificateRevocationLists,
      // HTTP options
      lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : void 0,
      // HTTP/2 options
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    const url = this._internals.url;
    const { request } = this._internals;
    if (!request && url) {
      return this.getFallbackRequestFunction();
    }
    return request;
  }
  getFallbackRequestFunction() {
    const url = this._internals.url;
    if (!url) {
      return;
    }
    if (url.protocol === "https:") {
      if (this._internals.http2) {
        if (major < 15 || major === 15 && minor < 10) {
          const error = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
          error.code = "EUNSUPPORTED";
          throw error;
        }
        return import_http2_wrapper.default.auto;
      }
      return https.request;
    }
    return http.request;
  }
  freeze() {
    const options = this._internals;
    Object.freeze(options);
    Object.freeze(options.hooks);
    Object.freeze(options.hooks.afterResponse);
    Object.freeze(options.hooks.beforeError);
    Object.freeze(options.hooks.beforeRedirect);
    Object.freeze(options.hooks.beforeRequest);
    Object.freeze(options.hooks.beforeRetry);
    Object.freeze(options.hooks.init);
    Object.freeze(options.https);
    Object.freeze(options.cacheOptions);
    Object.freeze(options.agent);
    Object.freeze(options.headers);
    Object.freeze(options.timeout);
    Object.freeze(options.retry);
    Object.freeze(options.retry.errorCodes);
    Object.freeze(options.retry.methods);
    Object.freeze(options.retry.statusCodes);
  }
};

// node_modules/got/dist/source/core/response.js
init_esm();
var isResponseOk = /* @__PURE__ */ __name((response) => {
  const { statusCode } = response;
  const { followRedirect } = response.request.options;
  const shouldFollow = typeof followRedirect === "function" ? followRedirect(response) : followRedirect;
  const limitStatusCode = shouldFollow ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
}, "isResponseOk");
var ParseError = class extends RequestError {
  static {
    __name(this, "ParseError");
  }
  constructor(error, response) {
    const { options } = response.request;
    super(`${error.message} in "${options.url.toString()}"`, error, response.request);
    this.name = "ParseError";
    this.code = "ERR_BODY_PARSE_FAILURE";
  }
};
var parseBody = /* @__PURE__ */ __name((response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    }
    if (responseType === "buffer") {
      return rawBody;
    }
  } catch (error) {
    throw new ParseError(error, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
}, "parseBody");

// node_modules/got/dist/source/core/utils/is-client-request.js
init_esm();
function isClientRequest(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
}
__name(isClientRequest, "isClientRequest");
var is_client_request_default = isClientRequest;

// node_modules/got/dist/source/core/utils/is-unix-socket-url.js
init_esm();
function isUnixSocketURL(url) {
  return url.protocol === "unix:" || url.hostname === "unix";
}
__name(isUnixSocketURL, "isUnixSocketURL");

// node_modules/got/dist/source/core/index.js
var supportsBrotli = distribution_default.string(process3.versions.brotli);
var methodsWithoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
var cacheableStore = new WeakableMap();
var redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
var proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
];
var noop3 = /* @__PURE__ */ __name(() => {
}, "noop");
var Request = class _Request extends Duplex {
  static {
    __name(this, "Request");
  }
  // @ts-expect-error - Ignoring for now.
  ["constructor"];
  _noPipe;
  // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
  options;
  response;
  requestUrl;
  redirectUrls;
  retryCount;
  _stopRetry;
  _downloadedSize;
  _uploadedSize;
  _stopReading;
  _pipedServerResponses;
  _request;
  _responseSize;
  _bodySize;
  _unproxyEvents;
  _isFromCache;
  _cannotHaveBody;
  _triggerRead;
  _cancelTimeouts;
  _removeListeners;
  _nativeResponse;
  _flushed;
  _aborted;
  // We need this because `this._request` if `undefined` when using cache
  _requestInitialized;
  constructor(url, options, defaults2) {
    super({
      // Don't destroy immediately, as the error may be emitted on unsuccessful retry
      autoDestroy: false,
      // It needs to be zero because we're just proxying the data to another stream
      highWaterMark: 0
    });
    this._downloadedSize = 0;
    this._uploadedSize = 0;
    this._stopReading = false;
    this._pipedServerResponses = /* @__PURE__ */ new Set();
    this._cannotHaveBody = false;
    this._unproxyEvents = noop3;
    this._triggerRead = false;
    this._cancelTimeouts = noop3;
    this._removeListeners = noop3;
    this._jobs = [];
    this._flushed = false;
    this._requestInitialized = false;
    this._aborted = false;
    this.redirectUrls = [];
    this.retryCount = 0;
    this._stopRetry = noop3;
    this.on("pipe", (source) => {
      if (source?.headers) {
        Object.assign(this.options.headers, source.headers);
      }
    });
    this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0) {
        throw new Error("A retry listener has been attached already.");
      }
    });
    try {
      this.options = new Options(url, options, defaults2);
      if (!this.options.url) {
        if (this.options.prefixUrl === "") {
          throw new TypeError("Missing `url` property");
        }
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
    } catch (error) {
      const { options: options2 } = error;
      if (options2) {
        this.options = options2;
      }
      this.flush = async () => {
        this.flush = async () => {
        };
        this.destroy(error);
      };
      return;
    }
    const { body } = this.options;
    if (distribution_default.nodeStream(body)) {
      body.once("error", (error) => {
        if (this._flushed) {
          this._beforeError(new UploadError(error, this));
        } else {
          this.flush = async () => {
            this.flush = async () => {
            };
            this._beforeError(new UploadError(error, this));
          };
        }
      });
    }
    if (this.options.signal) {
      const abort = /* @__PURE__ */ __name(() => {
        if (this.options.signal?.reason?.name === "TimeoutError") {
          this.destroy(new TimeoutError(this.options.signal.reason, this.timings, this));
        } else {
          this.destroy(new AbortError(this));
        }
      }, "abort");
      if (this.options.signal.aborted) {
        abort();
      } else {
        this.options.signal.addEventListener("abort", abort);
        this._removeListeners = () => {
          this.options.signal?.removeEventListener("abort", abort);
        };
      }
    }
  }
  async flush() {
    if (this._flushed) {
      return;
    }
    this._flushed = true;
    try {
      await this._finalizeBody();
      if (this.destroyed) {
        return;
      }
      await this._makeRequest();
      if (this.destroyed) {
        this._request?.destroy();
        return;
      }
      for (const job of this._jobs) {
        job();
      }
      this._jobs.length = 0;
      this._requestInitialized = true;
    } catch (error) {
      this._beforeError(error);
    }
  }
  _beforeError(error) {
    if (this._stopReading) {
      return;
    }
    const { response, options } = this;
    const attemptCount = this.retryCount + (error.name === "RetryError" ? 0 : 1);
    this._stopReading = true;
    if (!(error instanceof RequestError)) {
      error = new RequestError(error.message, error, this);
    }
    const typedError = error;
    void (async () => {
      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
        response.setEncoding(this.readableEncoding);
        const success = await this._setRawBody(response);
        if (success) {
          response.body = response.rawBody.toString();
        }
      }
      if (this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          if (response && "retry-after" in response.headers) {
            retryAfter = Number(response.headers["retry-after"]);
            if (Number.isNaN(retryAfter)) {
              retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
              if (retryAfter <= 0) {
                retryAfter = 1;
              }
            } else {
              retryAfter *= 1e3;
            }
          }
          const retryOptions = options.retry;
          backoff = await retryOptions.calculateDelay({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: calculate_retry_delay_default({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
            })
          });
        } catch (error_) {
          void this._error(new RequestError(error_.message, error_, this));
          return;
        }
        if (backoff) {
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (this.destroyed) {
            return;
          }
          try {
            for (const hook of this.options.hooks.beforeRetry) {
              await hook(typedError, this.retryCount + 1);
            }
          } catch (error_) {
            void this._error(new RequestError(error_.message, error, this));
            return;
          }
          if (this.destroyed) {
            return;
          }
          this.destroy();
          this.emit("retry", this.retryCount + 1, error, (updatedOptions) => {
            const request = new _Request(options.url, updatedOptions, options);
            request.retryCount = this.retryCount + 1;
            process3.nextTick(() => {
              void request.flush();
            });
            return request;
          });
          return;
        }
      }
      void this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = true;
    const { response } = this;
    if (response && !this._stopReading) {
      if (response.readableLength) {
        this._triggerRead = false;
      }
      let data;
      while ((data = response.read()) !== null) {
        this._downloadedSize += data.length;
        const progress = this.downloadProgress;
        if (progress.percent < 1) {
          this.emit("downloadProgress", progress);
        }
        this.push(data);
      }
    }
  }
  _write(chunk2, encoding, callback) {
    const write = /* @__PURE__ */ __name(() => {
      this._writeRequest(chunk2, encoding, callback);
    }, "write");
    if (this._requestInitialized) {
      write();
    } else {
      this._jobs.push(write);
    }
  }
  _final(callback) {
    const endRequest = /* @__PURE__ */ __name(() => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error) => {
        if (this._request?._writableState?.errored) {
          return;
        }
        if (!error) {
          this._bodySize = this._uploadedSize;
          this.emit("uploadProgress", this.uploadProgress);
          this._request?.emit("upload-complete");
        }
        callback(error);
      });
    }, "endRequest");
    if (this._requestInitialized) {
      endRequest();
    } else {
      this._jobs.push(endRequest);
    }
  }
  _destroy(error, callback) {
    this._stopReading = true;
    this.flush = async () => {
    };
    this._stopRetry();
    this._cancelTimeouts();
    this._removeListeners();
    if (this.options) {
      const { body } = this.options;
      if (distribution_default.nodeStream(body)) {
        body.destroy();
      }
    }
    if (this._request) {
      this._request.destroy();
    }
    if (error !== null && !distribution_default.undefined(error) && !(error instanceof RequestError)) {
      error = new RequestError(error.message, error, this);
    }
    callback(error);
  }
  pipe(destination, options) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.add(destination);
    }
    return super.pipe(destination, options);
  }
  unpipe(destination) {
    if (destination instanceof ServerResponse) {
      this._pipedServerResponses.delete(destination);
    }
    super.unpipe(destination);
    return this;
  }
  async _finalizeBody() {
    const { options } = this;
    const { headers } = options;
    const isForm = !distribution_default.undefined(options.form);
    const isJSON = !distribution_default.undefined(options.json);
    const isBody = !distribution_default.undefined(options.body);
    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
    this._cannotHaveBody = cannotHaveBody;
    if (isForm || isJSON || isBody) {
      if (cannotHaveBody) {
        throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
      }
      const noContentType = !distribution_default.string(headers["content-type"]);
      if (isBody) {
        if (isFormData2(options.body)) {
          const encoder = new FormDataEncoder(options.body);
          if (noContentType) {
            headers["content-type"] = encoder.headers["Content-Type"];
          }
          if ("Content-Length" in encoder.headers) {
            headers["content-length"] = encoder.headers["Content-Length"];
          }
          options.body = encoder.encode();
        }
        if (isFormData3(options.body) && noContentType) {
          headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
        }
      } else if (isForm) {
        if (noContentType) {
          headers["content-type"] = "application/x-www-form-urlencoded";
        }
        const { form } = options;
        options.form = void 0;
        options.body = new URLSearchParams(form).toString();
      } else {
        if (noContentType) {
          headers["content-type"] = "application/json";
        }
        const { json } = options;
        options.json = void 0;
        options.body = options.stringifyJson(json);
      }
      const uploadBodySize = await getBodySize(options.body, options.headers);
      if (distribution_default.undefined(headers["content-length"]) && distribution_default.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !distribution_default.undefined(uploadBodySize)) {
        headers["content-length"] = String(uploadBodySize);
      }
    }
    if (options.responseType === "json" && !("accept" in options.headers)) {
      options.headers.accept = "application/json";
    }
    this._bodySize = Number(headers["content-length"]) || void 0;
  }
  async _onResponseBase(response) {
    if (this.isAborted) {
      return;
    }
    const { options } = this;
    const { url } = options;
    this._nativeResponse = response;
    const statusCode = response.statusCode;
    const { method } = options;
    const hasNoBody = method === "HEAD" || statusCode >= 100 && statusCode < 200 || statusCode === 204 || statusCode === 205 || statusCode === 304;
    if (options.decompress && !hasNoBody) {
      response = (0, import_decompress_response.default)(response);
    }
    const typedResponse = response;
    typedResponse.statusMessage = typedResponse.statusMessage ?? http2.STATUS_CODES[statusCode];
    typedResponse.url = options.url.toString();
    typedResponse.requestUrl = this.requestUrl;
    typedResponse.redirectUrls = this.redirectUrls;
    typedResponse.request = this;
    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
    typedResponse.ip = this.ip;
    typedResponse.retryCount = this.retryCount;
    typedResponse.ok = isResponseOk(typedResponse);
    this._isFromCache = typedResponse.isFromCache;
    this._responseSize = Number(response.headers["content-length"]) || void 0;
    this.response = typedResponse;
    response.once("end", () => {
      this._responseSize = this._downloadedSize;
      this.emit("downloadProgress", this.downloadProgress);
    });
    response.once("error", (error) => {
      this._aborted = true;
      response.destroy();
      this._beforeError(new ReadError(error, this));
    });
    response.once("aborted", () => {
      this._aborted = true;
      this._beforeError(new ReadError({
        name: "Error",
        message: "The server aborted pending request",
        code: "ECONNRESET"
      }, this));
    });
    this.emit("downloadProgress", this.downloadProgress);
    const rawCookies = response.headers["set-cookie"];
    if (distribution_default.object(options.cookieJar) && rawCookies) {
      let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
      if (options.ignoreInvalidCookies) {
        promises = promises.map(async (promise) => {
          try {
            await promise;
          } catch {
          }
        });
      }
      try {
        await Promise.all(promises);
      } catch (error) {
        this._beforeError(error);
        return;
      }
    }
    if (this.isAborted) {
      return;
    }
    if (response.headers.location && redirectCodes.has(statusCode)) {
      const shouldFollow = typeof options.followRedirect === "function" ? options.followRedirect(typedResponse) : options.followRedirect;
      if (shouldFollow) {
        response.resume();
        this._cancelTimeouts();
        this._unproxyEvents();
        if (this.redirectUrls.length >= options.maxRedirects) {
          this._beforeError(new MaxRedirectsError(this));
          return;
        }
        this._request = void 0;
        const updatedOptions = new Options(void 0, void 0, this.options);
        const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
        const canRewrite = statusCode !== 307 && statusCode !== 308;
        const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
        if (serverRequestedGet || userRequestedGet) {
          updatedOptions.method = "GET";
          updatedOptions.body = void 0;
          updatedOptions.json = void 0;
          updatedOptions.form = void 0;
          delete updatedOptions.headers["content-length"];
        }
        try {
          const redirectBuffer = Buffer3.from(response.headers.location, "binary").toString();
          const redirectUrl = new URL(redirectBuffer, url);
          if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
            this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
            return;
          }
          if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
            if ("host" in updatedOptions.headers) {
              delete updatedOptions.headers.host;
            }
            if ("cookie" in updatedOptions.headers) {
              delete updatedOptions.headers.cookie;
            }
            if ("authorization" in updatedOptions.headers) {
              delete updatedOptions.headers.authorization;
            }
            if (updatedOptions.username || updatedOptions.password) {
              updatedOptions.username = "";
              updatedOptions.password = "";
            }
          } else {
            redirectUrl.username = updatedOptions.username;
            redirectUrl.password = updatedOptions.password;
          }
          this.redirectUrls.push(redirectUrl);
          updatedOptions.prefixUrl = "";
          updatedOptions.url = redirectUrl;
          for (const hook of updatedOptions.hooks.beforeRedirect) {
            await hook(updatedOptions, typedResponse);
          }
          this.emit("redirect", updatedOptions, typedResponse);
          this.options = updatedOptions;
          await this._makeRequest();
        } catch (error) {
          this._beforeError(error);
          return;
        }
        return;
      }
    }
    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
      this._beforeError(new HTTPError(typedResponse));
      return;
    }
    response.on("readable", () => {
      if (this._triggerRead) {
        this._read();
      }
    });
    this.on("resume", () => {
      response.resume();
    });
    this.on("pause", () => {
      response.pause();
    });
    response.once("end", () => {
      this.push(null);
    });
    if (this._noPipe) {
      const success = await this._setRawBody();
      if (success) {
        this.emit("response", response);
      }
      return;
    }
    this.emit("response", response);
    for (const destination of this._pipedServerResponses) {
      if (destination.headersSent) {
        continue;
      }
      for (const key in response.headers) {
        const isAllowed = options.decompress ? key !== "content-encoding" : true;
        const value = response.headers[key];
        if (isAllowed) {
          destination.setHeader(key, value);
        }
      }
      destination.statusCode = statusCode;
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded) {
      return false;
    }
    try {
      const fromArray = await from.toArray();
      const rawBody = isBuffer(fromArray.at(0)) ? Buffer3.concat(fromArray) : Buffer3.from(fromArray.join(""));
      if (!this.isAborted) {
        this.response.rawBody = rawBody;
        return true;
      }
    } catch {
    }
    return false;
  }
  async _onResponse(response) {
    try {
      await this._onResponseBase(response);
    } catch (error) {
      this._beforeError(error);
    }
  }
  _onRequest(request) {
    const { options } = this;
    const { timeout, url } = options;
    source_default(request);
    if (this.options.http2) {
      request.setTimeout(0);
    }
    this._cancelTimeouts = timedOut(request, timeout, url);
    const responseEventName = options.cache ? "cacheableResponse" : "response";
    request.once(responseEventName, (response) => {
      void this._onResponse(response);
    });
    request.once("error", (error) => {
      this._aborted = true;
      request.destroy();
      error = error instanceof TimeoutError2 ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
      this._beforeError(error);
    });
    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);
    this._request = request;
    this.emit("uploadProgress", this.uploadProgress);
    this._sendBody();
    this.emit("request", request);
  }
  async _asyncWrite(chunk2) {
    return new Promise((resolve, reject) => {
      super.write(chunk2, (error) => {
        if (error) {
          reject(error);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    const { body } = this.options;
    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    if (distribution_default.nodeStream(body)) {
      body.pipe(currentRequest);
    } else if (distribution_default.generator(body) || distribution_default.asyncGenerator(body)) {
      (async () => {
        try {
          for await (const chunk2 of body) {
            await this._asyncWrite(chunk2);
          }
          super.end();
        } catch (error) {
          this._beforeError(error);
        }
      })();
    } else if (!distribution_default.undefined(body)) {
      this._writeRequest(body, void 0, () => {
      });
      currentRequest.end();
    } else if (this._cannotHaveBody || this._noPipe) {
      currentRequest.end();
    }
  }
  _prepareCache(cache) {
    if (!cacheableStore.has(cache)) {
      const cacheableRequest = new dist_default((requestOptions, handler) => {
        const result = requestOptions._request(requestOptions, handler);
        if (distribution_default.promise(result)) {
          result.once = (event, handler2) => {
            if (event === "error") {
              (async () => {
                try {
                  await result;
                } catch (error) {
                  handler2(error);
                }
              })();
            } else if (event === "abort" || event === "destroy") {
              (async () => {
                try {
                  const request = await result;
                  request.once(event, handler2);
                } catch {
                }
              })();
            } else {
              throw new Error(`Unknown HTTP2 promise event: ${event}`);
            }
            return result;
          };
        }
        return result;
      }, cache);
      cacheableStore.set(cache, cacheableRequest.request());
    }
  }
  async _createCacheableRequest(url, options) {
    return new Promise((resolve, reject) => {
      Object.assign(options, urlToOptions(url));
      let request;
      const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
        response._readableState.autoDestroy = false;
        if (request) {
          const fix = /* @__PURE__ */ __name(() => {
            if (response.req) {
              response.complete = response.req.res.complete;
            }
          }, "fix");
          response.prependOnceListener("end", fix);
          fix();
          (await request).emit("cacheableResponse", response);
        }
        resolve(response);
      });
      cacheRequest.once("error", reject);
      cacheRequest.once("request", async (requestOrPromise) => {
        request = requestOrPromise;
        resolve(request);
      });
    });
  }
  async _makeRequest() {
    const { options } = this;
    const { headers, username, password } = options;
    const cookieJar = options.cookieJar;
    for (const key in headers) {
      if (distribution_default.undefined(headers[key])) {
        delete headers[key];
      } else if (distribution_default.null(headers[key])) {
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
      }
    }
    if (options.decompress && distribution_default.undefined(headers["accept-encoding"])) {
      headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
    }
    if (username || password) {
      const credentials = Buffer3.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      const cookieString = await cookieJar.getCookieString(options.url.toString());
      if (distribution_default.nonEmptyString(cookieString)) {
        headers.cookie = cookieString;
      }
    }
    options.prefixUrl = "";
    let request;
    for (const hook of options.hooks.beforeRequest) {
      const result = await hook(options);
      if (!distribution_default.undefined(result)) {
        request = /* @__PURE__ */ __name(() => result, "request");
        break;
      }
    }
    request ||= options.getRequestFunction();
    const url = options.url;
    this._requestOptions = options.createNativeRequestOptions();
    if (options.cache) {
      this._requestOptions._request = request;
      this._requestOptions.cache = options.cache;
      this._requestOptions.body = options.body;
      this._prepareCache(options.cache);
    }
    const function_ = options.cache ? this._createCacheableRequest : request;
    try {
      let requestOrResponse = function_(url, this._requestOptions);
      if (distribution_default.promise(requestOrResponse)) {
        requestOrResponse = await requestOrResponse;
      }
      if (distribution_default.undefined(requestOrResponse)) {
        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
        if (distribution_default.promise(requestOrResponse)) {
          requestOrResponse = await requestOrResponse;
        }
      }
      if (is_client_request_default(requestOrResponse)) {
        this._onRequest(requestOrResponse);
      } else if (this.writable) {
        this.once("finish", () => {
          void this._onResponse(requestOrResponse);
        });
        this._sendBody();
      } else {
        void this._onResponse(requestOrResponse);
      }
    } catch (error) {
      if (error instanceof CacheError2) {
        throw new CacheError(error, this);
      }
      throw error;
    }
  }
  async _error(error) {
    try {
      if (error instanceof HTTPError && !this.options.throwHttpErrors) {
      } else {
        for (const hook of this.options.hooks.beforeError) {
          error = await hook(error);
        }
      }
    } catch (error_) {
      error = new RequestError(error_.message, error_, this);
    }
    this.destroy(error);
  }
  _writeRequest(chunk2, encoding, callback) {
    if (!this._request || this._request.destroyed) {
      return;
    }
    this._request.write(chunk2, encoding, (error) => {
      if (!error && !this._request.destroyed) {
        this._uploadedSize += Buffer3.byteLength(chunk2, encoding);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      }
      callback(error);
    });
  }
  /**
  The remote IP address.
  */
  get ip() {
    return this.socket?.remoteAddress;
  }
  /**
  Indicates whether the request has been aborted or not.
  */
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    return this._request?.socket ?? void 0;
  }
  /**
  Progress event for downloading (receiving a response).
  */
  get downloadProgress() {
    let percent;
    if (this._responseSize) {
      percent = this._downloadedSize / this._responseSize;
    } else if (this._responseSize === this._downloadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  /**
  Progress event for uploading (sending a request).
  */
  get uploadProgress() {
    let percent;
    if (this._bodySize) {
      percent = this._uploadedSize / this._bodySize;
    } else if (this._bodySize === this._uploadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  /**
      The object contains the following properties:
  
      - `start` - Time when the request started.
      - `socket` - Time when a socket was assigned to the request.
      - `lookup` - Time when the DNS lookup finished.
      - `connect` - Time when the socket successfully connected.
      - `secureConnect` - Time when the socket securely connected.
      - `upload` - Time when the request finished uploading.
      - `response` - Time when the request fired `response` event.
      - `end` - Time when the response fired `end` event.
      - `error` - Time when the request fired `error` event.
      - `abort` - Time when the request fired `abort` event.
      - `phases`
          - `wait` - `timings.socket - timings.start`
          - `dns` - `timings.lookup - timings.socket`
          - `tcp` - `timings.connect - timings.lookup`
          - `tls` - `timings.secureConnect - timings.connect`
          - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
          - `firstByte` - `timings.response - timings.upload`
          - `download` - `timings.end - timings.response`
          - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
  
      If something has not been measured yet, it will be `undefined`.
  
      __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
      */
  get timings() {
    return this._request?.timings;
  }
  /**
  Whether the response was retrieved from the cache.
  */
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    return this._request?.reusedSocket;
  }
};

// node_modules/got/dist/source/as-promise/types.js
init_esm();
var CancelError2 = class extends RequestError {
  static {
    __name(this, "CancelError");
  }
  constructor(request) {
    super("Promise was canceled", {}, request);
    this.name = "CancelError";
    this.code = "ERR_CANCELED";
  }
  /**
  Whether the promise is canceled.
  */
  get isCanceled() {
    return true;
  }
};

// node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest;
  let globalResponse;
  let normalizedOptions;
  const emitter = new EventEmitter2();
  const promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    });
    onCancel.shouldReject = false;
    onCancel(() => {
      reject(new CancelError2(globalRequest));
    });
    const makeRequest = /* @__PURE__ */ __name((retryCount) => {
      onCancel(() => {
      });
      const request = firstRequest ?? new Request(void 0, void 0, normalizedOptions);
      request.retryCount = retryCount;
      request._noPipe = true;
      globalRequest = request;
      request.once("response", async (response) => {
        const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
        const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
        const { options } = request;
        if (isCompressed && !options.decompress) {
          response.body = response.rawBody;
        } else {
          try {
            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);
          } catch (error) {
            try {
              response.body = response.rawBody.toString();
            } catch (error2) {
              request._beforeError(new ParseError(error2, response));
              return;
            }
            if (isResponseOk(response)) {
              request._beforeError(error);
              return;
            }
          }
        }
        try {
          const hooks = options.hooks.afterResponse;
          for (const [index, hook] of hooks.entries()) {
            response = await hook(response, async (updatedOptions) => {
              options.merge(updatedOptions);
              options.prefixUrl = "";
              if (updatedOptions.url) {
                options.url = updatedOptions.url;
              }
              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
              throw new RetryError(request);
            });
            if (!(distribution_default.object(response) && distribution_default.number(response.statusCode) && !distribution_default.nullOrUndefined(response.body))) {
              throw new TypeError("The `afterResponse` hook returned an invalid value");
            }
          }
        } catch (error) {
          request._beforeError(error);
          return;
        }
        globalResponse = response;
        if (!isResponseOk(response)) {
          request._beforeError(new HTTPError(response));
          return;
        }
        request.destroy();
        resolve(request.options.resolveBodyOnly ? response.body : response);
      });
      const onError = /* @__PURE__ */ __name((error) => {
        if (promise.isCanceled) {
          return;
        }
        const { options } = request;
        if (error instanceof HTTPError && !options.throwHttpErrors) {
          const { response } = error;
          request.destroy();
          resolve(request.options.resolveBodyOnly ? response.body : response);
          return;
        }
        reject(error);
      }, "onError");
      request.once("error", onError);
      const previousBody = request.options?.body;
      request.once("retry", (newRetryCount, error) => {
        firstRequest = void 0;
        const newBody = request.options.body;
        if (previousBody === newBody && distribution_default.nodeStream(newBody)) {
          error.message = "Cannot retry with consumed body stream";
          onError(error);
          return;
        }
        normalizedOptions = request.options;
        makeRequest(newRetryCount);
      });
      proxyEvents(request, emitter, proxiedRequestEvents2);
      if (distribution_default.undefined(firstRequest)) {
        void request.flush();
      }
    }, "makeRequest");
    makeRequest(0);
  });
  promise.on = (event, function_) => {
    emitter.on(event, function_);
    return promise;
  };
  promise.off = (event, function_) => {
    emitter.off(event, function_);
    return promise;
  };
  const shortcut = /* @__PURE__ */ __name((responseType) => {
    const newPromise = (async () => {
      await promise;
      const { options } = globalResponse.request;
      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);
    })();
    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
    return newPromise;
  }, "shortcut");
  promise.json = () => {
    if (globalRequest.options) {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && !("accept" in headers)) {
        headers.accept = "application/json";
      }
    }
    return shortcut("json");
  };
  promise.buffer = () => shortcut("buffer");
  promise.text = () => shortcut("text");
  return promise;
}
__name(asPromise, "asPromise");

// node_modules/got/dist/source/create.js
var isGotInstance = /* @__PURE__ */ __name((value) => distribution_default.function(value), "isGotInstance");
var aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
];
var create = /* @__PURE__ */ __name((defaults2) => {
  defaults2 = {
    options: new Options(void 0, void 0, defaults2.options),
    handlers: [...defaults2.handlers],
    mutableDefaults: defaults2.mutableDefaults
  };
  Object.defineProperty(defaults2, "mutableDefaults", {
    enumerable: true,
    configurable: false,
    writable: false
  });
  const got2 = /* @__PURE__ */ __name((url, options, defaultOptions2 = defaults2.options) => {
    const request = new Request(url, options, defaultOptions2);
    let promise;
    const lastHandler = /* @__PURE__ */ __name((normalized) => {
      request.options = normalized;
      request._noPipe = !normalized?.isStream;
      void request.flush();
      if (normalized?.isStream) {
        return request;
      }
      promise ||= asPromise(request);
      return promise;
    }, "lastHandler");
    let iteration = 0;
    const iterateHandlers = /* @__PURE__ */ __name((newOptions) => {
      const handler = defaults2.handlers[iteration++] ?? lastHandler;
      const result = handler(newOptions, iterateHandlers);
      if (distribution_default.promise(result) && !request.options?.isStream) {
        promise ||= asPromise(request);
        if (result !== promise) {
          const descriptors = Object.getOwnPropertyDescriptors(promise);
          for (const key in descriptors) {
            if (key in result) {
              delete descriptors[key];
            }
          }
          Object.defineProperties(result, descriptors);
          result.cancel = promise.cancel;
        }
      }
      return result;
    }, "iterateHandlers");
    return iterateHandlers(request.options);
  }, "got");
  got2.extend = (...instancesOrOptions) => {
    const options = new Options(void 0, void 0, defaults2.options);
    const handlers = [...defaults2.handlers];
    let mutableDefaults;
    for (const value of instancesOrOptions) {
      if (isGotInstance(value)) {
        options.merge(value.defaults.options);
        handlers.push(...value.defaults.handlers);
        mutableDefaults = value.defaults.mutableDefaults;
      } else {
        options.merge(value);
        if (value.handlers) {
          handlers.push(...value.handlers);
        }
        mutableDefaults = value.mutableDefaults;
      }
    }
    return create({
      options,
      handlers,
      mutableDefaults: Boolean(mutableDefaults)
    });
  };
  const paginateEach = /* @__PURE__ */ __name(async function* (url, options) {
    let normalizedOptions = new Options(url, options, defaults2.options);
    normalizedOptions.resolveBodyOnly = false;
    const { pagination } = normalizedOptions;
    assert.function(pagination.transform);
    assert.function(pagination.shouldContinue);
    assert.function(pagination.filter);
    assert.function(pagination.paginate);
    assert.number(pagination.countLimit);
    assert.number(pagination.requestLimit);
    assert.number(pagination.backoff);
    const allItems = [];
    let { countLimit } = pagination;
    let numberOfRequests = 0;
    while (numberOfRequests < pagination.requestLimit) {
      if (numberOfRequests !== 0) {
        await delay(pagination.backoff);
      }
      const response = await got2(void 0, void 0, normalizedOptions);
      const parsed = await pagination.transform(response);
      const currentItems = [];
      assert.array(parsed);
      for (const item of parsed) {
        if (pagination.filter({ item, currentItems, allItems })) {
          if (!pagination.shouldContinue({ item, currentItems, allItems })) {
            return;
          }
          yield item;
          if (pagination.stackAllItems) {
            allItems.push(item);
          }
          currentItems.push(item);
          if (--countLimit <= 0) {
            return;
          }
        }
      }
      const optionsToMerge = pagination.paginate({
        response,
        currentItems,
        allItems
      });
      if (optionsToMerge === false) {
        return;
      }
      if (optionsToMerge === response.request.options) {
        normalizedOptions = response.request.options;
      } else {
        normalizedOptions.merge(optionsToMerge);
        assert.any([distribution_default.urlInstance, distribution_default.undefined], optionsToMerge.url);
        if (optionsToMerge.url !== void 0) {
          normalizedOptions.prefixUrl = "";
          normalizedOptions.url = optionsToMerge.url;
        }
      }
      numberOfRequests++;
    }
  }, "paginateEach");
  got2.paginate = paginateEach;
  got2.paginate.all = async (url, options) => {
    const results = [];
    for await (const item of paginateEach(url, options)) {
      results.push(item);
    }
    return results;
  };
  got2.paginate.each = paginateEach;
  got2.stream = (url, options) => got2(url, { ...options, isStream: true });
  for (const method of aliases) {
    got2[method] = (url, options) => got2(url, { ...options, method });
    got2.stream[method] = (url, options) => got2(url, { ...options, method, isStream: true });
  }
  if (!defaults2.mutableDefaults) {
    Object.freeze(defaults2.handlers);
    defaults2.options.freeze();
  }
  Object.defineProperty(got2, "defaults", {
    value: defaults2,
    writable: false,
    configurable: false,
    enumerable: true
  });
  return got2;
}, "create");
var create_default = create;

// node_modules/got/dist/source/index.js
var defaults = {
  options: new Options(),
  handlers: [],
  mutableDefaults: false
};
var got = create_default(defaults);
var source_default2 = got;

// node_modules/into-stream/index.js
init_esm();
import { Readable as ReadableStream3 } from "node:stream";
function baseIntoStream(isObjectMode, input) {
  if (input === void 0 || input === null) {
    throw new TypeError("Input should not be undefined or null.");
  }
  async function* reader() {
    let value = await input;
    if (!value) {
      return;
    }
    if (Array.isArray(value)) {
      value = [...value];
    }
    if (!isObjectMode && (value instanceof ArrayBuffer || ArrayBuffer.isView(value))) {
      value = new Uint8Array(value);
    }
    const convertElement = /* @__PURE__ */ __name((element) => {
      if (isObjectMode) {
        return element;
      }
      if (ArrayBuffer.isView(element)) {
        return new Uint8Array(element);
      }
      if (typeof element === "number") {
        return new Uint8Array([element]);
      }
      return element;
    }, "convertElement");
    if (typeof value !== "string" && !ArrayBuffer.isView(value) && value?.[Symbol.iterator]) {
      for (const element of value) {
        yield convertElement(element);
      }
      return;
    }
    if (value?.[Symbol.asyncIterator]) {
      for await (const element of value) {
        yield convertElement(await element);
      }
      return;
    }
    yield value;
  }
  __name(reader, "reader");
  return ReadableStream3.from(reader(), { objectMode: isObjectMode });
}
__name(baseIntoStream, "baseIntoStream");
var intoStream = baseIntoStream.bind(void 0, false);
var into_stream_default = intoStream;
intoStream.object = baseIntoStream.bind(void 0, true);

// node_modules/transloadit/node_modules/is-stream/index.js
init_esm();
function isStream2(stream2, { checkOpen = true } = {}) {
  return stream2 !== null && typeof stream2 === "object" && (stream2.writable || stream2.readable || !checkOpen || stream2.writable === void 0 && stream2.readable === void 0) && typeof stream2.pipe === "function";
}
__name(isStream2, "isStream");
function isReadableStream2(stream2, { checkOpen = true } = {}) {
  return isStream2(stream2, { checkOpen }) && (stream2.readable || !checkOpen) && typeof stream2.read === "function" && typeof stream2.readable === "boolean" && typeof stream2.readableObjectMode === "boolean" && typeof stream2.destroy === "function" && typeof stream2.destroyed === "boolean";
}
__name(isReadableStream2, "isReadableStream");

// node_modules/p-map/index.js
init_esm();
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve_, reject_) => {
    if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = /* @__PURE__ */ new Map();
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === void 0 ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const signalListener = /* @__PURE__ */ __name(() => {
      reject(signal.reason);
    }, "signalListener");
    const cleanup = /* @__PURE__ */ __name(() => {
      signal?.removeEventListener("abort", signalListener);
    }, "cleanup");
    const resolve = /* @__PURE__ */ __name((value) => {
      resolve_(value);
      cleanup();
    }, "resolve");
    const reject = /* @__PURE__ */ __name((reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
      cleanup();
    }, "reject");
    if (signal) {
      if (signal.aborted) {
        reject(signal.reason);
      }
      signal.addEventListener("abort", signalListener, { once: true });
    }
    const next = /* @__PURE__ */ __name(async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve(result);
            return;
          }
          const pureResult = [];
          for (const [index2, value] of result.entries()) {
            if (skippedIndexesMap.get(index2) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index, value);
          }
          result[index] = value;
          resolvingCount--;
          await next();
        } catch (error) {
          if (stopOnError) {
            reject(error);
          } else {
            errors.push(error);
            resolvingCount--;
            try {
              await next();
            } catch (error2) {
              reject(error2);
            }
          }
        }
      })();
    }, "next");
    (async () => {
      for (let index = 0; index < concurrency; index++) {
        try {
          await next();
        } catch (error) {
          reject(error);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
__name(pMap, "pMap");
var pMapSkip = Symbol("skip");

// node_modules/transloadit/package.json
var package_default = {
  name: "transloadit",
  version: "4.7.4",
  description: "Node.js SDK for Transloadit",
  homepage: "https://github.com/transloadit/node-sdk/tree/main/packages/node",
  bugs: {
    url: "https://github.com/transloadit/node-sdk/issues"
  },
  type: "module",
  keywords: [
    "transloadit",
    "tus",
    "resumable-upload",
    "upload",
    "file-processing",
    "assembly",
    "assemblies",
    "template",
    "templates",
    "encoding",
    "transcoding",
    "video",
    "image",
    "audio",
    "mp3",
    "cli",
    "typescript"
  ],
  author: "Tim Koschuetzki <tim@transloadit.com>",
  packageManager: "yarn@4.12.0",
  engines: {
    node: ">= 20"
  },
  dependencies: {
    "@aws-sdk/client-s3": "^3.891.0",
    "@aws-sdk/s3-request-presigner": "^3.891.0",
    "@transloadit/sev-logger": "^0.1.9",
    "@transloadit/utils": "^4.3.0",
    clipanion: "^4.0.0-rc.4",
    debug: "^4.4.3",
    dotenv: "^17.2.3",
    "form-data": "^4.0.4",
    got: "14.4.9",
    "into-stream": "^9.0.0",
    "is-stream": "^4.0.1",
    "json-to-ast": "^2.1.0",
    "lodash-es": "^4.17.21",
    "node-watch": "^0.7.4",
    "p-map": "^7.0.3",
    "p-queue": "^9.0.1",
    "recursive-readdir": "^2.2.3",
    "tus-js-client": "^4.3.1",
    typanion: "^3.14.0",
    "type-fest": "^4.41.0",
    zod: "3.25.76"
  },
  devDependencies: {
    "@types/debug": "^4.1.12",
    "@types/minimist": "^1.2.5",
    "@types/node": "^24.10.3",
    "@types/recursive-readdir": "^2.2.4",
    minimatch: "^10.1.1"
  },
  repository: {
    type: "git",
    url: "https://github.com/transloadit/node-sdk",
    directory: "packages/node"
  },
  directories: {
    src: "./src"
  },
  scripts: {
    check: "yarn lint:ts && yarn fix && yarn test:unit",
    "fix:js": "biome check --write .",
    "lint:ts": "yarn --cwd ../.. tsc:node",
    "fix:js:unsafe": "biome check --write . --unsafe",
    "lint:js": "biome check .",
    lint: "npm-run-all --parallel 'lint:js'",
    fix: "npm-run-all --serial 'fix:js'",
    "lint:deps": "knip --dependencies --no-progress",
    "fix:deps": "knip --dependencies --no-progress --fix",
    prepack: "node ../../scripts/prepare-transloadit.ts",
    "test:unit": "yarn --cwd ../.. tsc:utils && ../../node_modules/.bin/vitest run --coverage ./test/unit",
    "test:e2e": "yarn --cwd ../.. tsc:utils && ../../node_modules/.bin/vitest run ./test/e2e",
    test: "yarn --cwd ../.. tsc:utils && ../../node_modules/.bin/vitest run --coverage"
  },
  license: "MIT",
  main: "./dist/Transloadit.js",
  exports: {
    ".": "./dist/Transloadit.js",
    "./package.json": "./package.json"
  },
  files: [
    "dist",
    "src"
  ],
  bin: "./dist/cli.js"
};

// node_modules/transloadit/dist/ApiError.js
init_esm();
var ApiError = class extends Error {
  static {
    __name(this, "ApiError");
  }
  name = "ApiError";
  // there might not be an error code (or message) if the server didn't respond with any JSON response at all
  // e.g. if there was a 500 in the HTTP reverse proxy
  code;
  rawMessage;
  reason;
  assemblySslUrl;
  assemblyId;
  cause;
  constructor(params) {
    const { cause, body = {} } = params;
    const parts = ["API error"];
    if (cause instanceof HTTPError && cause?.response.statusCode)
      parts.push(`(HTTP ${cause.response.statusCode})`);
    if (body.error)
      parts.push(`${body.error}:`);
    if (body.message)
      parts.push(body.message);
    if (body.assembly_ssl_url)
      parts.push(body.assembly_ssl_url);
    const message = parts.join(" ");
    super(message);
    this.rawMessage = body.message;
    this.reason = body.reason;
    this.assemblyId = body.assembly_id;
    this.assemblySslUrl = body.assembly_ssl_url;
    this.code = body.error;
    this.cause = cause;
  }
};

// node_modules/transloadit/dist/alphalib/types/assemblyStatus.js
init_esm();
var assemblyBusyCodeSchema = external_exports.enum([
  "ASSEMBLY_UPLOADING",
  "ASSEMBLY_EXECUTING",
  "ASSEMBLY_REPLAYING"
]);
var assemblyStatusOkCodeSchema = external_exports.enum([
  "ASSEMBLY_CANCELED",
  "ASSEMBLY_COMPLETED",
  "ASSEMBLY_EXECUTING",
  "ASSEMBLY_REPLAYING",
  "ASSEMBLY_UPLOADING",
  "REQUEST_ABORTED"
  // 'ASSEMBLY_EXECUTION_PROGRESS_FETCHED',
  // 'ASSEMBLY_FILE_ACCEPTED',
  // 'ASSEMBLY_FILE_RESERVED',
]);
var assemblyStatusErrCodeSchema = external_exports.enum([
  "ADMIN_PERMISSIONS_REQUIRED",
  "ASSEMBLY_ACCOUNT_MISMATCH",
  "ASSEMBLY_CANNOT_BE_REPLAYED",
  "ASSEMBLY_COULD_NOT_BE_CREATED",
  "ASSEMBLY_CRASHED",
  "ASSEMBLY_DISALLOWED_ROBOTS_USED",
  "ASSEMBLY_EMPTY_STEPS",
  "ASSEMBLY_EXECUTION_PROGRESS_NOT_ENABLED",
  "ASSEMBLY_EXPIRED",
  "ASSEMBLY_FILE_NOT_RESERVED",
  "ASSEMBLY_INFINITE",
  "ASSEMBLY_INSTANCE_NOT_FOUND",
  "ASSEMBLY_INVALID_NOTIFY_URL",
  "ASSEMBLY_INVALID_NUM_EXPECTED_UPLOAD_FILES_PARAM",
  "ASSEMBLY_INVALID_STEPS",
  "ASSEMBLY_JOB_ENQUEUE_ERROR",
  "ASSEMBLY_LIST_ERROR",
  "ASSEMBLY_MEMORY_LIMIT_EXCEEDED",
  "ASSEMBLY_NO_CHARGEABLE_STEP",
  "ASSEMBLY_NO_STEPS",
  "ASSEMBLY_NOT_CAPABLE",
  "ASSEMBLY_NOT_FINISHED",
  "ASSEMBLY_NOT_FOUND",
  "ASSEMBLY_NOT_REPLAYED",
  "ASSEMBLY_NOTIFICATION_LIST_ERROR",
  "ASSEMBLY_NOTIFICATION_NOT_PERSISTED",
  "ASSEMBLY_NOTIFICATION_NOT_REPLAYED",
  "ASSEMBLY_NOTIFICATIONS_LIST_ERROR",
  "ASSEMBLY_NO_NOTIFY_URL",
  "ASSEMBLY_ROBOT_MISSING",
  "ASSEMBLY_SATURATED",
  "ASSEMBLY_STATS_ERROR",
  "ASSEMBLY_STATS_INVALID_TIME",
  "ASSEMBLY_STATS_MISSING_REGION",
  "ASSEMBLY_STATUS_FETCHING_RATE_LIMIT_REACHED",
  "ASSEMBLY_STATUS_NOT_FOUND",
  "ASSEMBLY_STATUS_PARSE_ERROR",
  "ASSEMBLY_STEP_INVALID_ROBOT",
  "ASSEMBLY_STEP_INVALID_USE",
  "ASSEMBLY_STEP_INVALID",
  "ASSEMBLY_STEP_NO_ROBOT",
  "ASSEMBLY_STEP_UNKNOWN_ROBOT",
  "ASSEMBLY_STEP_UNKNOWN_USE",
  "AI_CHAT_VALIDATION",
  "ASSEMBLY_URL_TRANSFORM_MISSING",
  "AUTH_EXPIRED",
  "AUTH_KEY_SCOPES_NOT_FOUND",
  "AUTH_KEYS_NOT_FOUND",
  "AUTH_SECRET_NOT_RETRIEVED",
  "AZURE_STORE_ACCESS_DENIED",
  "BEARER_TOKEN_AUTH_KEY_MISMATCH",
  "BEARER_TOKEN_EXPIRED",
  "BEARER_TOKEN_INVALID",
  "BACKBLAZE_IMPORT_ACCESS_DENIED",
  "BACKBLAZE_IMPORT_NOT_FOUND",
  "BACKBLAZE_STORE_ACCESS_DENIED",
  "BACKBLAZE_STORE_FAILURE",
  "BAD_PRICING",
  "BILL_LIMIT_EXCEEDED",
  "CANNOT_ACCEPT_NEW_ASSEMBLIES",
  "CANNOT_FETCH_ACTIVE_ASSEMBLIES",
  "CDN_REQUIRED",
  "CLOUDFILES_IMPORT_ACCESS_DENIED",
  "CLOUDFILES_IMPORT_NOT_FOUND",
  "CLOUDFILES_STORE_ACCESS_DENIED",
  "CLOUDFILES_STORE_ERROR",
  "CLOUDFLARE_IMPORT_VALIDATION",
  "DIGITALOCEAN_STORE_ACCESS_DENIED",
  "DO_NOT_REUSE_ASSEMBLY_IDS",
  "DOCUMENT_CONVERT_UNSUPPORTED_CONVERSION",
  "DOCUMENT_OPTIMIZE_UNSUPPORTED_INPUT",
  "DOCUMENT_OPTIMIZE_VALIDATION",
  "DOCUMENT_SPLIT_VALIDATION",
  "FILE_DOWNLOAD_ERROR",
  "FILE_FILTER_DECLINED_FILE",
  "FILE_FILTER_INVALID_OPERATOR",
  "FILE_FILTER_VALIDATION",
  "FILE_META_DATA_ERROR",
  "FILE_PREVIEW_VALIDATION",
  "FILE_READ_VALIDATION_ERROR",
  "FILE_SERVE_NO_RESULT",
  "FILE_VERIFY_INVALID_FILE",
  "FILE_VIRUSSCAN_DECLINED_FILE",
  "GET_ACCOUNT_DB_ERROR",
  "GET_ACCOUNT_UNKNOWN_AUTH_KEY",
  "GOOGLE_IMPORT_VALIDATION",
  "GOOGLE_STORE_VALIDATION",
  "HTML_CONVERT_VALIDATION",
  "HTTP_IMPORT_ACCESS_DENIED",
  "HTTP_IMPORT_FAILURE",
  "HTTP_IMPORT_NOT_FOUND",
  "HTTP_IMPORT_VALIDATION",
  "IMAGE_DESCRIBE_VALIDATION",
  "IMAGE_RESIZE_ERROR",
  "IMAGE_RESIZE_VALIDATION",
  "IMPORT_FILE_ERROR",
  "INCOMPLETE_PRICING",
  "INSUFFICIENT_AUTH_SCOPE",
  "INTERNAL_COMMAND_ERROR",
  "INTERNAL_COMMAND_TIMEOUT",
  "INVALID_ASSEMBLY_STATUS",
  "INVALID_AUTH_EXPIRES_PARAMETER",
  "INVALID_AUTH_KEY_PARAMETER",
  "INVALID_AUTH_MAX_SIZE_PARAMETER",
  "INVALID_AUTH_REFERER_PARAMETER",
  "INVALID_FILE_META_DATA",
  "INVALID_FORM_DATA",
  "INVALID_URL_ENCODING",
  "INVALID_INPUT_ERROR",
  "INVALID_PARAMS_FIELD",
  "INVALID_SIGNATURE",
  "INVALID_STEP_NAME",
  "INVALID_TEMPLATE_FIELD",
  "INVALID_UPLOAD_HANDLE_STEP_NAME",
  "MAX_SIZE_EXCEEDED",
  "NO_AUTH_EXPIRES_PARAMETER",
  "NO_AUTH_KEY_PARAMETER",
  "NO_AUTH_PARAMETER",
  "NO_COUNTRY",
  "NO_OBJECT_AUTH_PARAMETER",
  "NO_OBJECT_PARAMS_FIELD",
  "NO_PARAMS_FIELD",
  "NO_PRICING",
  "NO_RESULT_STEP_FOUND",
  "NO_RPC_RESULT_FROM_IMAGE_RESIZER",
  "NO_SIGNATURE_FIELD",
  "NO_TEMPLATE_ID",
  "PLAN_LIMIT_EXCEEDED",
  "POSSIBLY_MALICIOUS_FILE_FOUND",
  "PRIORITY_JOB_SLOTS_NOT_FOUND",
  "RATE_LIMIT_REACHED",
  "REFERER_MISMATCH",
  "REQUEST_PREMATURE_CLOSED",
  "ROBOT_VALIDATION_BASE_ERROR",
  "S3_ACCESS_DENIED",
  "S3_IMPORT_ACCESS_DENIED",
  "S3_IMPORT_VALIDATION",
  "S3_NOT_FOUND",
  "S3_STORE_ACCESS_DENIED",
  "S3_STORE_VALIDATION",
  "SERVER_403",
  "SERVER_404",
  "SERVER_500",
  "SIGNATURE_REUSE_DETECTED",
  "TEMPLATE_CREDENTIALS_INJECTION_ERROR",
  "TEMPLATE_DB_ERROR",
  "TEMPLATE_DENIES_STEPS_OVERRIDE",
  "TEMPLATE_INVALID_JSON",
  "TEMPLATE_NOT_FOUND",
  "TMP_FILE_DOWNLOAD_ERROR",
  "USER_COMMAND_ERROR",
  "VERIFIED_EMAIL_REQUIRED",
  "VIDEO_CONCAT_INVALID_INPUT",
  "VIDEO_CONCAT_NO_OUTPUT",
  "VIDEO_CONCAT_VALIDATION",
  "VIDEO_ENCODE_VALIDATION",
  "VIMEO_IMPORT_FAILURE",
  "WORKER_JOB_ERROR"
]);
var assemblyStatusMetaSchema = external_exports.object({
  width: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  height: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  date_file_modified: external_exports.string().nullable().optional(),
  aspect_ratio: external_exports.union([external_exports.number(), external_exports.string(), external_exports.null()]).optional(),
  has_clipping_path: external_exports.boolean().optional(),
  frame_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  colorspace: external_exports.string().nullable().optional(),
  has_transparency: external_exports.boolean().nullable().optional(),
  average_color: external_exports.string().nullable().optional(),
  svgViewBoxWidth: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  svgViewBoxHeight: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  date_recorded: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  date_file_created: external_exports.string().nullable().optional(),
  title: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  description: external_exports.string().nullable().optional(),
  duration: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  location: external_exports.string().nullable().optional(),
  city: external_exports.string().nullable().optional(),
  state: external_exports.string().nullable().optional(),
  rights: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  country: external_exports.string().nullable().optional(),
  country_code: external_exports.string().nullable().optional(),
  keywords: external_exports.union([external_exports.string(), external_exports.array(external_exports.union([external_exports.string(), external_exports.number()]))]).nullable().optional(),
  aperture: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  exposure_compensation: external_exports.union([external_exports.number(), external_exports.string()]).nullable().optional(),
  exposure_mode: external_exports.string().nullable().optional(),
  exposure_time: external_exports.union([external_exports.number(), external_exports.string()]).nullable().optional(),
  flash: external_exports.string().nullable().optional(),
  focal_length: external_exports.string().nullable().optional(),
  f_number: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  iso: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  light_value: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  metering_mode: external_exports.string().nullable().optional(),
  shutter_speed: external_exports.union([external_exports.number(), external_exports.string()]).nullable().optional(),
  white_balance: external_exports.string().nullable().optional(),
  device_name: external_exports.string().nullable().optional(),
  device_vendor: external_exports.string().nullable().optional(),
  device_software: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  latitude: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  longitude: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  orientation: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  creator: external_exports.string().nullable().optional(),
  author: external_exports.string().nullable().optional(),
  copyright: external_exports.string().nullable().optional(),
  copyright_notice: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  dominant_colors: external_exports.array(external_exports.string()).nullable().optional(),
  xp_title: external_exports.string().nullable().optional(),
  xp_comment: external_exports.string().nullable().optional(),
  xp_keywords: external_exports.string().nullable().optional(),
  xp_subject: external_exports.string().nullable().optional(),
  recognized_text: external_exports.union([
    external_exports.array(external_exports.string()),
    external_exports.array(external_exports.object({
      text: external_exports.string(),
      boundingPolygon: external_exports.array(external_exports.object({ x: external_exports.number(), y: external_exports.number() }))
    }).passthrough())
  ]).optional(),
  descriptions: external_exports.array(external_exports.union([external_exports.string(), external_exports.object({ name: external_exports.string(), confidence: external_exports.number() }).passthrough()])).optional(),
  framerate: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  mean_volume: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  video_bitrate: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  overall_bitrate: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  video_codec: external_exports.string().nullable().optional(),
  audio_bitrate: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  audio_samplerate: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  audio_channels: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  audio_channel_layout: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  audio_sample_format: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  audio_profile: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  audio_codec: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  num_audio_streams: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  num_video_streams: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  num_subtitles: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  bit_depth: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  seekable: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
  pixel_format: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  reference_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  time_base: external_exports.union([external_exports.string(), external_exports.null()]).optional(),
  streams: external_exports.union([
    external_exports.object({
      video: external_exports.array(external_exports.unknown()).optional(),
      audio: external_exports.array(external_exports.unknown()).optional(),
      subtitle: external_exports.array(external_exports.unknown()).optional()
    }),
    external_exports.null()
  ]).optional(),
  rotation: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  album: external_exports.string().nullable().optional(),
  comment: external_exports.string().nullable().optional(),
  year: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  encoding_profile: external_exports.string().nullable().optional(),
  encoding_level: external_exports.string().nullable().optional(),
  has_artwork: external_exports.union([external_exports.boolean(), external_exports.null()]).optional(),
  has_alpha_channel: external_exports.boolean().nullable().optional(),
  beats_per_minute: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  genre: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  artist: external_exports.string().nullable().optional(),
  performer: external_exports.string().nullable().optional(),
  lyrics: external_exports.string().nullable().optional(),
  band: external_exports.string().nullable().optional(),
  disc: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  track: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  turbo: external_exports.boolean().nullable().optional(),
  encoder: external_exports.string().nullable().optional(),
  thumb_index: external_exports.number().nullable().optional(),
  thumb_offset: external_exports.preprocess((val) => typeof val === "string" ? Number.parseInt(val, 10) : val, external_exports.number()).nullable().optional(),
  page_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  page_size: external_exports.string().nullable().optional(),
  producer: external_exports.string().nullable().optional(),
  create_date: external_exports.string().nullable().optional(),
  modify_date: external_exports.union([external_exports.string(), external_exports.number()]).nullable().optional(),
  colortransfer: external_exports.string().nullable().optional(),
  colorprimaries: external_exports.string().nullable().optional(),
  archive_directory: external_exports.string().nullable().optional(),
  relative_path: external_exports.string().nullable().optional(),
  segment_index: external_exports.number().nullable().optional(),
  starts_at: external_exports.string().nullable().optional(),
  ends_at: external_exports.string().nullable().optional(),
  resolution: external_exports.string().nullable().optional(),
  bandwidth: external_exports.number().nullable().optional(),
  closed_captions: external_exports.boolean().nullable().optional(),
  codecs: external_exports.string().nullable().optional(),
  storage_url: external_exports.string().optional(),
  version_id: external_exports.string().optional(),
  faces: external_exports.array(external_exports.object({
    x1: external_exports.number(),
    y1: external_exports.number(),
    x2: external_exports.number(),
    y2: external_exports.number(),
    confidence: external_exports.number().optional(),
    width: external_exports.number(),
    height: external_exports.number()
  }).passthrough()).nullable().optional(),
  reason: external_exports.string().optional(),
  step: external_exports.string().optional(),
  previousStep: external_exports.string().optional(),
  exitCode: external_exports.number().nullable().optional(),
  exitSignal: external_exports.string().nullable().optional(),
  stdout: external_exports.string().optional(),
  stderr: external_exports.string().optional(),
  cmd: external_exports.union([external_exports.string(), external_exports.array(external_exports.union([external_exports.string(), external_exports.number()]))]).optional(),
  worker: external_exports.string().optional(),
  word_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  character_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  character_count_with_spaces: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  line_count: external_exports.union([external_exports.number(), external_exports.null()]).optional(),
  paragraph_count: external_exports.union([external_exports.number(), external_exports.null()]).optional()
}).passthrough();
var hlsNestedMetaSchema = external_exports.object({
  relative_path: external_exports.string().optional(),
  duration: external_exports.number().optional(),
  width: external_exports.number().optional(),
  height: external_exports.number().optional(),
  framerate: external_exports.number().optional(),
  overall_bitrate: external_exports.number().optional(),
  aspect_ratio: external_exports.number().optional(),
  video_codec: external_exports.string().optional(),
  audio_samplerate: external_exports.number().optional(),
  audio_channels: external_exports.number().optional(),
  num_audio_streams: external_exports.number().optional(),
  audio_codec: external_exports.string().optional(),
  seekable: external_exports.boolean().optional(),
  date_file_modified: external_exports.string().optional(),
  encoding_profile: external_exports.string().optional(),
  encoding_level: external_exports.string().optional(),
  has_artwork: external_exports.boolean().optional(),
  has_alpha_channel: external_exports.boolean().optional(),
  version_id: external_exports.string().optional()
});
var hlsPlaylistSchema = external_exports.object({
  name: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
  content: external_exports.string().optional(),
  relative_path: external_exports.string().optional(),
  stream: external_exports.string().optional(),
  meta: hlsNestedMetaSchema.optional()
});
var assemblyStatusUploadSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  basename: external_exports.string(),
  ext: external_exports.string(),
  size: external_exports.number(),
  mime: external_exports.string().nullable(),
  type: external_exports.string().nullable(),
  field: external_exports.string().nullable(),
  md5hash: external_exports.string().nullable(),
  original_id: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]),
  original_basename: external_exports.string(),
  original_name: external_exports.string(),
  original_path: external_exports.string(),
  original_md5hash: external_exports.string().nullable(),
  from_batch_import: external_exports.boolean(),
  is_tus_file: external_exports.boolean(),
  tus_upload_url: external_exports.string().nullable(),
  url: external_exports.string().nullable(),
  ssl_url: external_exports.string().nullable(),
  meta: assemblyStatusMetaSchema,
  user_meta: external_exports.record(external_exports.unknown()).optional(),
  as: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).nullable().optional(),
  is_temp_url: external_exports.boolean().optional(),
  queue: external_exports.string().nullable().optional(),
  queue_time: external_exports.number().optional(),
  exec_time: external_exports.number().optional(),
  import_url: external_exports.string().optional(),
  cost: external_exports.union([external_exports.number(), external_exports.null()]).optional()
}).passthrough();
var assemblyStatusUploadsSchema = external_exports.array(assemblyStatusUploadSchema);
var assemblyStatusResultSchema = external_exports.object({
  id: external_exports.string().optional(),
  basename: external_exports.string().nullable().optional(),
  field: external_exports.string().nullable().optional(),
  md5hash: external_exports.string().nullable().optional(),
  original_id: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional(),
  original_basename: external_exports.string().nullable().optional(),
  original_path: external_exports.string().nullable().optional(),
  original_md5hash: external_exports.string().nullable().optional(),
  from_batch_import: external_exports.boolean().optional(),
  is_tus_file: external_exports.boolean().optional(),
  tus_upload_url: external_exports.string().nullable().optional(),
  is_temp_url: external_exports.boolean().optional(),
  cost: external_exports.number().nullable().optional(),
  duration_human: external_exports.string().nullable().optional(),
  duration: external_exports.number().nullable().optional(),
  exec_time: external_exports.number().nullable().optional(),
  ext: external_exports.string().nullable().optional(),
  filepath: external_exports.string().nullable().optional(),
  path: external_exports.string().nullable().optional(),
  height: external_exports.number().nullable().optional(),
  meta: assemblyStatusMetaSchema.nullable().optional(),
  mime: external_exports.string().nullable().optional(),
  name: external_exports.string().nullable().optional(),
  original_name: external_exports.string().nullable().optional(),
  preview: external_exports.string().nullable().optional(),
  queue_time: external_exports.number().nullable().optional(),
  queue: external_exports.string().nullable().optional(),
  size_human: external_exports.string().nullable().optional(),
  size: external_exports.number().nullable().optional(),
  ssl_url: external_exports.string().nullable().optional(),
  type: external_exports.string().nullable().optional(),
  url: external_exports.string().nullable().optional(),
  user_meta: external_exports.record(external_exports.union([external_exports.string(), external_exports.number()])).nullable().optional(),
  width: external_exports.number().nullable().optional(),
  as: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).nullable().optional(),
  queueTime: external_exports.number().nullable().optional(),
  execTime: external_exports.number().nullable().optional(),
  import_url: external_exports.string().optional(),
  signed_url: external_exports.string().optional(),
  signed_ssl_url: external_exports.string().optional(),
  ios_url: external_exports.string().optional(),
  streaming_url: external_exports.string().optional(),
  remote_path: external_exports.string().optional(),
  playlists: external_exports.array(hlsPlaylistSchema).optional(),
  hls_url: external_exports.string().optional(),
  forcedFileExt: external_exports.string().optional(),
  // Robot-specific metadata added at runtime by /vimeo/import
  vimeo: external_exports.object({
    title: external_exports.string(),
    uri: external_exports.string()
  }).optional()
}).passthrough();
var assemblyStatusResultsSchema = external_exports.record(external_exports.array(assemblyStatusResultSchema));
var debugInfoSchema = external_exports.object({
  err: external_exports.unknown().optional(),
  // Or a more specific error type if known
  screenshot_ssl_url: external_exports.string().optional(),
  screenshot_filepath: external_exports.string().optional(),
  screenshot_s3_url: external_exports.string().optional(),
  // Add s3 URL field
  console_filepath: external_exports.string().optional(),
  console_ssl_url: external_exports.string().optional(),
  // Add console SSL URL field
  console_s3_url: external_exports.string().optional()
  // Add console s3 URL field
}).passthrough();
var assemblyStatusBaseSchema = external_exports.object({
  message: external_exports.string().optional(),
  admin_cmd: external_exports.unknown().optional(),
  assemblyId: external_exports.string().optional(),
  assembly_id: external_exports.string().optional(),
  parent_id: external_exports.string().nullable().optional(),
  account_id: external_exports.string().optional(),
  account_name: external_exports.string().nullable().optional(),
  account_slug: external_exports.string().nullable().optional(),
  api_auth_key_id: external_exports.string().nullable().optional(),
  template_id: external_exports.string().nullable().optional(),
  template_name: external_exports.string().nullable().optional(),
  instance: external_exports.string().optional(),
  region: external_exports.string().optional(),
  assembly_url: external_exports.string().optional(),
  assembly_ssl_url: external_exports.string().optional(),
  uppyserver_url: external_exports.string().optional(),
  companion_url: external_exports.string().optional(),
  websocket_url: external_exports.string().optional(),
  update_stream_url: external_exports.string().optional(),
  tus_url: external_exports.string().optional(),
  bytes_received: external_exports.number().optional(),
  bytes_expected: external_exports.number().nullable().optional(),
  upload_duration: external_exports.number().optional(),
  client_agent: external_exports.string().nullable().optional(),
  client_ip: external_exports.string().nullable().optional(),
  client_referer: external_exports.string().nullable().optional(),
  transloadit_client: external_exports.string().nullable().optional(),
  start_date: external_exports.string().optional(),
  upload_meta_data_extracted: external_exports.boolean().optional(),
  warnings: external_exports.array(external_exports.object({ level: external_exports.literal("notice").or(external_exports.literal("warning")), msg: external_exports.string() }).passthrough()).optional(),
  is_infinite: external_exports.boolean().optional(),
  error: external_exports.undefined().optional(),
  has_dupe_jobs: external_exports.boolean().optional(),
  execution_start: external_exports.string().nullable().optional(),
  execution_duration: external_exports.number().nullable().optional(),
  queue_duration: external_exports.number().optional(),
  jobs_queue_duration: external_exports.number().optional(),
  notify_start: external_exports.string().nullable().optional(),
  notify_url: external_exports.string().nullable().optional(),
  notify_status: external_exports.string().nullable().optional(),
  notify_response_code: external_exports.number().nullable().optional(),
  notify_response_data: external_exports.string().nullable().optional(),
  notify_duration: external_exports.number().nullable().optional(),
  last_job_completed: external_exports.string().nullable().optional(),
  fields: external_exports.record(external_exports.unknown()).optional(),
  running_jobs: external_exports.array(external_exports.string()).optional(),
  bytes_usage: external_exports.number().optional(),
  usage_tags: external_exports.string().optional(),
  executing_jobs: external_exports.array(external_exports.string()).optional(),
  started_jobs: external_exports.array(external_exports.string()).optional(),
  parent_assembly_status: external_exports.unknown().nullable().optional(),
  params: external_exports.string().nullable().optional(),
  template: external_exports.string().nullable().optional(),
  merged_params: external_exports.string().nullable().optional(),
  num_input_files: external_exports.number().optional(),
  uploads: assemblyStatusUploadsSchema.optional(),
  results: assemblyStatusResultsSchema.optional(),
  build_id: external_exports.string().optional(),
  expected_tus_uploads: external_exports.number().optional(),
  started_tus_uploads: external_exports.number().optional(),
  finished_tus_uploads: external_exports.number().optional(),
  virusname: external_exports.string().optional(),
  tus_uploads: external_exports.array(external_exports.object({
    filename: external_exports.string(),
    fieldname: external_exports.string(),
    user_meta: external_exports.record(external_exports.unknown()).optional(),
    size: external_exports.number(),
    offset: external_exports.number(),
    finished: external_exports.boolean(),
    upload_url: external_exports.string(),
    local_path: external_exports.string().optional()
  }).passthrough()).optional(),
  debuginfo: debugInfoSchema.optional(),
  step: external_exports.string().optional(),
  previousStep: external_exports.string().optional(),
  worker: external_exports.string().optional(),
  info: external_exports.object({
    retryIn: external_exports.number().optional()
  }).optional()
});
var assemblyStatusBusySchema = external_exports.object({
  ok: assemblyBusyCodeSchema
  // TODO: Does busy status also share base fields? Need example.
  // Assuming for now it might share some base fields but not all recursively?
  // Let's make it extend the *non-recursive* base for now.
}).extend(assemblyStatusBaseSchema.shape).passthrough();
var assemblyStatusOkSchema = assemblyStatusBaseSchema.extend({
  ok: assemblyStatusOkCodeSchema
}).passthrough();
var assemblyStatusErrSchema = assemblyStatusBaseSchema.extend({
  error: assemblyStatusErrCodeSchema,
  ok: external_exports.null().optional(),
  retries: external_exports.number().optional(),
  numRetries: external_exports.number().optional(),
  reason: external_exports.string().optional(),
  step: external_exports.string().optional(),
  previousStep: external_exports.string().optional(),
  file: external_exports.string().optional(),
  name: external_exports.string().optional(),
  path: external_exports.string().optional(),
  exitCode: external_exports.number().nullable().optional(),
  exitSignal: external_exports.string().nullable().optional(),
  stdout: external_exports.string().optional(),
  stderr: external_exports.string().optional(),
  cmd: external_exports.union([external_exports.string(), external_exports.array(external_exports.union([external_exports.string(), external_exports.number()]))]).optional(),
  admin_cmd: external_exports.union([external_exports.string(), external_exports.array(external_exports.union([external_exports.string(), external_exports.number()]))]).optional(),
  worker: external_exports.string().optional(),
  headers: external_exports.record(external_exports.unknown()).optional(),
  retryable: external_exports.boolean().optional(),
  err: external_exports.unknown().optional()
}).passthrough();
var assemblyStatusSysErrSchema = assemblyStatusBaseSchema.extend({
  // Changed from .object()
  // No 'ok' or 'error' discriminator
  errno: external_exports.number(),
  code: external_exports.string(),
  syscall: external_exports.string(),
  path: external_exports.string().optional()
  // Path might be present
  // Consider adding other potential sys error fields if observed later
}).passthrough();
var assemblyStatusSchema = external_exports.union([
  assemblyStatusBusySchema,
  // Use schema defined above
  assemblyStatusOkSchema,
  // Use schema defined above
  assemblyStatusErrSchema,
  // Use schema defined above
  assemblyStatusSysErrSchema
  // Add the new system error state
]);
var assemblyIndexItemSchema = external_exports.object({
  id: external_exports.string(),
  // Likely always present for a list item
  parent_id: assemblyStatusBaseSchema.shape.parent_id.optional(),
  account_id: assemblyStatusBaseSchema.shape.account_id.unwrap().optional(),
  template_id: assemblyStatusBaseSchema.shape.template_id.optional(),
  instance: assemblyStatusBaseSchema.shape.instance.unwrap().optional(),
  notify_url: assemblyStatusBaseSchema.shape.notify_url.optional(),
  redirect_url: external_exports.string().nullable().optional(),
  files: external_exports.string().nullable(),
  // JSON stringified, specific to list item, CAN BE NULL
  warning_count: external_exports.number().optional(),
  execution_duration: assemblyStatusBaseSchema.shape.execution_duration.optional(),
  execution_start: assemblyStatusBaseSchema.shape.execution_start.optional(),
  region: assemblyStatusBaseSchema.shape.region.optional(),
  num_input_files: assemblyStatusBaseSchema.shape.num_input_files.optional(),
  bytes_usage: assemblyStatusBaseSchema.shape.bytes_usage.optional(),
  ok: assemblyStatusOkCodeSchema.nullable().optional(),
  error: assemblyStatusErrCodeSchema.nullable().optional(),
  created: external_exports.string(),
  created_ts: external_exports.number().optional(),
  template_name: external_exports.string().nullable().optional()
}).passthrough();
var assemblyIndexSchema = external_exports.array(assemblyIndexItemSchema);

// node_modules/transloadit/dist/alphalib/zodParseWithContext.js
init_esm();
function getByPath(obj, path2) {
  if (!path2)
    return obj;
  const parts = path2.split(".");
  let current = obj;
  for (const part of parts) {
    if (current == null || typeof current !== "object")
      return void 0;
    current = current[part];
  }
  return current;
}
__name(getByPath, "getByPath");
function zodParseWithContext(schema, obj) {
  const zodRes = schema.safeParse(obj);
  if (!zodRes.success) {
    if (typeof obj === "object" && obj !== null && Object.keys(obj).length === 0 && zodRes.error.errors.length > 0) {
      const firstError = zodRes.error.errors[0];
      if (zodRes.error.errors.length === 1 && firstError && firstError.code === "invalid_union" && firstError.path.length === 0 && Array.isArray(firstError.unionErrors) && firstError.unionErrors.length > 0) {
        const humanReadable2 = "Validation failed: Input object is empty or missing key fields required to determine its type, and does not match any variant of the expected schema. Please provide a valid object.";
        return {
          success: false,
          // For this specific summarized error, we might not need to map all detailed ZodIssueWithContext
          // or we can provide a simplified single error entry reflecting this summary.
          // For now, let's return the original errors but with the new top-level humanReadable.
          errors: zodRes.error.errors.map((e) => ({
            ...e,
            parentObj: obj,
            humanReadable: e.message
          })),
          humanReadable: humanReadable2
        };
      }
    }
    const zodIssuesWithContext = [];
    const badPaths = /* @__PURE__ */ new Map();
    for (const zodIssue of zodRes.error.errors) {
      const lastPath = zodIssue.path;
      let parentObj = {};
      if (lastPath) {
        const strPath = lastPath.slice(0, -1).join(".");
        parentObj = getByPath(obj, strPath) ?? {};
      }
      const path2 = zodIssue.path.map((p) => typeof p === "string" ? p.replaceAll(".", "\\.") : p).join(".");
      if (!badPaths.has(path2)) {
        badPaths.set(path2, []);
      }
      const messages = [];
      if (zodIssue.code === "unrecognized_keys") {
        const maxKeysToShow = 3;
        const { keys } = zodIssue;
        const truncatedKeys = keys.slice(0, maxKeysToShow);
        const ellipsis = keys.length > maxKeysToShow ? "..." : "";
        let message = `has unrecognized keys: ${truncatedKeys.map((k) => `\`${k}\``).join(", ")}${ellipsis}`;
        if (zodIssue.path.length === 0) {
          message += " (Hint: No union variant matched. Check for extra keys or type mismatches in variants.)";
        }
        messages.push(message);
      } else if ("unionErrors" in zodIssue && zodIssue.unionErrors) {
        const collectedLiterals = {};
        const collectedMessages = {};
        for (const unionError of zodIssue.unionErrors) {
          for (const issue of unionError.issues) {
            const nestedPath = issue.path.join(".");
            if (!collectedLiterals[nestedPath])
              collectedLiterals[nestedPath] = [];
            if (!collectedMessages[nestedPath])
              collectedMessages[nestedPath] = /* @__PURE__ */ new Set();
            if (issue.code === "custom" && issue.message.includes("interpolation string")) {
              continue;
            }
            if (issue.code === "invalid_literal") {
              const { expected } = issue;
              if (expected !== void 0 && expected !== null && (typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean")) {
                collectedLiterals[nestedPath].push(expected);
              }
              collectedMessages[nestedPath].add(issue.message);
            } else if (issue.code === "invalid_enum_value") {
              const { options } = issue;
              if (options && options.length > 0) {
                collectedLiterals[nestedPath].push(...options.map(String));
              }
              collectedMessages[nestedPath].add(issue.message);
            } else if (issue.code === "unrecognized_keys") {
              const maxKeysToShow = 3;
              const { keys } = issue;
              const truncatedKeys = keys.slice(0, maxKeysToShow);
              const ellipsis = keys.length > maxKeysToShow ? "..." : "";
              collectedMessages[nestedPath].add(`has unrecognized keys: ${truncatedKeys.map((k) => `\`${k}\``).join(", ")}${ellipsis}`);
            } else if (issue.code === "invalid_type") {
              const received = issue.received === "undefined" ? "missing" : issue.received;
              const actualValue = getByPath(parentObj, nestedPath);
              const actualValueStr = typeof actualValue === "object" && actualValue !== null ? JSON.stringify(actualValue) : String(actualValue);
              let expectedOutput = String(issue.expected);
              const MAX_EXPECTED_TO_SHOW = 3;
              if (typeof issue.expected === "string" && issue.expected.includes(" | ")) {
                const expectedValues = issue.expected.split(" | ");
                if (expectedValues.length > MAX_EXPECTED_TO_SHOW) {
                  const shownValues = expectedValues.slice(0, MAX_EXPECTED_TO_SHOW).join(" | ");
                  const remainingCount = expectedValues.length - MAX_EXPECTED_TO_SHOW;
                  expectedOutput = `${shownValues} | .. or ${remainingCount} others ..`;
                }
              }
              collectedMessages[nestedPath].add(`got invalid type: ${received} (value: \`${actualValueStr}\`, expected: ${expectedOutput})`);
            } else {
              collectedMessages[nestedPath].add(issue.message);
            }
          }
        }
        for (const nestedPath in collectedMessages) {
          if (!badPaths.has(nestedPath)) {
            badPaths.set(nestedPath, []);
          }
          const targetMessages = badPaths.get(nestedPath);
          if (!targetMessages) {
            continue;
          }
          const invalidTypeMessages = Array.from(collectedMessages[nestedPath]).filter((m) => m.startsWith("got invalid type:"));
          const unrecognizedKeyMessages = Array.from(collectedMessages[nestedPath]).filter((m) => m.startsWith("has unrecognized keys:"));
          const literalMessages = collectedLiterals[nestedPath] ?? [];
          if (invalidTypeMessages.length > 0) {
            targetMessages.push(...invalidTypeMessages);
          } else if (unrecognizedKeyMessages.length > 0) {
            targetMessages.push(...unrecognizedKeyMessages);
          } else if (literalMessages.length > 0) {
            const uniqueLiterals = [...new Set(literalMessages)];
            targetMessages.push(`should be one of: \`${uniqueLiterals.join("`, `")}\``);
          } else {
            targetMessages.push(...collectedMessages[nestedPath]);
          }
        }
      } else {
        let received;
        let type;
        let bigType;
        switch (zodIssue.code) {
          case "invalid_type": {
            received = zodIssue.received === "undefined" ? "missing" : zodIssue.received;
            const actualValue = getByPath(obj, path2);
            const actualValueStr = typeof actualValue === "object" && actualValue !== null ? JSON.stringify(actualValue) : String(actualValue);
            messages.push(`got invalid type: ${received} (value: \`${actualValueStr}\`)`);
            break;
          }
          case "invalid_string":
            if (zodIssue.validation === "email") {
              messages.push("should be a valid email address");
            } else if (zodIssue.validation === "url") {
              messages.push("should be a valid URL");
            } else {
              messages.push(zodIssue.message);
            }
            break;
          case "too_small":
            type = zodIssue.type === "string" ? "characters" : "items";
            messages.push(`should have at least ${zodIssue.minimum} ${type}`);
            break;
          case "too_big":
            bigType = zodIssue.type === "string" ? "characters" : "items";
            messages.push(`should have at most ${zodIssue.maximum} ${bigType}`);
            break;
          case "custom":
            messages.push(zodIssue.message);
            break;
          default:
            messages.push(zodIssue.message);
        }
      }
      if (messages.length > 0) {
        badPaths.get(path2)?.push(...messages);
      }
      const field = path2 || "Input";
      const issueSpecificMessages = badPaths.get(path2) ?? messages;
      const humanReadable2 = `Path \`${field}\` ${issueSpecificMessages.join(", ")}`;
      zodIssuesWithContext.push({
        ...zodIssue,
        parentObj,
        humanReadable: humanReadable2
      });
    }
    const errorList = Array.from(badPaths.entries()).map(([path2, messages]) => {
      const field = path2 || "Input";
      return ` - \`${field}\`: ${messages.join(", ")}`;
    }).join("\n");
    const humanReadable = `Validation failed for the following fields:
${errorList}`;
    return { success: false, errors: zodIssuesWithContext, humanReadable };
  }
  return { success: true, safe: zodRes.data, errors: [], humanReadable: "" };
}
__name(zodParseWithContext, "zodParseWithContext");

// node_modules/transloadit/dist/bearerToken.js
init_esm();
var tokenErrorSchema = external_exports.object({
  error: external_exports.string(),
  message: external_exports.string().optional()
}).passthrough();
var tokenSuccessSchema = external_exports.object({
  access_token: external_exports.string().min(1),
  token_type: external_exports.literal("Bearer").optional(),
  expires_in: external_exports.number(),
  scope: external_exports.string().optional()
}).passthrough();
var buildBasicAuthHeaderValue = /* @__PURE__ */ __name((credentials) => `Basic ${Buffer.from(`${credentials.authKey}:${credentials.authSecret}`, "utf8").toString("base64")}`, "buildBasicAuthHeaderValue");
var isLoopbackHost = /* @__PURE__ */ __name((hostname) => hostname === "localhost" || hostname === "::1" || hostname.startsWith("127."), "isLoopbackHost");
var normalizeTokenBaseEndpoint = /* @__PURE__ */ __name((raw) => {
  const baseRaw = (raw || process.env.TRANSLOADIT_ENDPOINT || "https://api2.transloadit.com").trim();
  let url;
  try {
    url = new URL(baseRaw);
  } catch {
    return {
      ok: false,
      error: "Invalid endpoint URL. Use --endpoint https://api2.transloadit.com (or set TRANSLOADIT_ENDPOINT)."
    };
  }
  if (url.username || url.password) {
    return { ok: false, error: "Endpoint must not include username/password." };
  }
  if (url.search || url.hash) {
    return { ok: false, error: "Endpoint must not include query string or hash." };
  }
  if (url.protocol !== "https:") {
    if (url.protocol === "http:" && isLoopbackHost(url.hostname)) {
    } else {
      return {
        ok: false,
        error: "Refusing to send credentials to a non-HTTPS endpoint. Use https://... (or http://localhost for local development)."
      };
    }
  }
  const pathLower = url.pathname.toLowerCase();
  if (pathLower === "/token" || pathLower === "/token/") {
    url.pathname = "/";
  }
  if (!url.pathname.endsWith("/")) {
    url.pathname = `${url.pathname}/`;
  }
  return { ok: true, baseUrl: url };
}, "normalizeTokenBaseEndpoint");
var normalizeScopeInput = /* @__PURE__ */ __name((input) => {
  if (input == null)
    return void 0;
  const raw = Array.isArray(input) ? input.join(" ") : String(input);
  const trimmed = raw.trim();
  if (!trimmed)
    return void 0;
  const parts = trimmed.split(/[\s,]+/).map((p) => p.trim());
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const part of parts) {
    if (!part || seen.has(part))
      continue;
    seen.add(part);
    out.push(part);
  }
  return out.length > 0 ? out.join(" ") : void 0;
}, "normalizeScopeInput");
async function mintBearerTokenWithCredentials(credentials, options = {}) {
  const endpointResult = normalizeTokenBaseEndpoint(options.endpoint);
  if (!endpointResult.ok) {
    return { ok: false, error: endpointResult.error };
  }
  const url = new URL("token", endpointResult.baseUrl).toString();
  const aud = (options.aud ?? "mcp").trim() || "mcp";
  const scope = normalizeScopeInput(options.scope);
  const timeoutMs = options.timeoutMs ?? 15e3;
  const params = new URLSearchParams({
    grant_type: "client_credentials",
    aud
  });
  if (scope)
    params.set("scope", scope);
  let res;
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    res = await fetch(url, {
      method: "POST",
      // Never follow redirects with Basic Auth credentials.
      redirect: "error",
      signal: controller.signal,
      headers: {
        Authorization: buildBasicAuthHeaderValue(credentials),
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params.toString()
    });
  } catch (err) {
    clearTimeout(timeout);
    if (err instanceof Error && err.name === "AbortError") {
      return {
        ok: false,
        error: `Failed to mint bearer token: request timed out after ${Math.round(timeoutMs / 1e3)}s.`
      };
    }
    const message = err instanceof Error ? err.message : String(err);
    return { ok: false, error: `Failed to mint bearer token: ${message}` };
  } finally {
    clearTimeout(timeout);
  }
  const text = await res.text();
  const trimmed = text.trim();
  let parsedJson = null;
  try {
    parsedJson = trimmed ? JSON.parse(trimmed) : null;
  } catch {
    parsedJson = null;
  }
  if (res.ok) {
    if (parsedJson == null) {
      return { ok: false, error: "Token response was not valid JSON." };
    }
    const parsed = tokenSuccessSchema.safeParse(parsedJson);
    if (!parsed.success) {
      return { ok: false, error: "Token response did not include an access_token." };
    }
    const data = {
      ...parsed.data,
      token_type: parsed.data.token_type ?? "Bearer"
    };
    return { ok: true, raw: trimmed, data };
  }
  const parsedError = tokenErrorSchema.safeParse(parsedJson);
  if (parsedError.success) {
    return {
      ok: false,
      error: parsedError.data.message ? `${parsedError.data.error}: ${parsedError.data.message}` : parsedError.data.error
    };
  }
  return {
    ok: false,
    error: `Token request failed (${res.status}): ${trimmed || res.statusText}`
  };
}
__name(mintBearerTokenWithCredentials, "mintBearerTokenWithCredentials");

// node_modules/transloadit/dist/InconsistentResponseError.js
init_esm();
var InconsistentResponseError = class extends Error {
  static {
    __name(this, "InconsistentResponseError");
  }
  name = "InconsistentResponseError";
};

// node_modules/transloadit/dist/lintAssemblyInstructions.js
init_esm();

// node_modules/transloadit/dist/alphalib/assembly-linter.lang.en.js
init_esm();

// node_modules/transloadit/dist/alphalib/types/stackVersions.js
init_esm();
var stackVersions = {
  ffmpeg: {
    recommendedVersion: "v6",
    test: /^v?[567](\.\d+)?(\.\d+)?$/,
    suggestedValues: ["v5", "v6", "v7"]
  },
  imagemagick: {
    recommendedVersion: "v3",
    test: /^v?[23](\.\d+)?(\.\d+)?$/,
    suggestedValues: ["v2", "v3"]
  }
};

// node_modules/transloadit/dist/alphalib/assembly-linter.lang.en.js
var linterMessages = {
  "smart-cdn-max-steps-exceeded": /* @__PURE__ */ __name((result) => ({
    simple: `Smart CDN Assemblies are limited to ${result.maxStepCount} steps, but found ${result.stepCount} steps`,
    text: `Smart CDN Assemblies are limited to ${result.maxStepCount} steps, but found ${result.stepCount} steps`,
    desc: `
    When using the /file/serve Robot for Smart CDN Assemblies, Transloadit limits the number of steps to ${result.maxStepCount} for performance and security reasons.

    Your Assembly currently has ${result.stepCount} steps. Please reduce the number of steps to ${result.maxStepCount} or fewer. Consider combining operations or restructuring your Assembly.
    `
  }), "smart-cdn-max-steps-exceeded"),
  "smart-cdn-robot-not-allowed": /* @__PURE__ */ __name((result) => {
    const robotName = result.robotName ?? result.robot ?? "unknown";
    return {
      simple: `Robot "${robotName}" is not allowed in Smart CDN Assemblies`,
      text: `Robot \`${robotName}\` is not allowed in Smart CDN Assemblies`,
      desc: `
    Smart CDN Assemblies, which use the /file/serve Robot, only support certain robots for security and performance reasons. The Robot "${robotName}" is not compatible with Smart CDN.

    Please check the [Content Delivery documentation](/services/content-delivery/) for more information about which robots are allowed in Smart CDN Assemblies.
    `
    };
  }, "smart-cdn-robot-not-allowed"),
  "empty-steps": /* @__PURE__ */ __name(() => ({
    simple: `The "steps" property is empty`,
    text: "The `steps` property is empty",
    desc: "The `steps` property is the main part of your Assembly Instructions. It defines which transcoding operations should be performed on your files and in which order. Each property inside `steps` represents a single transcoding operation, although this could be on multiple files passing through."
  }), "empty-steps"),
  "missing-steps": /* @__PURE__ */ __name(() => ({
    simple: `The "steps" property is missing`,
    text: "The `steps` property is missing",
    desc: `
The \`steps\` property is the main part of your Assembly Instructions. It defines which transcoding operations should be performed on your files and in which order. Each property inside \`steps\` represents a single transcoding operation.

Here's an example of a valid \`steps\` structure:

\`\`\`json
{
  "steps": {
    "resize": {
      "robot": "/image/resize",
      "use": ":original",
      "width": 100,
      "height": 100
    },
    "store": {
      "robot": "/s3/store",
      "use": "resize"
    }
  }
}
\`\`\`
`
  }), "missing-steps"),
  "invalid-steps-type": /* @__PURE__ */ __name(() => ({
    simple: `The "steps" property must be an object`,
    text: "The `steps` property must be an object",
    desc: `
The \`steps\` property in your Assembly Instructions must be an object, not an array or any other type. Each key in the \`steps\` object represents a _Step_ name, and its value should be an object describing that Step.

Here's an example of the correct structure:

\`\`\`json
{
  "steps": {
    "resize": {
      "robot": "/image/resize",
      "use": ":original",
      "width": 100,
      "height": 100
    },
    "store": {
      "robot": "/s3/store",
      "use": "resize"
    }
  }
}
\`\`\`

If you've used an array for \`steps\`, convert it to an object where each array item becomes a named _Step_.
`
  }), "invalid-steps-type"),
  "step-is-not-an-object": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is not an object`,
    text: `Step \`${result.stepName}\` is not an object`,
    desc: "Each _Step_ should be an object."
  }), "step-is-not-an-object"),
  "missing-robot": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is missing the "robot" parameter`,
    text: `Step \`${result.stepName}\` is missing the \`robot\` parameter`,
    desc: `
The \`robot\` parameter defines which _Robot_ should be used for a given _Step_. Each _Robot_ performs a specific transcoding operation on the files you give it. For example, /image/resize can resize and add effects to images. A list of available _Robots_ can be found in [the documentation](/docs/robots/#overview).

In order to use the _Robot_, you specify its name in the \`robot\` property. The \`use\` property indicates which files the _Robot_ should be working on. For example:
`
  }), "missing-robot"),
  "undefined-robot": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is using a non-existing Robot "${result.robot}"`,
    text: `Step \`${result.stepName}\` is using a non-existing Robot \`${result.robot}\``,
    desc: `
The \`robot\` parameter defines which _Robot_ should be used for a given _Step_. Each _Robot_ performs a specific transcoding operation on the files it is given. However, the _Robot_ that you are referring to with (\`${result.robot}\`) does not exist. Please have a look at [our documentation](/docs/robots/#overview) for a list of all available _Robots_.
`
  }), "undefined-robot"),
  "missing-url": /* @__PURE__ */ __name(() => ({
    simple: `The "url" property is missing`,
    text: "/html/convert either needs the `use` or `url` parameter",
    desc: `
/html/convert requires either the \`use\` or \`url\`. These are mutually exclusive. If the \`url\` parameter is given, the _Robot_ will create a screenshot of a given website. If the \`use\` parameter is given, the _Robot_ will create a screenshot of a provided HTML document. Here is an example showcasing the \`url\` parameter:
`
  }), "missing-url"),
  "schema-violation": /* @__PURE__ */ __name((result) => ({
    simple: `Schema violation: ${result.message}`,
    text: `Schema violation: ${result.message}`,
    desc: "It is possible that the Instructions do not match the schema."
  }), "schema-violation"),
  "missing-use": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is missing the "use" parameter`,
    text: `Step \`${result.stepName}\` is missing the \`use\` parameter`,
    desc: `
The \`use\` parameter defines which files a _Robot_ should process. You can reference another _Step_ name in order to use its output files as an input for your current _Step_, \`${result.stepName}\`. Alternatively, you can also use the built-in \`:original\` _Step_. In this case, the _Robot_ will process all uploaded files.

In the following example, you can see a pipeline where the _Step_ \`crop_thumbed\` uses the uploaded files from \`:original\` and the _Step_ \`exported\` uses \`:original\` and \`crop_thumbed\` as an input:
`
  }), "missing-use"),
  "missing-use-steps": /* @__PURE__ */ __name(() => ({
    simple: `The "use" parameter is an object and must have a "steps" property`,
    text: "The `use` parameter is an object and must have a `steps` property",
    desc: `
The \`use\` parameter can be a string, an object, or an array. The object form can be used if the output from multiple _Steps_ should be bundled and processed in one take, for instance, to create a single slideshow from many images, as opposed to a slideshow for each individual image.

In this case, the _Steps_ should be listed in the \`steps\` property inside the \`use\` object. In the following example, the \`archived\` _Step_ produces a TAR archive containing the files from the \`:original\` and \`resized\` _Steps_:
`
  }), "missing-use-steps"),
  "undefined-step": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is using a non-existing Step "${result.wrongStepName}"`,
    text: `Step \`${result.stepName}\` references a non-existing Step \`${result.wrongStepName}\``,
    desc: `
The _Step_ \`${result.stepName}\` attempts to use the output files from _Step_ \`${result.wrongStepName}\`, but _Step_ \`${result.wrongStepName}\` does not exist in these _Assembly Instructions_. Please add the missing _Step_ or use another _Step_.
`
  }), "undefined-step"),
  "wrong-use-type": /* @__PURE__ */ __name((result) => ({
    simple: `The "use" parameter must be a string, object, or an array`,
    text: "The `use` parameter must be a string, object, or an array",
    desc: `
The \`use\` parameter can be a string, an object, or an array.

If the _Step_ \`${result.stepName}\` should only process the output of **one other Step**, you can use a string like \`"use": ":original"\`.

If the _Step_ \`${result.stepName}\` should process the output of **multiple Steps individually**, you can use an array, such as: \`"use": [ ":original", "crop_thumbed" ]\`.

If the _Step_ \`${result.stepName}\` should process the output of **multiple Steps combined**, you can use an object, such as in this more complex example:
`
  }), "wrong-use-type"),
  "wrong-step-name": /* @__PURE__ */ __name(() => ({
    simple: `When receiving uploads using "/upload/handle", the Step must be named ":original"`,
    text: "When receiving uploads using `/upload/handle`, the Step must be named `:original`",
    desc: `
There are three constraints when using this _Robot_:

* **not** define a \`use\` parameter, contrary to all other _Robots_
* only use it **once** in a single set of _Assembly Instructions_
* name the _Step_ that it's used in: \`:original\`
`
  }), "wrong-step-name"),
  "missing-input": /* @__PURE__ */ __name(() => ({
    simple: "The Template does not take any input files",
    text: "The _Template_ does not take any input files",
    desc: `
Templates can operate on user-uploaded files, or import files from file storage services and from around the web.

Use [/upload/handle](/docs/robots/#upload-handle) to process uploaded files. Transloadit offers a range of [import _Robot_s](/docs/robots/#service-file-importing) for services like S3, Dropbox, and many others.
`
  }), "missing-input"),
  "no-storage": /* @__PURE__ */ __name(() => ({
    simple: "No storage Robot is used to save the results",
    text: "No storage _Robot_ is used to save the results",
    desc: `
Transloadit stores the encoding results of your _Assemblies_ for only 24 hours on its own servers at \`tmp.transloadit.com\`. After this period, the files will not be available from these locations anymore. To ensure that you are still able to access these files, we recommend to store them on your own servers (such as FTP and SFTP) or export them to cloud provider storage like AWS S3, Google Cloud Storage, or Microsoft Azure Storage.

For all of those destinations and many more, we offer [dedicated export Robots](/docs/robots/#service-file-exporting). For example, if you want to export your encoding results to AWS S3, you can use [/s3/store](/docs/robots/#s3-store) like so:
`
  }), "no-storage"),
  "missing-original-storage": /* @__PURE__ */ __name(() => ({
    simple: "The uploaded files are not stored for later reprocessing",
    text: "The uploaded files are not stored for later reprocessing",
    desc: `
Transloadit stores the uploaded files of your _Assemblies_ for only 24 hours on its own servers at \`tmp.transloadit.com\`. After this period, the files will not be available from these locations anymore. Storing not only the encoded result files but also the files that your users originally uploaded gives you the chance to re-encode them later into different formats as your requirements change. If you do not store them, they are lost forever, as asking your users to upload them again is likely not an option.

In order to store the uploaded files, you can add the \`:original\` _Step_ to the \`use\` parameter in your storage _Step_.
`
  }), "missing-original-storage"),
  "empty-use-array": /* @__PURE__ */ __name((result) => ({
    simple: `The "use" array is empty`,
    text: "The `use` array is empty",
    desc: `
The \`use\` parameter can be a string, an object, or an array. If it is an array, the _Step_ \`${result.stepName}\` will use the output of all _Steps_ that are referenced in the \`use\` parameter as its input. In following example, the \`exported\` _Step_ uses the output files from the \`crop_thumbed\` and the \`:original\` _Steps_:
`
  }), "empty-use-array"),
  "infinite-assembly": /* @__PURE__ */ __name((result) => ({
    simple: `This "use" parameter creates an infinite loop`,
    text: "The `use` parameter creates an infinite loop",
    desc: `
The \`use\` parameter used in _Step_ \`${result.stepName}\` creates an infinite _Assembly_ execution loop. The _Assembly_ will error upon execution. Please make sure that the \`use\` parameter does not create an infinite loop.
`
  }), "infinite-assembly"),
  "invalid-json": /* @__PURE__ */ __name((result) => ({
    simple: result.message ?? "Invalid JSON",
    text: result.message ?? "Invalid JSON",
    desc: `
The _Assembly Instructions_ are written using JSON syntax, but the input above is not in a valid notation. Please consult the error on the editor's left hand side for more details.
`
  }), "invalid-json"),
  "missing-ffmpeg-stack": /* @__PURE__ */ __name((result) => ({
    simple: `${result.robot} should define the "ffmpeg_stack" parameter`,
    text: `${result.robot} should define the \`ffmpeg_stack\` parameter`,
    desc: `
The \`ffmpeg_stack\` parameter specifies which version of the FFmpeg stack should be used for this _Step_. If this parameter is absent, your _Step_ will fall back to an older FFmpeg stack which might not support all the latest features. The current recommendation is to use \`${stackVersions.ffmpeg.recommendedVersion}\`. Other valid values can be found at ${result.isAudioRobot ? "[Audio Encoding Presets](/docs/presets/audio)" : "[Video Encoding Presets](/docs/presets/video/)"}.

Here is an example showcasing the \`ffmpeg_stack\` parameter:
`
  }), "missing-ffmpeg-stack"),
  "wrong-ffmpeg-version": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is using a nonexistent FFmpeg stack "${result.stackVersion}"`,
    text: `Step \`${result.stepName}\` is using a nonexistent FFmpeg stack \`${result.stackVersion}\``,
    desc: `
The \`ffmpeg_stack\` parameter defines which version of our internal FFmpeg stack should be used for a given _Step_. However, the \`ffmpeg_stack\` that you are referring to (\`${result.stackVersion}\`) does not exist. Please have a look at ${result.isAudioRobot ? "[Audio Encoding Presets](/docs/presets/audio)" : "[Video Encoding Presets](/docs/presets/video/)"} for a list of all available versions.

If you are unsure, we recommend using \`${stackVersions.ffmpeg.recommendedVersion}\`.
`
  }), "wrong-ffmpeg-version"),
  "missing-imagemagick-stack": /* @__PURE__ */ __name(() => ({
    simple: `The "imagemagick_stack" parameter is missing`,
    text: "The `imagemagick_stack` parameter is missing",
    desc: `
The \`imagemagick_stack\` parameter specifies which version of the ImageMagick stack should be used for this _Step_. If this parameter is absent, your _Step_ will fall back to an older ImageMagick stack which might not support all the latest features. The current recommendation is to use \`${stackVersions.imagemagick.recommendedVersion}\`. Other valid values can be found at [Supported Image Formats](/docs/supported-formats/#image-formats).

Here is an example showcasing the \`imagemagick_stack\` parameter:
`
  }), "missing-imagemagick-stack"),
  "wrong-imagemagick-version": /* @__PURE__ */ __name((result) => ({
    simple: `Step "${result.stepName}" is using a nonexistent ImageMagick stack "${result.stackVersion}"`,
    text: `Step \`${result.stepName}\` is using a nonexistent ImageMagick stack \`${result.stackVersion}\``,
    desc: `
The \`imagemagick_stack\` parameter defines which version of our internal ImageMagick stack should be used for a given _Step_. However, the \`imagemagick_stack\` that you are referring to (\`${result.stackVersion}\`) does not exist. Please have a look at [Supported Image Formats](/docs/supported-formats/#image-formats) for a list of all available versions.

If you are unsure, we recommend using \`${stackVersions.imagemagick.recommendedVersion}\`.
`
  }), "wrong-imagemagick-version"),
  "unqualified-http-import-url": /* @__PURE__ */ __name((result) => ({
    simple: `The /http/import url in Step "${result.stepName}" should start with a protocol and domain name`,
    text: `The \`url\` parameter in Step \`${result.stepName}\` should start with a protocol and domain name`,
    desc: `
When using the /http/import Robot, it's important to prefix any path variable with a full URL including the protocol, domain/bucket name, and optionally folder, in the \`url\` or \`path\` parameter. This ensures that Transloadit only imports files from intended sources and attackers can't just import from any source.

Signature Authentication can also help prevent this, but it's recommended to have layers of protection against this if you can.

Instead of using a relative URL or just a field variable like \`\${'{fields.input}'}\`, you should provide a complete URL. For example:

\`\`\`json
"${result.stepName}": {
  "robot": "/http/import",
  "url": "https://example.com/\${fields.input}"
}
\`\`\`

This practice helps prevent potential security issues by ensuring that files are only imported from specified domains.
`
  }), "unqualified-http-import-url"),
  "duplicate-key-in-step": /* @__PURE__ */ __name((result) => ({
    simple: `Duplicate key(s) found${result.stepName ? ` in Step "${result.stepName}"` : ""}: ${result.duplicateKeys?.join(", ")}`,
    text: `Duplicate key(s) found${result.stepName ? ` in Step \`${result.stepName}\`` : ""}: \`${result.duplicateKeys?.join(", ")}\``,
    desc: `
Each key within an object must be unique. Duplicate keys can lead to unexpected behavior and may cause some settings to be overwritten.

Please remove or rename the duplicate key(s)${result.stepName ? ` in the _Step_ \`${result.stepName}\`` : ""} to ensure that each key is unique.
`
  }), "duplicate-key-in-step"),
  "smart-cdn-input-field-missing": /* @__PURE__ */ __name(() => ({
    simple: "Smart CDN path component available as ${fields.input}",
    text: `You may have accidentally omitted the Smart CDN's \`\${'{fields.input}'}\` path component`,
    desc: `
When using Transloadit's Smart CDN with the  /file/serve Robot, the path component of the URL is automatically made available as \`\${'{fields.input}'}\`. For example, if your Smart CDN URL is \`https://my-app.tlcdn.com/img-preview/cities/amsterdam.jpg?w=400\`, then \`\${'{fields.input}'}\` would be set to \`/cities/amsterdam.jpg\`.

This is typically used to fetch the correct file from your storage bucket, before transforming and serving it. While the Smart CDN can be used in other ways, you may want to check if you accidentally omitted the \`\${'{fields.input}'}\` path component in your import _Step_. For example:

\`\`\`json
"imported": {
  "robot": "/http/import",
  "url": "https://example.com/\${fields.input}"
}
\`\`\`
`,
    example: `{
  "robot": "/file/serve",
  "url": "s3://my-bucket\${fields.input}"
}`
  }), "smart-cdn-input-field-missing")
};
var firstNonEmptyLine = /* @__PURE__ */ __name((text) => text.split("\n").map((line) => line.trim()).find((line) => line.length > 0), "firstNonEmptyLine");
var getLintIssueDescription = /* @__PURE__ */ __name((issue) => {
  const message = linterMessages[issue.code](issue);
  return message.desc.trim();
}, "getLintIssueDescription");
var getLintIssueSummary = /* @__PURE__ */ __name((issue) => {
  if (issue.message)
    return issue.message;
  const fromDesc = issue.desc ?? getLintIssueDescription(issue);
  return firstNonEmptyLine(fromDesc) ?? issue.code;
}, "getLintIssueSummary");
var hydrateLintIssue = /* @__PURE__ */ __name((issue) => {
  const desc = issue.desc ?? getLintIssueDescription(issue);
  const summary = getLintIssueSummary({ ...issue, desc });
  return { ...issue, desc, summary };
}, "hydrateLintIssue");
var hydrateLintIssues = /* @__PURE__ */ __name((issues) => issues.map((issue) => hydrateLintIssue(issue)), "hydrateLintIssues");

// node_modules/transloadit/dist/alphalib/assembly-linter.js
init_esm();
var import_json_to_ast = __toESM(require_build(), 1);

// node_modules/transloadit/dist/alphalib/object.js
init_esm();
function entries2(object) {
  return Object.entries(object);
}
__name(entries2, "entries");

// node_modules/transloadit/dist/alphalib/stepParsing.js
init_esm();

// node_modules/transloadit/dist/alphalib/types/robots/_index.js
init_esm();

// node_modules/transloadit/dist/alphalib/types/robots/ai-chat.js
init_esm();

// node_modules/transloadit/dist/alphalib/types/robots/_instructions-primitives.js
init_esm();
var robotNames = external_exports.enum([
  "AiChatRobot",
  "UploadHandleRobot",
  "FileServeRobot",
  "FileWatermarkRobot",
  "FileVerifyRobot",
  "EdglyDeliverRobot",
  "TlcdnDeliverRobot",
  "VideoSubtitleRobot",
  "VideoEncodeRobot",
  "VideoAdaptiveRobot",
  "VideoMergeRobot",
  "VideoConcatRobot",
  "AudioWaveformRobot",
  "AudioEncodeRobot",
  "AudioLoopRobot",
  "AudioConcatRobot",
  "AudioMergeRobot",
  "AudioArtworkRobot",
  "ImageFacedetectRobot",
  "ImageDescribeRobot",
  "ImageOcrRobot",
  "ImageBgremoveRobot",
  "ImageGenerateRobot",
  "DocumentOcrRobot",
  "SpeechTranscribeRobot",
  "VideoThumbsRobot",
  "FileVirusscanRobot",
  "ImageOptimizeRobot",
  "FileCompressRobot",
  "MetaReadRobot",
  "FileDecompressRobot",
  "MetaWriteRobot",
  "DocumentThumbsRobot",
  "DocumentConvertRobot",
  "DocumentMergeRobot",
  "DocumentSplitRobot",
  "DocumentOptimizeRobot",
  "DocumentAutorotateRobot",
  "HtmlConvertRobot",
  "ImageResizeRobot",
  "ImageMergeRobot",
  "S3ImportRobot",
  "S3StoreRobot",
  "DigitalOceanImportRobot",
  "DigitalOceanStoreRobot",
  "BackblazeImportRobot",
  "BackblazeStoreRobot",
  "MinioImportRobot",
  "TigrisImportRobot",
  "CloudflareImportRobot",
  "SupabaseImportRobot",
  "MinioStoreRobot",
  "TigrisStoreRobot",
  "CloudflareStoreRobot",
  "SupabaseStoreRobot",
  "WasabiImportRobot",
  "WasabiStoreRobot",
  "SwiftImportRobot",
  "SwiftStoreRobot",
  "GoogleImportRobot",
  "GoogleStoreRobot",
  "DropboxImportRobot",
  "DropboxStoreRobot",
  "HttpImportRobot",
  "SftpImportRobot",
  "SftpStoreRobot",
  "FtpImportRobot",
  "FtpStoreRobot",
  "CloudfilesImportRobot",
  "CloudfilesStoreRobot",
  "AzureImportRobot",
  "AzureStoreRobot",
  "YoutubeStoreRobot",
  "VimeoImportRobot",
  "VimeoStoreRobot",
  "AssemblySavejsonRobot",
  "ScriptRunRobot",
  "FileHashRobot",
  "FileReadRobot",
  "VideoOndemandRobot",
  "FileFilterRobot",
  "TextSpeakRobot",
  "TextTranslateRobot",
  "FilePreviewRobot",
  "TusStoreRobot",
  "ProgressSimulateRobot"
]);
var robotMetaSchema = external_exports.object({
  // Added keys from api2/lib/config.ts:
  name: robotNames,
  priceFactor: external_exports.number(),
  queueSlotCount: external_exports.number(),
  downloadInputFiles: external_exports.boolean().optional(),
  preserveInputFileUrls: external_exports.boolean().optional(),
  minimumCharge: external_exports.number().optional(),
  minimumChargeUsd: external_exports.number().optional(),
  minimumChargeUsdPerSpeechTranscribeMinute: external_exports.object({
    aws: external_exports.number(),
    gcp: external_exports.number()
  }).optional(),
  minimumChargeUsdPerDocumentOcrPage: external_exports.object({
    aws: external_exports.number(),
    gcp: external_exports.number()
  }).optional(),
  isAllowedForUrlTransform: external_exports.boolean(),
  removeJobResultFilesFromDiskRightAfterStoringOnS3: external_exports.boolean(),
  lazyLoad: external_exports.boolean().optional(),
  installVersionFile: external_exports.string().optional(),
  trackOutputFileSize: external_exports.boolean().optional(),
  isInternal: external_exports.boolean(),
  numDaemons: external_exports.number().optional(),
  stage: external_exports.enum(["alpha", "beta", "ga", "deprecated", "removed"]),
  importRanges: external_exports.array(external_exports.string()).optional(),
  extraChargeForImageResize: external_exports.number().optional(),
  // Original keys from content repo:
  allowed_for_url_transform: external_exports.boolean(),
  bytescount: external_exports.number(),
  description: external_exports.string().optional(),
  discount_factor: external_exports.number(),
  discount_pct: external_exports.number(),
  // To avoid a cycling dependency back to template.ts, we'll use any for now:
  // example_code: assemblyInstructionsSchema.optional(),
  example_code: external_exports.any().optional(),
  example_code_description: external_exports.string().optional(),
  extended_description: external_exports.string().optional(),
  has_small_icon: external_exports.literal(true).optional(),
  minimum_charge: external_exports.number(),
  minimum_charge_usd: external_exports.union([external_exports.number(), external_exports.record(external_exports.string(), external_exports.number())]).optional(),
  minimum_charge_usd_note: external_exports.string().optional(),
  ogimage: external_exports.string().optional(),
  marketing_intro: external_exports.string().optional(),
  output_factor: external_exports.number(),
  override_lvl1: external_exports.string().optional(),
  purpose_sentence: external_exports.string(),
  purpose_verb: external_exports.enum([
    "auto-rotate",
    "cache & deliver",
    "compress",
    "concatenate",
    "convert",
    "decompress",
    "detect",
    "encode",
    "export",
    "extract",
    "filter",
    "generate",
    "handle",
    "hash",
    "import",
    "loop",
    "merge",
    "optimize",
    "read",
    "recognize",
    "run",
    "scan",
    "serve",
    "speak",
    "subtitle",
    "take",
    "transcode",
    "transcribe",
    "translate",
    "verify",
    "remove",
    "write",
    "stream"
  ]),
  purpose_word: external_exports.string(),
  purpose_words: external_exports.string(),
  requires_credentials: external_exports.literal(true).optional(),
  service_slug: external_exports.enum([
    "artificial-intelligence",
    "audio-encoding",
    "code-evaluation",
    "content-delivery",
    "document-processing",
    "file-compressing",
    "file-exporting",
    "file-filtering",
    "file-importing",
    "handling-uploads",
    "image-manipulation",
    "media-cataloging",
    "video-encoding"
  ]),
  slot_count: external_exports.number(),
  title: external_exports.string(),
  typical_file_size_mb: external_exports.number(),
  typical_file_type: external_exports.enum([
    "audio file",
    "audio or video file",
    "document",
    "file",
    "image",
    "video",
    "webpage"
  ]),
  uses_tools: external_exports.array(external_exports.enum(["ffmpeg", "imagemagick"])).optional()
});
var interpolationRegexFull = /^\${.+}$/;
var interpolationSchemaFull = external_exports.custom((input) => typeof input === "string" && interpolationRegexFull.test(input), "Must be a full interpolation string");
var interpolationRegexPartial = /\${.+}/;
var interpolationSchemaPartial = external_exports.custom((input) => typeof input === "string" && interpolationRegexPartial.test(input), "Must be a partially interpolatable string");
var booleanStringSchema = external_exports.enum(["true", "false"]);
function interpolateRecursive(schema) {
  const def = schema._def;
  switch (def.typeName) {
    case external_exports.ZodFirstPartyTypeKind.ZodBoolean:
      return external_exports.union([
        interpolationSchemaFull,
        external_exports.union([schema, booleanStringSchema]).transform((value) => value === true || value === false)
      ]);
    case external_exports.ZodFirstPartyTypeKind.ZodArray: {
      let replacement = external_exports.array(interpolateRecursive(def.type), def);
      if (def.exactLength != null) {
        replacement = replacement.min(def.exactLength.value, def.exactLength.message);
      }
      if (def.maxLength != null) {
        replacement = replacement.min(def.maxLength.value, def.maxLength.message);
      }
      if (def.minLength != null) {
        replacement = replacement.min(def.minLength.value, def.minLength.message);
      }
      return external_exports.union([interpolationSchemaFull, replacement]);
    }
    case external_exports.ZodFirstPartyTypeKind.ZodDefault: {
      const replacement = interpolateRecursive(def.innerType).default(def.defaultValue());
      return def.description ? replacement.describe(def.description) : replacement;
    }
    case external_exports.ZodFirstPartyTypeKind.ZodEffects:
    case external_exports.ZodFirstPartyTypeKind.ZodEnum:
    case external_exports.ZodFirstPartyTypeKind.ZodLiteral:
      return external_exports.union([interpolationSchemaFull, schema], def);
    case external_exports.ZodFirstPartyTypeKind.ZodNumber:
      return external_exports.union([
        external_exports.string().regex(/^\d+(\.\d+)?$/).transform((value) => Number(value)),
        interpolationSchemaFull,
        schema
      ], def);
    case external_exports.ZodFirstPartyTypeKind.ZodNullable:
      return interpolateRecursive(def.innerType).nullable().describe(def.description);
    case external_exports.ZodFirstPartyTypeKind.ZodObject: {
      const replacement = external_exports.object(Object.fromEntries(Object.entries(def.shape()).map(([key, nested]) => [
        key,
        interpolateRecursive(nested)
      ])), def);
      return external_exports.union([
        interpolationSchemaFull,
        def.unknownKeys === "strict" ? replacement.strict() : def.unknownKeys === "passthrough" ? replacement.passthrough() : replacement
      ]);
    }
    case external_exports.ZodFirstPartyTypeKind.ZodOptional:
      return external_exports.optional(interpolateRecursive(def.innerType), def);
    case external_exports.ZodFirstPartyTypeKind.ZodRecord:
      return external_exports.record(def.keyType, interpolateRecursive(def.valueType), def);
    case external_exports.ZodFirstPartyTypeKind.ZodString:
      return external_exports.union([interpolationSchemaPartial, schema], def);
    case external_exports.ZodFirstPartyTypeKind.ZodTuple: {
      const tuple = external_exports.tuple(def.items.map(interpolateRecursive), def);
      return external_exports.union([
        interpolationSchemaFull,
        def.rest ? tuple.rest(def.rest) : tuple
      ]);
    }
    case external_exports.ZodFirstPartyTypeKind.ZodUnion:
      return external_exports.union([interpolationSchemaFull, ...def.options.map(interpolateRecursive)], def);
    default:
      return schema;
  }
}
__name(interpolateRecursive, "interpolateRecursive");
var uninterpolatableKeys = ["robot", "use"];
function interpolateRobot(schema) {
  const def = schema._def;
  return external_exports.object(Object.fromEntries(Object.entries(def.shape()).map(([key, nested]) => [
    key,
    uninterpolatableKeys.includes(key) ? nested : interpolateRecursive(nested)
  ])), def).strict();
}
__name(interpolateRobot, "interpolateRobot");
var robotBase = external_exports.object({
  output_meta: external_exports.union([external_exports.record(external_exports.boolean()), external_exports.boolean(), external_exports.array(external_exports.string())]).optional().describe(`
Allows you to specify a set of metadata that is more expensive on CPU power to calculate, and thus is disabled by default to keep your Assemblies processing fast.

For images, you can add \`"has_transparency": true\` in this object to extract if the image contains transparent parts and \`"dominant_colors": true\` to extract an array of hexadecimal color codes from the image.

For videos, you can add the \`"colorspace: true"\` parameter to extract the colorspace of the output video.

For audio, you can add \`"mean_volume": true\` to get a single value representing the mean average volume of the audio file.

You can also set this to \`false\` to skip metadata extraction and speed up transcoding.
`),
  result: external_exports.boolean().default(false).describe("Whether the results of this Step should be present in the Assembly Status JSON"),
  queue: external_exports.enum(["batch"]).optional().describe(`Setting the queue to 'batch', manually downgrades the priority of jobs for this step to avoid consuming Priority job slots for jobs that don't need zero queue waiting times`),
  force_accept: external_exports.boolean().default(false).describe(`Force a Robot to accept a file type it would have ignored.

By default, Robots ignore files they are not familiar with.
[/video/encode](/docs/robots/video-encode/), for
example, will happily ignore input images.

With the \`force_accept\` parameter set to \`true\`, you can force Robots to accept all files thrown at them.
This will typically lead to errors and should only be used for debugging or combatting edge cases.
`),
  ignore_errors: external_exports.union([external_exports.boolean(), external_exports.array(external_exports.enum(["meta", "execute"]))]).transform((value) => value === true ? ["meta", "execute"] : value === false ? [] : value).default([]).describe(`
Ignore errors during specific phases of processing.

Setting this to \`["meta"]\` will cause the Robot to ignore errors during metadata extraction.

Setting this to \`["execute"]\` will cause the Robot to ignore errors during the main execution phase.

Setting this to \`true\` is equivalent to \`["meta", "execute"]\` and will ignore errors in both phases.
`)
}).strict();
var useParamObjectSchema = external_exports.object({
  name: external_exports.string(),
  fields: external_exports.string().optional(),
  as: external_exports.string().optional()
}).strict();
var useParamStringSchema = external_exports.string();
var useParamArrayOfStringsSchema = external_exports.array(useParamStringSchema);
var useParamArrayOfUseParamObjectSchema = external_exports.array(useParamObjectSchema);
var useParamStepsSchema = external_exports.union([
  useParamStringSchema,
  useParamArrayOfStringsSchema,
  useParamArrayOfUseParamObjectSchema
]);
var useParamObjectOfStepsSchema = external_exports.object({
  steps: useParamStepsSchema,
  bundle_steps: external_exports.boolean().optional(),
  group_by_original: external_exports.boolean().optional(),
  fields: external_exports.array(external_exports.string()).optional().describe(`
Array of field names to filter input files by when using steps.
`)
}).strict();
var useParamObjectWithHiddenFieldsSchema = useParamObjectSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), external_exports.boolean()]).optional()
});
var useParamArrayOfUseParamObjectWithHiddenFieldsSchema = external_exports.array(useParamObjectWithHiddenFieldsSchema);
var useParamStepsWithHiddenFieldsSchema = external_exports.union([
  useParamStringSchema,
  useParamArrayOfStringsSchema,
  useParamArrayOfUseParamObjectWithHiddenFieldsSchema
]);
var useParamObjectOfStepsWithHiddenFieldsSchema = external_exports.object({
  steps: useParamStepsWithHiddenFieldsSchema,
  bundle_steps: external_exports.boolean().optional(),
  group_by_original: external_exports.boolean().optional(),
  fields: external_exports.array(external_exports.string()).optional().describe(`
Array of field names to filter input files by when using steps.
`)
}).strict();
var robotUse = external_exports.object({
  use: external_exports.union([useParamStepsSchema, useParamObjectOfStepsSchema]).describe(`
Specifies which Step(s) to use as input.

- You can pick any names for Steps except \`":original"\` (reserved for user uploads handled by Transloadit)
- You can provide several Steps as input with arrays:
  \`\`\`json
  {
    "use": [
      ":original",
      "encoded",
      "resized"
    ]
  }
  \`\`\`

> [!Tip]
> That's likely all you need to know about \`use\`, but you can view [Advanced use cases](/docs/topics/use-parameter/).
`).optional()
}).strict();
var robotUseWithHiddenFields = external_exports.object({
  use: external_exports.union([useParamStepsWithHiddenFieldsSchema, useParamObjectOfStepsWithHiddenFieldsSchema]).describe(`
Specifies which Step(s) to use as input.

- You can pick any names for Steps except \`":original"\` (reserved for user uploads handled by Transloadit)
- You can provide several Steps as input with arrays:
  \`\`\`json
  {
    "use": [
      ":original",
      "encoded",
      "resized"
    ]
  }
  \`\`\`

> [!Tip]
> That's likely all you need to know about \`use\`, but you can view [Advanced use cases](/docs/topics/use-parameter/).
`).optional()
}).strict();
var complexWidthSchema = external_exports.preprocess((val) => {
  if (typeof val === "string" && val.startsWith("${")) {
    return val;
  }
  if (typeof val === "string") {
    const num = Number.parseInt(val, 10);
    if (Number.isNaN(num) || val.includes("x")) {
      return val;
    }
    return num;
  }
  return val;
}, external_exports.number().int().min(1).max(7680));
var complexHeightSchema = external_exports.preprocess((val) => {
  if (typeof val === "string" && val.startsWith("${")) {
    return val;
  }
  if (typeof val === "string") {
    const num = Number.parseInt(val, 10);
    if (Number.isNaN(num) || val.includes("x")) {
      return val;
    }
    return num;
  }
  return val;
}, external_exports.number().int().min(1).max(4320));
var robotFFmpeg = external_exports.object({
  ffmpeg: external_exports.object({
    af: external_exports.string().optional(),
    "b:a": external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    "b:v": external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    "c:a": external_exports.string().optional(),
    "c:v": external_exports.string().optional(),
    "codec:a": external_exports.string().optional(),
    "codec:v": external_exports.string().optional(),
    "filter:v": external_exports.string().optional(),
    "filter:a": external_exports.string().optional(),
    bits_per_mb: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    ss: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    t: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    to: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    vendor: external_exports.string().optional(),
    shortest: external_exports.boolean().nullish(),
    filter_complex: external_exports.union([external_exports.string(), external_exports.record(external_exports.string())]).optional(),
    "level:v": external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    "profile:v": external_exports.union([external_exports.number(), external_exports.enum(["baseline", "main", "high", "main10"])]).optional(),
    "qscale:a": external_exports.number().optional(),
    "qscale:v": external_exports.number().optional(),
    "x264-params": external_exports.string().optional(),
    "overshoot-pct": external_exports.number().optional(),
    deadline: external_exports.string().optional(),
    "cpu-used": external_exports.string().optional(),
    "undershoot-pct": external_exports.number().optional(),
    "row-mt": external_exports.number().optional(),
    "x265-params": external_exports.object({
      "vbv-maxrate": external_exports.number().optional(),
      "vbv-bufsize": external_exports.number().optional(),
      "rc-lookahead": external_exports.number().optional(),
      "b-adapt": external_exports.number().optional()
    }).strict().optional(),
    "svtav1-params": external_exports.object({
      tune: external_exports.number().optional(),
      "enable-qm": external_exports.number().optional(),
      "fast-decode": external_exports.number().optional(),
      "film-grain-denoise": external_exports.number().optional()
    }).strict().optional(),
    ac: external_exports.number().optional(),
    an: external_exports.boolean().optional(),
    ar: external_exports.number().optional(),
    async: external_exports.number().optional(),
    b: external_exports.union([
      external_exports.object({
        v: external_exports.number().optional(),
        a: external_exports.number().optional()
      }).strict(),
      external_exports.string()
    ]).optional(),
    bt: external_exports.union([external_exports.number(), external_exports.string()]).optional(),
    bufsize: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    c: external_exports.string().optional(),
    codec: external_exports.object({
      v: external_exports.string().optional(),
      a: external_exports.string().optional()
    }).strict().optional(),
    coder: external_exports.number().optional(),
    crf: external_exports.number().optional(),
    f: external_exports.string().optional(),
    flags: external_exports.string().optional(),
    g: external_exports.number().optional(),
    i_qfactor: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    keyint_min: external_exports.number().optional(),
    level: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    map: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional(),
    maxrate: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    me_range: external_exports.number().optional(),
    movflags: external_exports.string().optional(),
    partitions: external_exports.string().optional(),
    pix_fmt: external_exports.string().optional(),
    preset: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    profile: external_exports.string().optional(),
    "q:a": external_exports.number().optional(),
    qcomp: external_exports.union([external_exports.string(), external_exports.number()]).optional(),
    qdiff: external_exports.number().optional(),
    qmax: external_exports.number().optional(),
    qmin: external_exports.number().optional(),
    r: external_exports.union([external_exports.number(), external_exports.string()]).nullable().optional(),
    rc_eq: external_exports.string().optional(),
    refs: external_exports.number().optional(),
    s: external_exports.string().optional(),
    sc_threshold: external_exports.number().optional(),
    sws_flags: external_exports.string().optional(),
    threads: external_exports.number().optional(),
    trellis: external_exports.number().optional(),
    transloaditffpreset: external_exports.literal("empty").optional(),
    vn: external_exports.boolean().optional(),
    vf: external_exports.string().optional(),
    x264opts: external_exports.string().optional(),
    vbr: external_exports.union([external_exports.string(), external_exports.number()]).optional()
  }).passthrough().optional().describe(`
A parameter object to be passed to FFmpeg. If a preset is used, the options specified are merged on top of the ones from the preset. For available options, see the [FFmpeg documentation](https://ffmpeg.org/ffmpeg-doc.html). Options specified here take precedence over the preset options.
`),
  ffmpeg_stack: external_exports.union([external_exports.enum(["v5", "v6", "v7"]), external_exports.string().regex(/^v?[567](\.\d+)?(\.\d+)?$/)]).default("v5.0.0").describe(`
Selects the FFmpeg stack version to use for encoding. These versions reflect real FFmpeg versions. We currently recommend to use "v6.0.0".
`)
});
function transformPreset(preset2) {
  return preset2.replaceAll("_", "-");
}
__name(transformPreset, "transformPreset");
function* generateCombinations(chunks) {
  if (chunks.length === 0) {
    return;
  }
  if (chunks.length === 1) {
    yield chunks[0];
  }
  const [head, ...remaining] = chunks;
  for (const result of generateCombinations(remaining)) {
    yield `${head}-${result}`;
    yield `${head}_${result}`;
  }
}
__name(generateCombinations, "generateCombinations");
function createPresets(inputs) {
  const results = [];
  for (const input of inputs) {
    results.push(...generateCombinations(input.split("-")));
  }
  return [...results].sort();
}
__name(createPresets, "createPresets");
var audioPresets = createPresets([
  "aac",
  "alac",
  "audio/aac",
  "audio/alac",
  "audio/flac",
  "audio/mp3",
  "audio/ogg",
  "dash-32k-audio",
  "dash-64k-audio",
  "dash-128k-audio",
  "dash-256k-audio",
  "dash/32k-audio",
  "dash/64k-audio",
  "dash/128k-audio",
  "dash/256k-audio",
  "empty",
  "flac",
  "hg-transformers-audio",
  "mp3",
  "ogg",
  "opus",
  "speech",
  "wav"
]);
var robotFFmpegAudio = robotFFmpeg.extend({
  preset: external_exports.enum(audioPresets).transform(transformPreset).optional().describe(`
Performs conversion using pre-configured settings.

If you specify your own FFmpeg parameters using the <dfn>Robot</dfn>'s \`ffmpeg\` parameter and you have not specified a preset, then the default \`mp3\` preset is not applied. This is to prevent you from having to override each of the MP3 preset's values manually.

For a list of audio presets, see [audio presets](/docs/presets/audio/).
`)
}).strict();
var robotFFmpegVideo = robotFFmpeg.extend({
  width: external_exports.number().int().min(1).nullish().describe(`
Width of the new video, in pixels.

If the value is not specified and the \`preset\` parameter is available, the \`preset\`'s [supplied width](/docs/presets/video/) will be implemented.
`),
  height: external_exports.number().int().min(1).nullish().describe(`
Height of the new video, in pixels.

If the value is not specified and the \`preset\` parameter is available, the \`preset\`'s [supplied height](/docs/presets/video/) will be implemented.
`),
  preset: external_exports.enum([
    ...createPresets([
      "android",
      "android-high",
      "android-low",
      "dash-270p-video",
      "dash-360p-video",
      "dash-480p-video",
      "dash-540p-video",
      "dash-576p-video",
      "dash-720p-video",
      "dash-1080p-video",
      "dash/270p-video",
      "dash/360p-video",
      "dash/480p-video",
      "dash/540p-video",
      "dash/576p-video",
      "dash/720p-video",
      "dash/1080p-video",
      "flash",
      "gif",
      "hevc",
      "hls-270p",
      "hls-360p",
      "hls-480p",
      "hls-540p",
      "hls-576p",
      "hls-720p",
      "hls-1080p",
      "hls/270p",
      "hls/360p",
      "hls/480p",
      "hls/540p",
      "hls/720p",
      "hls/1080p",
      "hls/4k",
      "ipad",
      "ipad-high",
      "ipad-low",
      "iphone",
      "iphone-high",
      "iphone-low",
      "ogv",
      "vod/270p",
      "vod/480p",
      "vod/720p",
      "vod/1080p",
      "vp9",
      "vp9-270p",
      "vp9-360p",
      "vp9-480p",
      "vp9-540p",
      "vp9-576p",
      "vp9-720p",
      "vp9-1080p",
      "web/mp4-x265/240p",
      "web/mp4-x265/360p",
      "web/mp4-x265/480p",
      "web/mp4-x265/720p",
      "web/mp4-x265/1080p",
      "web/mp4-x265/4k",
      "web/mp4-x265/8k",
      "web/mp4/240p",
      "web/mp4/360p",
      "web/mp4/480p",
      "web/mp4/540p",
      "web/mp4/720p",
      "web/mp4/1080p",
      "web/mp4/4k",
      "web/mp4/8k",
      "web/webm-av1/240p",
      "web/webm-av1/360p",
      "web/webm-av1/480p",
      "web/webm-av1/720p",
      "web/webm-av1/1080p",
      "web/webm-av1/4k",
      "web/webm-av1/8k",
      "web/webm/240p",
      "web/webm/360p",
      "web/webm/480p",
      "web/webm/720p",
      "web/webm/1080p",
      "web/webm/4k",
      "web/webm/8k",
      "webm",
      "webm-270p",
      "webm-360p",
      "webm-480p",
      "webm-540p",
      "webm-576p",
      "webm-720p",
      "webm-1080p",
      "wmv"
    ]),
    ...audioPresets
  ]).transform(transformPreset).optional().describe(`
Converts a video according to [pre-configured settings](/docs/presets/video/).

If you specify your own FFmpeg parameters using the <dfn>Robot</dfn>'s and/or do not not want Transloadit to set any encoding setting, starting \`ffmpeg_stack: "${stackVersions.ffmpeg.recommendedVersion}"\`,  you can use the value \`'empty'\` here.
`)
}).strict();
var unsafeCoordinatesSchema = external_exports.union([
  external_exports.object({
    x1: external_exports.union([external_exports.string(), external_exports.number()]).nullish(),
    y1: external_exports.union([external_exports.string(), external_exports.number()]).nullish(),
    x2: external_exports.union([external_exports.string(), external_exports.number()]).nullish(),
    y2: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
  }).strict(),
  external_exports.string()
]).describe(`
Coordinates for watermarking.
`);
var parsedCoordinatesSchema = external_exports.object({
  x1: external_exports.number(),
  y1: external_exports.number(),
  x2: external_exports.number(),
  y2: external_exports.number()
}).strict();
var path = external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]);
var next_page_token = external_exports.string().default("");
var files_per_page = external_exports.number().int().default(1e3);
var page_number = external_exports.number().int().default(1);
var recursive = external_exports.boolean().default(false);
var return_file_stubs = external_exports.boolean().describe(`
If set to \`true\`, the Robot will not yet import the actual files but instead return an empty file stub that includes a URL from where the file can be imported by subsequent Robots. This is useful for cases where subsequent Steps need more control over the import process, such as with /video/ondemand. This parameter should only be set if all subsequent Steps use Robots that support file stubs.
`).default(false);
var port = external_exports.number().int().min(1).max(65535);
var preset = external_exports.string();
var resize_strategy = external_exports.enum(["crop", "fit", "fillcrop", "min_fit", "pad", "stretch"]).default("pad");
var positionSchema = external_exports.enum([
  "bottom",
  "bottom-left",
  "bottom-right",
  "center",
  "left",
  "right",
  "top",
  "top-left",
  "top-right"
]);
var percentageSchema = external_exports.string().regex(/^\d+%$/);
var color_with_alpha = external_exports.string().regex(/^#?[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/);
var color_without_alpha = external_exports.string().regex(/^#?[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/);
var color_with_alpha_with_named = external_exports.union([
  color_with_alpha,
  // Extend the base hex color schema
  external_exports.enum([
    "transparent",
    "none",
    "black",
    "white",
    "red",
    "green",
    "blue",
    "yellow",
    "cyan",
    "magenta",
    "gray",
    "grey",
    "opaque"
  ])
  // Named colors
]);
var color_without_alpha_with_named = external_exports.union([
  color_without_alpha,
  // Extend the base hex color schema
  external_exports.enum([
    "transparent",
    "none",
    "black",
    "white",
    "red",
    "green",
    "blue",
    "yellow",
    "cyan",
    "magenta",
    "gray",
    "grey",
    "opaque"
  ])
  // Named colors
]);
var bitrateSchema = external_exports.number().int().min(1);
var sampleRateSchema = external_exports.number().int().min(1);
var optimize_priority = external_exports.enum(["compression-ratio", "conversion-speed"]).default("conversion-speed");
var robotImagemagick = external_exports.object({
  imagemagick_stack: external_exports.union([external_exports.enum(["v3"]), external_exports.string().regex(/^v?[23](\.\d+)?(\.\d+)?$/)]).default("v3")
}).strict();
var colorspaceSchema = external_exports.enum([
  "CMY",
  "CMYK",
  "Gray",
  "HCL",
  "HCLp",
  "HSB",
  "HSI",
  "HSL",
  "HSV",
  "HWB",
  "Jzazbz",
  "Lab",
  "LCHab",
  "LCHuv",
  "LMS",
  "Log",
  "Luv",
  "OHTA",
  "OkLab",
  "OkLCH",
  "Rec601YCbCr",
  "Rec709YCbCr",
  "RGB",
  "scRGB",
  "sRGB",
  "Transparent",
  "Undefined",
  "xyY",
  "XYZ",
  "YCbCr",
  "YCC",
  "YDbDr",
  "YIQ",
  "YPbPr",
  "YUV"
]);
var imageQualitySchema = external_exports.number().int().min(1).max(100).default(92).describe(`
Controls the image compression for JPG and PNG images. Please also take a look at [/image/optimize](/docs/robots/image-optimize/).
`);
var aiProviderSchema = external_exports.enum(["aws", "gcp", "replicate", "fal", "transloadit"]);
var granularitySchema = external_exports.enum(["full", "list"]).default("full");
var robotImport = external_exports.object({
  force_name: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).nullable().default(null).describe("Custom name for the imported file(s). By default file names are derived from the source."),
  ignore_errors: external_exports.union([external_exports.boolean(), external_exports.array(external_exports.enum(["meta", "import", "execute"]))]).transform((value) => value === true ? ["meta", "import", "execute"] : value === false ? [] : value).default([])
}).strict();
var azureBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your [Template Credentials](/c/template-credentials/) as this parameter's value. They will contain the values for your Azure Container, Account and Key.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"account"\`, \`"key"\`, \`"container"\`.
`),
  account: external_exports.string().optional(),
  container: external_exports.string().optional(),
  key: external_exports.string().optional()
}).strict();
var backblazeBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Backblaze Bucket Name, App Key ID, and App Key.

To create your credential information, head over to Backblaze, sign in to your account, and select "Create a Bucket". Save the name of your bucket, and click on the "App Keys" tab, scroll to the bottom of the page then select Add a New Application Key. Allow access to your recently created bucket, select  Read and Write as your type of access, and tick the Allow List All Bucket Names option.

Now that everything is in place, create your key, and take note of the information you are given so you can input the information into your <dfn>Template Credentials</dfn>.

 Your App Key will only be viewable once, so make sure you note this down.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"app_key_id"\`, \`"app_key"\`.
`),
  bucket: external_exports.string().optional(),
  app_key_id: external_exports.string().optional(),
  app_key: external_exports.string().optional()
}).strict();
var cloudfilesBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your [Template Credentials](/c/template-credentials/) as this parameter's value. They will contain the values for your Cloud Files Container, User, Key, Account type and Data center.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"account_type"\` ("us" or "uk"), \`"data_center"\` ("dfw" for Dallas or "ord" for Chicago for example), \`"user"\`, \`"key"\`, \`"container"\`.
`),
  account_type: external_exports.enum(["uk", "us"]).optional(),
  data_center: external_exports.string().optional(),
  user: external_exports.string().optional(),
  key: external_exports.string().optional(),
  container: external_exports.string().optional()
}).strict();
var cloudflareBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your cloudflare bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var digitalOceanBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your [Template Credentials](/c/template-credentials/) as this parameter's value. They will contain the values for your DigitalOcean Space, Key, Secret and Region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"space"\`, \`"region"\` (for example: \`"fra1"\` or \`"nyc3"\`), \`"key"\`, \`"secret"\`.
`),
  space: external_exports.string().optional(),
  region: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var dropboxBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Dropbox access token.
`)
}).strict();
var vimeoBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Vimeo access token.
`)
}).strict();
var ftpBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your FTP host, user and password.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> with their static nature is too unwieldy. If you have this requirement, feel free to use the following parameters instead: \`"host"\`, \`"user"\`, \`"password"\`.
`),
  host: external_exports.string().optional(),
  port: port.default(21).describe("The port to use for the FTP connection."),
  user: external_exports.string().optional(),
  password: external_exports.string().optional()
}).strict();
var googleBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Create a new [Google service account](https://cloud.google.com/storage/docs/authentication). Set its role to "Storage Object Creator". Choose "JSON" for the key file format and download it to your computer. You will need to upload this file when creating your <dfn>Template Credentials</dfn>.

Go back to your Google credentials project and enable the "Google Cloud Storage JSON API" for it. Wait around ten minutes for the action to propagate through the Google network. Grab the project ID from the dropdown menu in the header bar on the Google site. You will also need it later on.

Now you can set up the \`storage.objects.create\` and \`storage.objects.delete\` permissions. The latter is optional and only required if you intend to overwrite existing paths.

To do this from the Google Cloud console, navigate to "IAM &amp; Admin" and select "Roles". From here, click "Create Role", enter a name, set the role launch stage to _General availability,_ and set the permissions stated above.

Next, go to Storage browser and select the ellipsis on your bucket to edit bucket permissions. From here, select "Add Member", enter your service account as a new member, and select your newly created role.

Then, create your associated [Template Credentials](/c/template-credentials/) in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value.
`)
}).strict();
var minioBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your MinIO bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var s3Base = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your S3 bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"bucket_region"\` (for example: \`"us-east-1"\` or \`"eu-west-2"\`), \`"key"\`, \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  bucket_region: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var sftpBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your SFTP host, user and optional custom public key.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"host"\`, \`"port"\`, \`"user"\`, \`"public_key"\` (optional).
`),
  host: external_exports.string().optional(),
  port: port.default(21).describe("The port to use for the FTP connection."),
  user: external_exports.string().optional(),
  public_key: external_exports.string().optional()
}).strict();
var supabaseBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Supabase bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.

If you do use these parameters, make sure to use the **Endpoint** value under \`Storage > S3 Connection\` in the Supabase console for the \`"host"\` value, and the values under **S3 Access Keys** on the same page for your \`"key"\` and \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  bucket_region: external_exports.string().optional().describe(`
The region where the bucket is located.
`),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var swiftBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
  Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Swift bucket, Key, Secret and Bucket region.

  While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.
  `),
  bucket: external_exports.string().optional(),
  bucket_region: external_exports.string().optional().describe(`
The region where the bucket is located.
`),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var tigrisBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your MinIO bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  bucket_region: external_exports.string().optional().describe(`
The region where the bucket is located.
`),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var wasabiBase = external_exports.object({
  credentials: external_exports.string().optional().describe(`
Please create your associated <dfn>Template Credentials</dfn> in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value. They will contain the values for your Wasabi bucket, Key, Secret and Bucket region.

While we recommend to use <dfn>Template Credentials</dfn> at all times, some use cases demand dynamic credentials for which using <dfn>Template Credentials</dfn> is too unwieldy because of their static nature. If you have this requirement, feel free to use the following parameters instead: \`"bucket"\`, \`"host"\`, \`"key"\`, \`"secret"\`.
`),
  bucket: external_exports.string().optional(),
  bucket_region: external_exports.string().optional().describe(`
The region where the bucket is located.
`),
  host: external_exports.string().optional(),
  key: external_exports.string().optional(),
  secret: external_exports.string().optional()
}).strict();
var filterExpression = external_exports.union([
  external_exports.string(),
  external_exports.number(),
  external_exports.null(),
  external_exports.array(external_exports.union([external_exports.string(), external_exports.number(), external_exports.null()]))
]);
var filterCondition = external_exports.union([
  external_exports.null(),
  external_exports.string(),
  external_exports.array(external_exports.tuple([
    filterExpression,
    external_exports.union([
      external_exports.literal("=").describe("Equals without type check"),
      external_exports.literal("==").describe("Equals without type check"),
      external_exports.literal("===").describe("Strict equals with type check"),
      external_exports.literal("<").describe("Less than"),
      external_exports.literal(">").describe("Greater than"),
      external_exports.literal("<=").describe("Less or equal"),
      external_exports.literal(">=").describe("Greater or equal"),
      external_exports.literal("!=").describe("Simple inequality check without type check"),
      external_exports.literal("!==").describe("Strict inequality check with type check"),
      external_exports.literal("regex").describe("Case-insensitive regular expression based on [RE2](https://github.com/google/re2) `.match()`"),
      external_exports.literal("!regex").describe("Case-insensitive regular expression based on [RE2](https://github.com/google/re2) `!.match()`"),
      external_exports.literal("includes").describe("Check if the right element is included in the array, which is represented by the left element"),
      external_exports.literal("!includes").describe("Check if the right element is not included in the array, which is represented by the left element"),
      external_exports.literal("empty").describe("Check if the left element is an empty array, an object without properties, an empty string, the number zero or the boolean false. Leave the third element of the array to be an empty string. It wont be evaluated."),
      external_exports.literal("!empty").describe("Check if the left element is an array with members, an object with at least one property, a non-empty string, a number that does not equal zero or the boolean true. Leave the third element of the array to be an empty string. It wont be evaluated.")
    ]),
    filterExpression
  ]))
]);
var videoEncodeSpecificInstructionsSchema = robotFFmpegVideo.extend({
  resize_strategy: resize_strategy.describe(`
See the [available resize strategies](/docs/topics/resize-strategies/).
`),
  zoom: external_exports.boolean().default(true).describe(`
If this is set to \`false\`, smaller videos will not be stretched to the desired width and height. For details about the impact of zooming for your preferred resize strategy, see the list of available [resize strategies](/docs/topics/resize-strategies/).
`),
  crop: unsafeCoordinatesSchema.optional().describe(`
Specify an object containing coordinates for the top left and bottom right corners of the rectangle to be cropped from the original video(s). Values can be integers for absolute pixel values or strings for percentage based values.

For example:

\`\`\`json
{
  "x1": 80,
  "y1": 100,
  "x2": "60%",
  "y2": "80%"
}
\`\`\`

This will crop the area from \`(80, 100)\` to \`(600, 800)\` from a 10001000 pixels video, which is a square whose width is 520px and height is 700px. If \`crop\` is set, the width and height parameters are ignored, and the \`resize_strategy\` is set to \`crop\` automatically.

You can also use a JSON string of such an object with coordinates in similar fashion:

\`\`\`json
"{\\"x1\\": <Integer>, \\"y1\\": <Integer>, \\"x2\\": <Integer>, \\"y2\\": <Integer>}"
\`\`\`
`),
  background: color_with_alpha.default("#00000000").describe(`
The background color of the resulting video the \`"rrggbbaa"\` format (red, green, blue, alpha) when used with the \`"pad"\` resize strategy. The default color is black.
`),
  rotate: external_exports.union([
    external_exports.literal(0),
    external_exports.literal(90),
    external_exports.literal(180),
    external_exports.literal(270),
    external_exports.literal(360),
    external_exports.literal(false)
  ]).optional().describe(`
Forces the video to be rotated by the specified degree integer. Currently, only multiples of \`90\` are supported. We automatically correct the orientation of many videos when the orientation is provided by the camera. This option is only useful for videos requiring rotation because it was not detected by the camera. If you set \`rotate\` to \`false\` no rotation is performed, even if the metadata contains such instructions.
`),
  hint: external_exports.boolean().default(false).describe(`
Enables hinting for mp4 files, for RTP/RTSP streaming.
`),
  turbo: external_exports.boolean().default(false).describe(`
Splits the video into multiple chunks so that each chunk can be encoded in parallel before all encoded chunks are stitched back together to form the result video. This comes at the expense of extra <dfn>Priority Job Slots</dfn> and may prove to be counter-productive for very small video files.
`),
  chunk_duration: external_exports.number().int().min(1).optional().describe(`
Allows you to specify the duration of each chunk when \`turbo\` is set to \`true\`. This means you can take advantage of that feature while using fewer <dfn>Priority Job Slots</dfn>. For instance, the longer each chunk is, the fewer <dfn>Encoding Jobs</dfn> will need to be used.
`),
  watermark_url: external_exports.string().default("").describe(`
A URL indicating a PNG image to be overlaid above this image. You can also [supply the watermark via another Assembly Step](/docs/topics/use-parameter/#supplying-the-watermark-via-an-assembly-step).
`),
  watermark_position: external_exports.union([positionSchema, external_exports.array(positionSchema)]).default("center").describe(`
The position at which the watermark is placed.

An array of possible values can also be specified, in which case one value will be selected at random, such as \`[ "center", "left", "bottom-left", "bottom-right" ]\`.

This setting puts the watermark in the specified corner. To use a specific pixel offset for the watermark, you will need to add the padding to the image itself.
`),
  watermark_x_offset: external_exports.number().int().default(0).describe(`
The x-offset in number of pixels at which the watermark will be placed in relation to the position it has due to \`watermark_position\`.

Values can be both positive and negative and yield different results depending on the \`watermark_position\` parameter. Positive values move the watermark closer to the image's center point, whereas negative values move the watermark further away from the image's center point.
`),
  watermark_y_offset: external_exports.number().int().default(0).describe(`
The y-offset in number of pixels at which the watermark will be placed in relation to the position it has due to \`watermark_position\`.

Values can be both positive and negative and yield different results depending on the \`watermark_position\` parameter. Positive values move the watermark closer to the image's center point, whereas negative values move the watermark further away from the image's center point.
`),
  watermark_size: percentageSchema.optional().describe(`
The size of the watermark, as a percentage, such as \`"50%"\`. How the watermark is resized greatly depends on the \`watermark_resize_strategy\`.
`),
  watermark_resize_strategy: external_exports.enum(["area", "fit", "stretch"]).default("fit").describe(`
To explain how the resize strategies work, let's assume our target video size is 800800 pixels and our watermark image is 400300 pixels. Let's also assume, the \`watermark_size\` parameter is set to \`"25%"\`.

For the \`"fit"\` resize strategy, the watermark is scaled so that the longer side of the watermark takes up 25% of the corresponding video side. And the other side is scaled according to the aspect ratio of the watermark image. So with our watermark, the width is the longer side, and 25% of the video size would be 200px. Hence, the watermark would be resized to 200150 pixels. If the \`watermark_size\` was set to \`"50%"\`", it would be resized to 400300 pixels (so just left at its original size).

For the \`"stretch"\` resize strategy, the watermark image is stretched (meaning, it is resized without keeping its aspect ratio in mind) so that both sides take up 25% of the corresponding video side. Since our video is 800800 pixels, for a watermark size of 25% the watermark would be resized to 200200 pixels. Its height would appear stretched, because keeping the aspect ratio in mind it would be resized to 200150 pixels instead.

For the \`"area"\` resize strategy, the watermark is resized (keeping its aspect ratio in check) so that it covers \`"xx%"\` of the video's surface area. The value from \`watermark_size\` is used for the percentage area size.
`),
  watermark_start_time: external_exports.number().default(0).describe(`
The delay in seconds from the start of the video for the watermark to appear. By default the watermark is immediately shown.
`),
  watermark_duration: external_exports.number().default(-1).describe(`
The duration in seconds for the watermark to be shown. Can be used together with \`watermark_start_time\` to create nice effects. The default value is \`-1.0\`, which means that the watermark is shown for the entire duration of the video.
`),
  watermark_opacity: external_exports.number().min(0).max(1).default(1).describe(`
The opacity of the watermark. Valid values are between \`0\` (invisible) and \`1.0\` (full visibility).
`),
  segment: external_exports.boolean().default(false).describe(`
Splits the file into multiple parts, to be used for Apple's [HTTP Live Streaming](https://developer.apple.com/resources/http-streaming/).
`),
  segment_duration: external_exports.number().int().min(1).default(10).describe(`
Specifies the length of each HTTP segment. This is optional, and the default value as recommended by Apple is \`10\`. Do not change this value unless you have a good reason.
`),
  segment_prefix: external_exports.string().default("").describe(`
The prefix used for the naming. For example, a prefix of \`"segment_"\` would produce files named \`"segment_0.ts"\`, \`"segment_1.ts"\` and so on. This is optional, and defaults to the base name of the input file. Also see the related \`segment_name\` parameter.
`),
  segment_name: external_exports.string().default("").describe(`
The name used for the final segment. Available variables are \`\${segment_prefix}\`, \`\${segment_number}\` and \`\${segment_id}\` (which is a UUIDv4 without dashes).
`),
  segment_time_delta: external_exports.number().optional().describe(`
Delta to apply to segment duration. This is optional and allows fine-tuning of segment boundaries.
`)
}).strict();

// node_modules/transloadit/dist/alphalib/types/robots/ai-chat.js
var jsonValueSchema = external_exports.lazy(() => external_exports.union([
  external_exports.string(),
  external_exports.number(),
  external_exports.boolean(),
  external_exports.null(),
  external_exports.array(jsonValueSchema),
  external_exports.record(jsonValueSchema)
]));
var providerMetadataSchema = external_exports.record(external_exports.record(jsonValueSchema)).optional();
var textPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  experimental_providerMetadata: providerMetadataSchema
});
var imagePartSchema = external_exports.object({
  type: external_exports.literal("image"),
  image: external_exports.union([
    external_exports.string(),
    external_exports.instanceof(Uint8Array),
    external_exports.instanceof(ArrayBuffer),
    // Note: Buffer is not included here since it's Node.js-only and this code runs in browsers.
    // Node.js Buffer extends Uint8Array, so Uint8Array validation handles Buffer values too.
    external_exports.instanceof(URL)
  ]),
  mimeType: external_exports.string().optional(),
  experimental_providerMetadata: providerMetadataSchema
});
var filePartSchema = external_exports.object({
  type: external_exports.literal("file"),
  data: external_exports.union([
    external_exports.string(),
    external_exports.instanceof(Uint8Array),
    external_exports.instanceof(ArrayBuffer),
    // Note: Buffer is not included here since it's Node.js-only and this code runs in browsers.
    // Node.js Buffer extends Uint8Array, so Uint8Array validation handles Buffer values too.
    external_exports.instanceof(URL)
  ]),
  mediaType: external_exports.string(),
  experimental_providerMetadata: providerMetadataSchema
});
var toolCallPartSchema = external_exports.object({
  type: external_exports.literal("tool-call"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  args: external_exports.record(jsonValueSchema),
  experimental_providerMetadata: providerMetadataSchema
});
var toolResultPartSchema = external_exports.object({
  type: external_exports.literal("tool-result"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  result: external_exports.unknown(),
  experimental_content: external_exports.array(external_exports.union([
    external_exports.object({
      type: external_exports.literal("text"),
      text: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("image"),
      data: external_exports.string(),
      mimeType: external_exports.string().optional()
    })
  ])).optional(),
  isError: external_exports.boolean().optional(),
  experimental_providerMetadata: providerMetadataSchema
});
var coreSystemMessageSchema = external_exports.object({
  role: external_exports.literal("system"),
  content: external_exports.string(),
  experimental_providerMetadata: providerMetadataSchema
});
var coreUserMessageSchema = external_exports.object({
  role: external_exports.literal("user"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(external_exports.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  experimental_providerMetadata: providerMetadataSchema
});
var coreAssistantMessageSchema = external_exports.object({
  role: external_exports.literal("assistant"),
  content: external_exports.union([external_exports.string(), external_exports.array(external_exports.union([textPartSchema, toolCallPartSchema]))]),
  experimental_providerMetadata: providerMetadataSchema
});
var coreToolMessageSchema = external_exports.object({
  role: external_exports.literal("tool"),
  content: external_exports.array(toolResultPartSchema),
  experimental_providerMetadata: providerMetadataSchema
});
var coreMessageSchema = external_exports.discriminatedUnion("role", [
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);
var meta = {
  name: "AiChatRobot",
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  minimum_charge: 0,
  output_factor: 0.6,
  purpose_sentence: "generates AI chat responses from prompts",
  purpose_verb: "generate",
  purpose_word: "generate",
  purpose_words: "Generate AI chat responses",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Generate AI chat responses",
  typical_file_size_mb: 0.01,
  typical_file_type: "document",
  priceFactor: 1,
  queueSlotCount: 10,
  // Is this a sensbile minimum charge? What if the customer supplies their own keys? Is it low enough for these cases?
  minimumChargeUsd: 0.06,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "alpha"
};
var MODEL_CAPABILITIES = {
  "anthropic/claude-4-sonnet-20250514": { pdf: true, image: true },
  "anthropic/claude-4-opus-20250514": { pdf: true, image: true },
  "anthropic/claude-sonnet-4-5": { pdf: true, image: true },
  "anthropic/claude-opus-4-5": { pdf: true, image: true },
  "anthropic/claude-opus-4-6": { pdf: true, image: true },
  "openai/gpt-4.1-2025-04-14": { pdf: false, image: true },
  "openai/chatgpt-4o-latest": { pdf: false, image: true },
  "openai/o3-2025-04-16": { pdf: false, image: true },
  "openai/gpt-4o-audio-preview": { pdf: false, image: false },
  "openai/gpt-5.2": { pdf: false, image: true },
  "openai/gpt-5.2-2025-12-11": { pdf: false, image: true },
  "openai/gpt-5.2-chat-latest": { pdf: false, image: true },
  "openai/gpt-5.2-pro": { pdf: false, image: true },
  "google/gemini-2.5-pro": { pdf: true, image: true },
  "moonshot/kimi-k2": { pdf: false, image: false }
};
var supportedModelsList = Object.keys(MODEL_CAPABILITIES);
var vendorModelSchema = external_exports.string().regex(/^[a-z]+\/[a-z0-9.-]+$/, 'Must be in format "vendor/model"').refine((val) => Object.hasOwn(MODEL_CAPABILITIES, val), {
  message: `Invalid vendor/model combination. Supported: ${supportedModelsList.join(", ")}`
});
var robotAiChatInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/ai/chat"),
  // TODO: Is the auto mode yet implemented?
  model: external_exports.union([vendorModelSchema, external_exports.literal("auto")]).default("auto").describe('The model to use. Transloadit can pick the best model for the job if you set this to "auto".'),
  format: external_exports.enum(["json", "text", "meta"]).default("json"),
  return_messages: external_exports.enum(["all", "last"]).default("last"),
  schema: external_exports.string().optional().describe("The JSON Schema that the LLM should output"),
  messages: external_exports.union([external_exports.string(), external_exports.array(coreMessageSchema)]).describe("The prompt, or message history to send to the LLM."),
  system_message: external_exports.string().optional().describe("Set the system/developer prompt, if the model allows it"),
  credentials: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional().describe("Names of template credentials to make available to the robot. When using your own AI provider keys, Transloadit charges a 10% markup (minimum $0.0005 per request)."),
  test_credentials: external_exports.boolean().optional().describe("Use Transloadit-provided credentials for testing. Usage is billed at provider cost plus a 10% markup (minimum $0.0005 per request)."),
  mcp_servers: external_exports.array(external_exports.object({
    type: external_exports.enum(["sse", "http"]),
    url: external_exports.string(),
    headers: external_exports.record(external_exports.string()).optional(),
    auth: external_exports.enum(["transloadit"]).optional()
  })).optional().describe('The MCP servers to use. This is used to call tools from the LLM. Use `headers` to pass `Authorization: Bearer <token>` when needed. You can use any MCP server reachable from your environment. For Transloadit\'s own MCP server, you can set `auth: "transloadit"` to let API2 auto-auth and inject an Authorization header for you (only for Transloadit-hosted MCP servers).')
}).strict();
var robotAiChatInstructionsWithHiddenFieldsSchema = robotAiChatInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAiChatInstructionsSchema.shape.result]),
  provider: external_exports.string().optional().describe("Where to run the model. By the default, it is the vendor. For instance, anthropic:claude* runs on the Anthropic API. But, Claude could also be run on AWS Bedrock. This is a hidden placeholder for now, but will be used in the future to allow for more flexibility in where to run models. "),
  // These are listed here because we don't have these properties in the public documentation.
  // They should set these keys using template credentials.
  openai_api_key: external_exports.string().optional().describe("The API key to use for the OpenAI API."),
  anthropic_api_key: external_exports.string().optional().describe("The API key to use for the Anthropic API."),
  deepseek_api_key: external_exports.string().optional().describe("The API key to use for the DeepSeek API."),
  google_generative_ai_api_key: external_exports.string().optional().describe("The API key to use for the Google Generative AI API."),
  xai_api_key: external_exports.string().optional().describe("The API key to use for the xAI API.")
});
var interpolatableRobotAiChatInstructionsSchema = interpolateRobot(robotAiChatInstructionsSchema);
var interpolatableRobotAiChatInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAiChatInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-artwork.js
init_esm();
var meta2 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      artwork_extracted: {
        robot: "/audio/artwork",
        use: ":original",
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "Extract embedded cover artwork from uploaded audio files:",
  minimum_charge: 0,
  output_factor: 0.8,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "extracts the embedded cover artwork from audio files and allows you to pipe it into other Steps, for example into /image/resize Steps. It can also insert images into audio files as cover artwork",
  purpose_verb: "extract",
  purpose_word: "extract/insert artwork",
  purpose_words: "Extract or insert audio artwork",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Extract or insert audio artwork",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  uses_tools: ["ffmpeg"],
  name: "AudioArtworkRobot",
  priceFactor: 1,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAudioArtworkInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegAudio).extend({
  robot: external_exports.literal("/audio/artwork").describe(`
For extraction, this <dfn>Robot</dfn> uses the image format embedded within the audio file  most often, this is JPEG.

If you need the image in a different format, pipe the result of this <dfn>Robot</dfn> into [/image/resize](/docs/robots/image-resize/).

The \`method\` parameter determines whether to extract or insert.
`),
  method: external_exports.enum(["extract", "insert"]).default("extract").describe(`
What should be done with the audio file. A value of \`"extract"\` means audio artwork will be extracted. A value of \`"insert"\` means the provided image will be inserted as audio artwork.
`),
  change_format_if_necessary: external_exports.boolean().default(false).describe(`
Whether the original file should be transcoded into a new format if there is an issue with the original file.
`)
}).strict();
var robotAudioArtworkInstructionsWithHiddenFieldsSchema = robotAudioArtworkInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioArtworkInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioArtworkInstructionsSchema = interpolateRobot(robotAudioArtworkInstructionsSchema);
var interpolatableRobotAudioArtworkInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioArtworkInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-concat.js
init_esm();
var meta3 = {
  allowed_for_url_transform: false,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      concatenated: {
        robot: "/audio/concat",
        use: {
          steps: [
            {
              name: ":original",
              fields: "first_audio_file",
              as: "audio_1"
            },
            {
              name: ":original",
              fields: "second_audio_file",
              as: "audio_2"
            },
            {
              name: ":original",
              fields: "third_audio_file",
              as: "audio_3"
            }
          ]
        },
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "If you have a form with 3 file input fields and want to concatenate the uploaded audios in a specific order, instruct Transloadit using the `name` attribute of each input field. Use this attribute as the value for the `fields` key in the JSON, and set `as` to `audio_[[index]]`. Transloadit will concatenate the files based on the ascending index order:",
  minimum_charge: 0,
  output_factor: 0.8,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "concatenates several audio files together",
  purpose_verb: "concatenate",
  purpose_word: "concatenate",
  purpose_words: "Concatenate audio",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Concatenate audio",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  uses_tools: ["ffmpeg"],
  name: "AudioConcatRobot",
  priceFactor: 4,
  queueSlotCount: 20,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAudioConcatInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegAudio).extend({
  result: external_exports.boolean().optional().describe("Whether the results of this Step should be present in the Assembly Status JSON"),
  robot: external_exports.literal("/audio/concat").describe(`
This Robot can concatenate an almost infinite number of audio files.
`),
  bitrate: bitrateSchema.optional().describe(`
Bit rate of the resulting audio file, in bits per second. If not specified will default to the bit rate of the input audio file.
`),
  sample_rate: sampleRateSchema.optional().describe(`
Sample rate of the resulting audio file, in Hertz. If not specified will default to the sample rate of the input audio file.
`),
  audio_fade_seconds: external_exports.number().default(1).describe(`
When used this adds an audio fade in and out effect between each section of your concatenated audio file. The float value is used, so if you want an audio delay effect of 500 milliseconds between each video section, you would select 0.5. Integer values can also be represented.

This parameter does not add an audio fade effect at the beginning or end of your result audio file. If you want to do so, create an additional [/audio/encode](/docs/robots/audio-encode/) <dfn>Step</dfn> and use our \`ffmpeg\` parameter as shown in this [demo](/demos/audio-encoding/ffmpeg-fade-in-and-out/).
`),
  crossfade: external_exports.boolean().default(false).describe(`
When set to \`true\`, this parameter enables crossfading between concatenated audio files using FFmpeg's \`acrossfade\` filter. This creates a smooth transition where the end of one audio file overlaps and blends with the beginning of the next file.

The duration of the crossfade is controlled by the \`audio_fade_seconds\` parameter (defaults to 1 second if \`audio_fade_seconds\` is 0).

Note: This parameter requires at least 2 audio files to concatenate and only works with audio files, not video files.
`)
}).strict();
var robotAudioConcatInstructionsWithHiddenFieldsSchema = robotAudioConcatInstructionsSchema.omit({ use: true }).merge(robotUseWithHiddenFields).extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioConcatInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioConcatInstructionsSchema = interpolateRobot(robotAudioConcatInstructionsSchema);
var interpolatableRobotAudioConcatInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioConcatInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-encode.js
init_esm();
var meta4 = {
  allowed_for_url_transform: false,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      mp3_encoded: {
        robot: "/audio/encode",
        use: ":original",
        preset: "mp3",
        bitrate: 256e3,
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "Encode uploaded audio to MP3 format at a 256 kbps bitrate:",
  minimum_charge: 0,
  output_factor: 0.8,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "converts audio files into all kinds of formats for you. We provide encoding presets for the most common formats",
  purpose_verb: "encode",
  purpose_word: "encode",
  purpose_words: "Encode audio",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Encode audio",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  uses_tools: ["ffmpeg"],
  name: "AudioEncodeRobot",
  priceFactor: 4,
  queueSlotCount: 20,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  stage: "ga",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotAudioEncodeInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegAudio).extend({
  result: external_exports.boolean().optional().describe("Whether the results of this Step should be present in the Assembly Status JSON"),
  robot: external_exports.literal("/audio/encode"),
  bitrate: bitrateSchema.optional().describe(`
Bit rate of the resulting audio file, in bits per second. If not specified will default to the bit rate of the input audio file.
`),
  sample_rate: sampleRateSchema.optional().describe(`
Sample rate of the resulting audio file, in Hertz. If not specified will default to the sample rate of the input audio file.
`)
}).strict();
var robotAudioEncodeInstructionsWithHiddenFieldsSchema = robotAudioEncodeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioEncodeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioEncodeInstructionsSchema = interpolateRobot(robotAudioEncodeInstructionsSchema);
var interpolatableRobotAudioEncodeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioEncodeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-loop.js
init_esm();
var meta5 = {
  allowed_for_url_transform: false,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      looped: {
        robot: "/audio/loop",
        use: ":original",
        duration: 300,
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "Loop uploaded audio to achieve a target duration of 300 seconds:",
  marketing_intro: "Whether youre producing beats, white-noise, or just empty segments as fillers between audio tracks that youre to stringing together with [/audio/concat](/docs/robots/audio-concat/), [/audio/loop](/docs/robots/audio-loop/) has got your back.",
  minimum_charge: 0,
  output_factor: 0.8,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "loops one audio file as often as is required to match a given duration",
  purpose_verb: "loop",
  purpose_word: "loop",
  purpose_words: "Loop audio",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Loop audio",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  uses_tools: ["ffmpeg"],
  name: "AudioLoopRobot",
  priceFactor: 4,
  queueSlotCount: 20,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAudioLoopInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegAudio).extend({
  robot: external_exports.literal("/audio/loop"),
  bitrate: bitrateSchema.optional().describe(`
Bit rate of the resulting audio file, in bits per second. If not specified will default to the bit rate of the input audio file.
`),
  sample_rate: sampleRateSchema.optional().describe(`
Sample rate of the resulting audio file, in Hertz. If not specified will default to the sample rate of the input audio file.
`),
  duration: external_exports.number().default(60).describe(`
Target duration for the whole process in seconds. The <dfn>Robot</dfn> will loop the input audio file for as long as this target duration is not reached yet.
`)
}).strict();
var robotAudioLoopInstructionsWithHiddenFieldsSchema = robotAudioLoopInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioLoopInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioLoopInstructionsSchema = interpolateRobot(robotAudioLoopInstructionsSchema);
var interpolatableRobotAudioLoopInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioLoopInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-merge.js
init_esm();
var meta6 = {
  allowed_for_url_transform: false,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      merged: {
        robot: "/audio/merge",
        preset: "mp3",
        use: {
          steps: [
            {
              name: ":original",
              fields: "first_audio_file",
              as: "audio"
            },
            {
              name: ":original",
              fields: "second_audio_file",
              as: "audio"
            },
            {
              name: ":original",
              fields: "third_audio_file",
              as: "audio"
            }
          ]
        },
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "If you have a form with 3 file input fields and wish to overlay the uploaded audios, instruct Transloadit using the `name` attribute of each input field. Use this attribute as the value for the `fields` key in the JSON, and set `as` to `audio`:",
  minimum_charge: 0,
  output_factor: 0.8,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "overlays several audio files on top of each other",
  purpose_verb: "merge",
  purpose_word: "merge",
  purpose_words: "Merge audio files into one",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Merge audio files into one",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  uses_tools: ["ffmpeg"],
  name: "AudioMergeRobot",
  priceFactor: 4,
  queueSlotCount: 20,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAudioMergeInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegAudio).extend({
  robot: external_exports.literal("/audio/merge"),
  bitrate: bitrateSchema.optional().describe(`
Bit rate of the resulting audio file, in bits per second. If not specified will default to the bit rate of the input audio file.
`),
  sample_rate: sampleRateSchema.optional().describe(`
Sample rate of the resulting audio file, in Hertz. If not specified will default to the sample rate of the input audio file.
`),
  duration: external_exports.enum(["first", "longest", "shortest"]).default("longest").describe(`
Duration of the output file compared to the duration of all merged audio files. Can be \`"first"\` (duration of the first input file), \`"shortest"\` (duration of the shortest audio file) or \`"longest"\` for the duration of the longest input file.
`),
  loop: external_exports.boolean().default(false).describe(`
Specifies if any input files that do not match the target duration should be looped to match it. Useful for audio merging where your overlay file is typically much shorter than the main audio file.
`),
  volume: external_exports.enum(["average", "sum"]).default("average").describe(`
Valid values are \`"average"\` and \`"sum"\` here. \`"average"\` means each input is scaled 1/n (n is the number of inputs) or \`"sum"\` which means each individual audio stays on the same volume, but since we merge tracks 'on top' of each other, this could result in very loud output.
`)
}).strict();
var robotAudioMergeInstructionsWithHiddenFieldsSchema = robotAudioMergeInstructionsSchema.omit({ use: true }).merge(robotUseWithHiddenFields).extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioMergeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioMergeInstructionsSchema = interpolateRobot(robotAudioMergeInstructionsSchema);
var interpolatableRobotAudioMergeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioMergeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/audio-waveform.js
init_esm();
var meta7 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      waveformed: {
        robot: "/audio/waveform",
        use: ":original",
        width: 400,
        height: 200,
        outer_color: "0099ccff",
        center_color: "0099ccff"
      }
    }
  },
  example_code_description: "Generate a 400200 waveform in `#0099cc` color from an uploaded audio file:",
  extended_description: `
Here is an example waveform image:

{% assign hotDemo = collections.demos |find: "url", "/demos/audio-encoding/generate-a-waveform-image-from-an-audio-file/" %}

<img src="{{hotDemo.data.generated_outputs.waveformed["audio-encoding-generate-a-waveform-image-from-an-audio-file-waveformed-joakim_karud-rock_angel-0.png"].ssl_url}}" width="300" alt="Example waveform image">
`,
  minimum_charge: 1048576,
  output_factor: 0.07,
  override_lvl1: "Audio Encoding",
  purpose_sentence: "generates waveform images for your audio files and allows you to change their colors and dimensions",
  purpose_verb: "generate",
  purpose_word: "generate waveforms",
  purpose_words: "Generate waveform images from audio",
  service_slug: "audio-encoding",
  slot_count: 20,
  title: "Generate waveform images from audio",
  typical_file_size_mb: 3.8,
  typical_file_type: "audio file",
  name: "AudioWaveformRobot",
  priceFactor: 1,
  queueSlotCount: 20,
  minimumCharge: 1048576,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAudioWaveformInstructionsBaseSchema = robotBase.merge(robotUse).merge(robotFFmpeg).extend({
  robot: external_exports.literal("/audio/waveform").describe(`
We recommend that you use an [/audio/encode](/docs/robots/audio-encode/) <dfn>Step</dfn> prior to your waveform <dfn>Step</dfn> to convert audio files to MP3. This way it is guaranteed that [/audio/waveform](/docs/robots/audio-waveform/) accepts your audio file and you can also down-sample large audio files and save some money.

Similarly, if you need the output image in a different format, please pipe the result of this <dfn>Robot</dfn> into [/image/resize](/docs/robots/image-resize/).
`),
  format: external_exports.enum(["image", "json"]).default("image").describe(`
The format of the result file. Can be \`"image"\` or \`"json"\`. If \`"image"\` is supplied, a PNG image will be created, otherwise a JSON file.
`),
  width: external_exports.number().int().min(1).default(256).describe(`
The width of the resulting image if the format \`"image"\` was selected.
`),
  height: external_exports.number().int().min(1).default(64).describe(`
The height of the resulting image if the format \`"image"\` was selected.
`),
  antialiasing: external_exports.union([external_exports.literal(0), external_exports.literal(1), external_exports.boolean()]).default(0).describe(`
Either a value of \`0\` or \`1\`, or \`true\`/\`false\`, corresponding to if you want to enable antialiasing to achieve smoother edges in the waveform graph or not.
`),
  background_color: color_with_alpha.default("#00000000").describe(`
The background color of the resulting image in the "rrggbbaa" format (red, green, blue, alpha), if the format \`"image"\` was selected.
`),
  center_color: color_with_alpha.default("000000ff").describe(`
The color used in the center of the gradient. The format is "rrggbbaa" (red, green, blue, alpha).
`),
  outer_color: color_with_alpha.default("000000ff").describe(`
The color used in the outer parts of the gradient. The format is "rrggbbaa" (red, green, blue, alpha).
`)
});
var styleSchema = external_exports.preprocess((val) => {
  if (val === "v1" || val === 1 || val === "1")
    return "v1";
  if (val === "v0" || val === 0 || val === "0")
    return "v0";
  return val;
}, external_exports.enum(["v0", "v1"]).default("v0"));
var robotAudioWaveformInstructionsSchema = robotAudioWaveformInstructionsBaseSchema.extend({
  style: styleSchema.describe(`
Waveform style version.

- \`"v0"\`: Legacy waveform generation (default).
- \`"v1"\`: Advanced waveform generation with additional parameters.

For backwards compatibility, numeric values \`0\`, \`1\`, \`2\` are also accepted and mapped to \`"v0"\` (0) and \`"v1"\` (1/2).
`),
  // v1-only parameters (accepted for v0 but have no effect)
  split_channels: external_exports.boolean().optional().describe(`
Available when style is \`"v1"\`. If set to \`true\`, outputs multi-channel waveform data or image files, one per channel.
`),
  zoom: external_exports.number().int().min(1).optional().describe(`
Available when style is \`"v1"\`. Zoom level in samples per pixel. This parameter cannot be used together with \`pixels_per_second\`.
`),
  pixels_per_second: external_exports.number().positive().optional().describe(`
Available when style is \`"v1"\`. Zoom level in pixels per second. This parameter cannot be used together with \`zoom\`.
`),
  bits: external_exports.union([external_exports.literal(8), external_exports.literal(16)]).optional().describe(`
Available when style is \`"v1"\`. Bit depth for waveform data. Can be 8 or 16.
`),
  start: external_exports.number().min(0).optional().describe(`
Available when style is \`"v1"\`. Start time in seconds.
`),
  end: external_exports.number().min(0).optional().describe(`
Available when style is \`"v1"\`. End time in seconds (0 means end of audio).
`),
  colors: external_exports.enum(["audition", "audacity"]).optional().describe(`
Available when style is \`"v1"\`. Color scheme to use. Can be "audition" or "audacity".
`),
  border_color: color_with_alpha.optional().describe(`
Available when style is \`"v1"\`. Border color in "rrggbbaa" format.
`),
  waveform_style: external_exports.enum(["normal", "bars"]).optional().describe(`
Available when style is \`"v1"\`. Waveform style. Can be "normal" or "bars".
`),
  bar_width: external_exports.number().int().positive().optional().describe(`
Available when style is \`"v1"\`. Width of bars in pixels when waveform_style is "bars".
`),
  bar_gap: external_exports.number().int().min(0).optional().describe(`
Available when style is \`"v1"\`. Gap between bars in pixels when waveform_style is "bars".
`),
  bar_style: external_exports.enum(["square", "rounded"]).optional().describe(`
Available when style is \`"v1"\`. Bar style when waveform_style is "bars".
`),
  axis_label_color: color_with_alpha.optional().describe(`
Available when style is \`"v1"\`. Color for axis labels in "rrggbbaa" format.
`),
  no_axis_labels: external_exports.boolean().optional().describe(`
Available when style is \`"v1"\`. If set to \`true\`, renders waveform image without axis labels.
`),
  with_axis_labels: external_exports.boolean().optional().describe(`
Available when style is \`"v1"\`. If set to \`true\`, renders waveform image with axis labels.
`),
  amplitude_scale: external_exports.number().positive().optional().describe(`
Available when style is \`"v1"\`. Amplitude scale factor.
`),
  compression: external_exports.number().int().min(-1).max(9).optional().describe(`
Available when style is \`"v1"\`. PNG compression level: 0 (none) to 9 (best), or -1 (default). Only applicable when format is "image".
`)
}).strict();
var robotAudioWaveformInstructionsWithHiddenFieldsSchema = robotAudioWaveformInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAudioWaveformInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAudioWaveformInstructionsSchema = interpolateRobot(robotAudioWaveformInstructionsSchema);
var interpolatableRobotAudioWaveformInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAudioWaveformInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/azure-import.js
init_esm();
var meta8 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/azure/import",
        credentials: "YOUR_AZURE_CREDENTIALS",
        path: "path/to/files/"
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Azure container",
  purpose_verb: "import",
  purpose_word: "Azure",
  purpose_words: "Import files from Azure",
  service_slug: "file-importing",
  requires_credentials: true,
  slot_count: 20,
  title: "Import files from Azure",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "AzureImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotAzureImportInstructionsSchema = robotBase.merge(robotImport).merge(azureBase).extend({
  robot: external_exports.literal("/azure/import"),
  path: path.describe(`
The path in your container to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are descendants of this directory are recursively imported. For example: \`images/\`.

If you want to import all files from the root directory, please use \`/\` as the value here.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
  Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.
  `),
  next_page_token: next_page_token.describe(`
A string token used for pagination. The returned files of one paginated call have the next page token inside of their meta data, which needs to be used for the subsequent paging call.
`),
  files_per_page: files_per_page.describe(`
The pagination page size.
`)
}).strict();
var robotAzureImportInstructionsWithHiddenFieldsSchema = robotAzureImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAzureImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAzureImportInstructionsSchema = interpolateRobot(robotAzureImportInstructionsSchema);
var interpolatableRobotAzureImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAzureImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/azure-store.js
init_esm();
var meta9 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/azure/store",
        use: ":original",
        credentials: "YOUR_AZURE_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Azure:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Microsoft Azure",
  purpose_verb: "export",
  purpose_word: "Azure",
  purpose_words: "Export files to Microsoft Azure",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Microsoft Azure",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "AzureStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotAzureStoreInstructionsSchema = robotBase.merge(robotUse).merge(azureBase).extend({
  robot: external_exports.literal("/azure/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  content_type: external_exports.string().optional().describe(`
The content type with which to store the file. By default this will be guessed by Azure.
`),
  content_encoding: external_exports.string().optional().describe(`
The content encoding with which to store the file. By default this will be guessed by Azure.
`),
  content_language: external_exports.string().optional().describe(`
The content language with which to store the file. By default this will be guessed by Azure.
`),
  content_disposition: external_exports.string().optional().describe(`
The content disposition with which to store the file. By default this will be guessed by Azure.
`),
  cache_control: external_exports.string().optional().describe(`
The cache control header with which to store the file.
`),
  // TODO: verify if this is correct.
  metadata: external_exports.record(external_exports.string()).default({}).describe(`
A JavaScript object containing a list of metadata to be set for this file on Azure, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  sas_expires_in: external_exports.number().int().min(0).optional().describe(`
Set this to a number to enable shared access signatures for your stored object. This reflects the number of seconds that the signature will be valid for once the object is stored. Enabling this will attach the shared access signature (SAS) to the result URL of your object.
`),
  sas_permissions: external_exports.string().regex(/^[rdw]+$/).min(0).max(3).optional().describe(`
Set this to a combination of \`r\` (read), \`w\` (write) and \`d\` (delete) for your shared access signatures (SAS) permissions.
`)
}).strict();
var robotAzureStoreInstructionsWithHiddenFieldsSchema = robotAzureStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotAzureStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotAzureStoreInstructionsSchema = interpolateRobot(robotAzureStoreInstructionsSchema);
var interpolatableRobotAzureStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotAzureStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/backblaze-import.js
init_esm();
var meta10 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/backblaze/import",
        credentials: "YOUR_BACKBLAZE_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Backblaze bucket",
  purpose_verb: "import",
  purpose_word: "Backblaze",
  purpose_words: "Import files from Backblaze",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Backblaze",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "BackblazeImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotBackblazeImportInstructionsSchema = robotBase.merge(robotImport).merge(backblazeBase).extend({
  robot: external_exports.literal("/backblaze/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive a 404 \`BACKBLAZE_IMPORT_NOT_FOUND\` error.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`start_file_name\` and \`files_per_page\` wisely here.
`),
  start_file_name: external_exports.string().default("").describe(`
The name of the last file from the previous paging call. This tells the <dfn>Robot</dfn> to ignore all files up to and including this file.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`)
}).strict();
var robotBackblazeImportInstructionsWithHiddenFieldsSchema = robotBackblazeImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotBackblazeImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotBackblazeImportInstructionsSchema = interpolateRobot(robotBackblazeImportInstructionsSchema);
var interpolatableRobotBackblazeImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotBackblazeImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/backblaze-store.js
init_esm();
var meta11 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/backblaze/store",
        use: ":original",
        credentials: "YOUR_BACKBLAZE_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Backblaze:",
  extended_description: `
## Access

Your Backblaze buckets need to have the \`listBuckets\` (to obtain a bucket ID from a bucket name), \`writeFiles\` and \`listFiles\` permissions.
`,
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Backblaze",
  purpose_verb: "export",
  purpose_word: "Backblaze",
  purpose_words: "Export files to Backblaze",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Backblaze",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "BackblazeStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotBackblazeStoreInstructionsSchema = robotBase.merge(robotUse).merge(backblazeBase).extend({
  robot: external_exports.literal("/backblaze/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  headers: external_exports.record(external_exports.string()).default({}).describe(`
An object containing a list of headers to be set for this file on backblaze, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

[Here](https://www.backblaze.com/b2/docs/b2_upload_file.html) you can find a list of available headers.

Object Metadata can be specified using \`X-Bz-Info-*\` headers.
`)
}).strict();
var robotBackblazeStoreInstructionsWithHiddenFieldsSchema = robotBackblazeStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotBackblazeStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotBackblazeStoreInstructionsSchema = interpolateRobot(robotBackblazeStoreInstructionsSchema);
var interpolatableRobotBackblazeStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotBackblazeStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/cloudfiles-import.js
init_esm();
var meta12 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/cloudfiles/import",
        credentials: "YOUR_CLOUDFILES_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Rackspace Cloud Files container",
  purpose_verb: "import",
  purpose_word: "Rackspace Cloud Files",
  purpose_words: "Import files from Rackspace Cloud Files",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Rackspace Cloud Files",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "CloudfilesImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotCloudfilesImportInstructionsSchema = robotBase.merge(robotImport).merge(cloudfilesBase).extend({
  robot: external_exports.literal("/cloudfiles/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: external_exports.boolean().default(false).describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\`wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`)
}).strict();
var robotCloudfilesImportInstructionsWithHiddenFieldsSchema = robotCloudfilesImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotCloudfilesImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotCloudfilesImportInstructionsSchema = interpolateRobot(robotCloudfilesImportInstructionsSchema);
var interpolatableRobotCloudfilesImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotCloudfilesImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/cloudfiles-store.js
init_esm();
var meta13 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/cloudfiles/store",
        use: ":original",
        credentials: "YOUR_CLOUDFILES_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Rackspace Cloud Files:",
  extended_description: `
<a id="export-to-rackspace-cloudfiles" aria-hidden="true"></a>

## A note about URLs

If your container is CDN-enabled, the resulting \`file.url\` indicates the path to the file in your
CDN container, or is \`null\` otherwise.

The storage container URL for this file is always available via \`file.meta.storage_url\`.
`,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Rackspace Cloud Files",
  purpose_verb: "export",
  purpose_word: "Rackspace Cloud Files",
  purpose_words: "Export files to Rackspace Cloud Files",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Rackspace Cloud Files",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "CloudfilesStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotCloudfilesStoreInstructionsSchema = robotBase.merge(robotUse).merge(cloudfilesBase).extend({
  robot: external_exports.literal("/cloudfiles/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which to store the file. This value can also contain [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`)
}).strict();
var robotCloudfilesStoreInstructionsWithHiddenFieldsSchema = robotCloudfilesStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotCloudfilesStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotCloudfilesStoreInstructionsSchema = interpolateRobot(robotCloudfilesStoreInstructionsSchema);
var interpolatableRobotCloudfilesStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotCloudfilesStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/cloudflare-import.js
init_esm();
var meta14 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/cloudflare/import",
        credentials: "YOUR_CLOUDFLARE_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your cloudflare r2 bucket",
  purpose_verb: "import",
  purpose_word: "cloudflare",
  purpose_words: "Import files from Cloudflare R2",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Cloudflare R2",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "CloudflareImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotCloudflareImportInstructionsSchema = robotBase.merge(robotImport).merge(cloudflareBase).extend({
  robot: external_exports.literal("/cloudflare/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subfolders and sub-subfolders, etc. of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotCloudflareImportInstructionsWithHiddenFieldsSchema = robotCloudflareImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotCloudflareImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotCloudflareImportInstructionsSchema = interpolateRobot(robotCloudflareImportInstructionsSchema);
var interpolatableRobotCloudflareImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotCloudflareImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/cloudflare-store.js
init_esm();
var meta15 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/cloudflare/store",
        use: ":original",
        credentials: "YOUR_CLOUDFLARE_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on cloudflare R2:",
  extended_description: `
The URL to the result file will be returned in the <dfn>Assembly Status JSON</dfn>.
`,
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to cloudflare r2 buckets",
  purpose_verb: "export",
  purpose_word: "cloudflare",
  purpose_words: "Export files to Cloudflare R2",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Cloudflare R2",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "CloudflareStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotCloudflareStoreInstructionsSchema = robotBase.merge(robotUse).merge(cloudflareBase).extend({
  robot: external_exports.literal("/cloudflare/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on cloudflare Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`),
  url_prefix: external_exports.string().optional().describe(`
The URL prefix used for accessing files from your Cloudflare R2 bucket. This is typically the custom public URL access host set up in your Cloudflare account.
`)
}).strict();
var robotCloudflareStoreInstructionsWithHiddenFieldsSchema = robotCloudflareStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotCloudflareStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotCloudflareStoreInstructionsSchema = interpolateRobot(robotCloudflareStoreInstructionsSchema);
var interpolatableRobotCloudflareStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotCloudflareStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/digitalocean-import.js
init_esm();
var meta16 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/digitalocean/import",
        credentials: "YOUR_DIGITALOCEAN_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from DigitalOcean Spaces",
  purpose_verb: "import",
  purpose_word: "DigitalOcean Spaces",
  purpose_words: "Import files from DigitalOcean Spaces",
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from DigitalOcean Spaces",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "DigitalOceanImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotDigitaloceanImportInstructionsSchema = robotBase.merge(robotImport).merge(digitalOceanBase).extend({
  robot: external_exports.literal("/digitalocean/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotDigitaloceanImportInstructionsWithHiddenFieldsSchema = robotDigitaloceanImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDigitaloceanImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDigitaloceanImportInstructionsSchema = interpolateRobot(robotDigitaloceanImportInstructionsSchema);
var interpolatableRobotDigitaloceanImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDigitaloceanImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/digitalocean-store.js
init_esm();
var meta17 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/digitalocean/store",
        use: ":original",
        credentials: "YOUR_DIGITALOCEAN_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on DigitalOcean Spaces:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to DigitalOcean Spaces",
  purpose_verb: "export",
  purpose_word: "DigitalOcean Spaces",
  purpose_words: "Export files to DigitalOcean Spaces",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to DigitalOcean Spaces",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "DigitalOceanStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDigitaloceanStoreInstructionsSchema = robotBase.merge(robotUse).merge(digitalOceanBase).extend({
  robot: external_exports.literal("/digitalocean/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  url_prefix: external_exports.string().default("https://{space}.{region}.digitaloceanspaces.com/").describe(`
The URL prefix used for the returned URL, such as \`"https://my.cdn.com/some/path"\`.
`),
  acl: external_exports.enum(["private", "public-read"]).default("public-read").describe(`
The permissions used for this file.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on DigitalOcean Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

[Here](https://developers.digitalocean.com/documentation/spaces/#object) you can find a list of available headers.

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`)
}).strict();
var robotDigitaloceanStoreInstructionsWithHiddenFieldsSchema = robotDigitaloceanStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDigitaloceanStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDigitaloceanStoreInstructionsSchema = interpolateRobot(robotDigitaloceanStoreInstructionsSchema);
var interpolatableRobotDigitaloceanStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDigitaloceanStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-autorotate.js
init_esm();
var meta18 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code_description: "Auto-rotate individual pages of a documents to the correction orientation:",
  minimum_charge: 2097152,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "corrects the orientation of documents",
  purpose_verb: "auto-rotate",
  purpose_word: "auto-rotate documents",
  purpose_words: "Auto-rotate documents",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Auto-rotate documents to the correct orientation",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  name: "DocumentAutorotateRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumCharge: 2097152,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentAutorotateInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/autorotate")
}).strict();
var robotDocumentAutorotateInstructionsWithHiddenFieldsSchema = robotDocumentAutorotateInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentAutorotateInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentAutorotateInstructionsSchema = interpolateRobot(robotDocumentAutorotateInstructionsSchema);
var interpolatableRobotDocumentAutorotateInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentAutorotateInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-convert.js
init_esm();
var meta19 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      converted: {
        robot: "/document/convert",
        use: ":original",
        format: "pdf"
      }
    }
  },
  example_code_description: "Convert uploaded files to PDF documents:",
  extended_description: `
> [!Note]
> This <dfn>Robot</dfn> can convert files to PDF, but cannot convert PDFs to different formats. If you want to convert PDFs to say, JPEG or TIFF, use [/image/resize](/docs/robots/image-resize/). If you want to turn them into text files or recognize (OCR) them to make them searchable, reach out, as we have a new <dfn>Robot</dfn> in the works for this.

Sometimes, a certain file type might not support what you are trying to accomplish. Perhaps your company is trying to automate document formatting, but it only works with docx, so all your docs need to be converted. Or maybe your stored jpg files are taking up too much space and you want a lighter format. Whatever the case, we have you covered.

Using this <dfn>Robot</dfn>, you can bypass the issues that certain file types may bring, by converting your file into the most suitable format. This also works in conjunction with our other <dfn>Robots</dfn>, allowing for even greater versatility when using our services.

> ![Warning]
> A general rule of this <dfn>Robot</dfn> is that converting files into an alien format category will result in an error. For example, SRT files can be converted into the VTT format, but not to an image.

The following file formats can be converted from:

- \`ai\`
- \`csv\`
- \`doc\`
- \`docx\`
- \`eps\`
- \`gif\`
- \`html\`
- \`jpg\`
- \`latex\`
- \`md\`
- \`oda\`
- \`odd\`
- \`odt\`
- \`ott\`
- \`png\`
- \`pot\`
- \`pps\`
- \`ppt\`
- \`pptx\`
- \`ppz\`
- \`ps\`
- \`rtf\`
- \`rtx\`
- \`svg\`
- \`text\`
- \`txt\`
- \`xhtml\`
- \`xla\`
- \`xls\`
- \`xlsx\`
- \`xml\`
`,
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "converts documents into different formats",
  purpose_verb: "convert",
  purpose_word: "convert",
  purpose_words: "Convert documents into different formats",
  service_slug: "document-processing",
  slot_count: 12,
  title: "Convert documents into different formats",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  name: "DocumentConvertRobot",
  priceFactor: 1,
  // This slot count needs to be unique, because unoconv can only process one document at a time,
  // and is also only included in WorkerSlotCalculator::slotsThatFit() when
  // we have enough idle unoconv daemons.
  // We do not want a queue of this Robot to block any other Robot's jobs.
  queueSlotCount: 32,
  minimumCharge: 1048576,
  lazyLoad: true,
  installVersionFile: process.env.API2_UNOCONV_INSTALL_VERSION_FILE || "",
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  // we cannot use coreConfig.numUnoconvDaemons, because it does not live in alphalib
  numDaemons: 8,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentConvertInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/convert").describe(`
> [!Note]
> This Robot can convert files to PDF, but cannot convert PDFs to different formats. If you want to convert PDFs to say, JPEG or TIFF, use [/image/resize](/docs/robots/image-resize/). If you want to turn them into text files or recognize (OCR) them to make them searchable, reach out, as we have a new Robot in the works for this.

Sometimes, a certain file type might not support what you are trying to accomplish. Perhaps your company is trying to automate document formatting, but it only works with docx, so all your docs need to be converted. Or maybe your stored jpg files are taking up too much space and you want a lighter format. Whatever the case, we have you covered.

Using this Robot, you can bypass the issues that certain file types may bring, by converting your file into the most suitable format. This also works in conjunction with our other Robots, allowing for even greater versatility when using our services.

> [!Warning]
> A general rule of this Robot is that converting files into an alien format category will result in an error. For example, SRT files can be converted into the VTT format, but not to an image.

The following file formats can be converted from:

- \`ai\`
- \`csv\`
- \`doc\`
- \`docx\`
- \`eps\`
- \`gif\`
- \`html\`
- \`jpg\`
- \`latex\`
- \`md\`
- \`oda\`
- \`odd\`
- \`odt\`
- \`ott\`
- \`png\`
- \`pot\`
- \`pps\`
- \`ppt\`
- \`pptx\`
- \`ppz\`
- \`ps\`
- \`rtf\`
- \`rtx\`
- \`svg\`
- \`text\`
- \`txt\`
- \`xhtml\`
- \`xla\`
- \`xls\`
- \`xlsx\`
- \`xml\`
`),
  format: external_exports.enum([
    "ai",
    "csv",
    "doc",
    "docx",
    "eps",
    "gif",
    "html",
    "jpeg",
    "jpg",
    "latex",
    "oda",
    "odd",
    "odt",
    "ott",
    "pdf",
    "png",
    "pot",
    "pps",
    "ppt",
    "pptx",
    "ppz",
    "ps",
    "rtf",
    "rtx",
    "srt",
    "svg",
    "text",
    "txt",
    "vtt",
    "xhtml",
    "xla",
    "xls",
    "xlsx",
    "xml"
  ]).describe(`
The desired format for document conversion.
`),
  markdown_format: external_exports.enum(["commonmark", "gfm"]).default("gfm").describe(`
Markdown can be represented in several [variants](https://www.iana.org/assignments/markdown-variants/markdown-variants.xhtml), so when using this Robot to transform Markdown into HTML please specify which revision is being used.
`),
  markdown_theme: external_exports.enum(["bare", "github"]).default("github").describe(`
This parameter overhauls your Markdown files styling based on several canned presets.
`),
  pdf_margin: external_exports.string().default("6.25mm,6.25mm,14.11mm,6.25mm").describe(`
PDF Paper margins, separated by \`,\` and with units.

We support the following unit values: \`px\`, \`in\`, \`cm\`, \`mm\`.

Currently this parameter is only supported when converting from \`html\`.
`),
  pdf_print_background: external_exports.boolean().default(true).describe(`
Print PDF background graphics.

Currently this parameter is only supported when converting from \`html\`.
`),
  pdf_format: external_exports.enum(["A0", "A1", "A2", "A3", "A4", "A5", "A6", "Ledger", "Legal", "Letter", "Tabloid"]).default("Letter").describe(`
PDF paper format.

Currently this parameter is only supported when converting from \`html\`.
`),
  pdf_display_header_footer: external_exports.boolean().default(false).describe(`
Display PDF header and footer.

Currently this parameter is only supported when converting from \`html\`.
`),
  pdf_header_template: external_exports.string().optional().describe(`
HTML template for the PDF print header.

Should be valid HTML markup with following classes used to inject printing values into them:
- \`date\` formatted print date
- \`title\` document title
- \`url\` document location
- \`pageNumber\` current page number
- \`totalPages\` total pages in the document

Currently this parameter is only supported when converting from \`html\`, and requires \`pdf_display_header_footer\` to be enabled.

To change the formatting of the HTML element, the \`font-size\` must be specified in a wrapper. For example, to center the page number at the top of a page you'd use the following HTML for the header template:

\`\`\`html
<div style="font-size: 15px; width: 100%; text-align: center;"><span class="pageNumber"></span></div>
\`\`\`
`),
  pdf_footer_template: external_exports.string().optional().describe(`
HTML template for the PDF print footer.

Should use the same format as the \`pdf_header_template\`.

Currently this parameter is only supported when converting from \`html\`, and requires \`pdf_display_header_footer\` to be enabled.

To change the formatting of the HTML element, the \`font-size\` must be specified in a wrapper. For example, to center the page number in the footer you'd use the following HTML for the footer template:

\`\`\`html
<div style="font-size: 15px; width: 100%; text-align: center;"><span class="pageNumber"></span></div>
\`\`\`
`)
}).strict();
var robotDocumentConvertInstructionsWithHiddenFieldsSchema = robotDocumentConvertInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentConvertInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentConvertInstructionsSchema = interpolateRobot(robotDocumentConvertInstructionsSchema);
var interpolatableRobotDocumentConvertInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentConvertInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-merge.js
init_esm();
var meta20 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      merged: {
        robot: "/document/merge",
        use: {
          steps: [":original"],
          bundle_steps: true
        }
      }
    }
  },
  example_code_description: "Merge all uploaded PDF documents into one:",
  extended_description: `
> ![Note]
> This <dfn>Robot</dfn> can merge PDF files only at the moment.

Input files are sorted alphanumerically unless you provide the as-syntax in the "use" parameter. For example:

\`\`\`json
{
  "use": [
    { "name": "my_step_name", "as": "document_2" },
    { "name": "my_other_step_name", "as": "document_1" }
  ]
}
\`\`\`
`,
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "concatenates several PDF documents into a single file",
  purpose_verb: "convert",
  purpose_word: "convert",
  purpose_words: "Merge documents into one",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Merge documents into one",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  name: "DocumentMergeRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumCharge: 1048576,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentMergeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/merge"),
  input_passwords: external_exports.array(external_exports.string()).default([]).describe(`
An array of passwords for the input documents, in case they are encrypted. The order of passwords must match the order of the documents as they are passed to the /document/merge step.

This can be achieved via our as-syntax using "document_1", "document_2", etc if provided. See the demos below.

If the as-syntax is not used in the "use" parameter, the documents are sorted alphanumerically based on their filename, and in that order input passwords should be provided.
`),
  output_password: external_exports.string().optional().describe(`
If not empty, encrypts the output file and makes it accessible only by typing in this password.
`)
}).strict();
var robotDocumentMergeInstructionsWithHiddenFieldsSchema = robotDocumentMergeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentMergeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentMergeInstructionsSchema = interpolateRobot(robotDocumentMergeInstructionsSchema);
var interpolatableRobotDocumentMergeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentMergeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-ocr.js
init_esm();
var meta21 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      recognized: {
        robot: "/document/ocr",
        use: ":original",
        provider: "gcp"
      }
    }
  },
  example_code_description: "Recognize text in an uploaded document and save it to a JSON file:",
  extended_description: `
> [!Warning]
> Transloadit aims to be deterministic, but this <dfn>Robot</dfn> uses third-party AI services. The providers (AWS, GCP) will evolve their models over time, giving different responses for the same input PDFs. Avoid relying on exact responses in your tests and application.

> [!Note]
> Currently, this <dfn>Robot</dfn> only supports character recognition for PDFs. To use this <dfn>Robot</dfn> with other document formats, use [/document/convert](/docs/robots/document-convert/) first to convert the document into a PDF.
`,
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "recognizes text in documents and returns it in a machine-readable format",
  purpose_verb: "recognize",
  purpose_word: "recognize text",
  purpose_words: "Recognize text in documents (OCR)",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Recognize text in documents",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  name: "DocumentOcrRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsdPerDocumentOcrPage: {
    aws: 0.02,
    gcp: 0.015
  },
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentOcrInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/ocr").describe(`
With this <dfn>Robot</dfn>, you can detect and extract text from PDFs using optical character recognition (OCR).

For example, you can use the results to obtain the content of invoices, legal documents or restaurant menus. You can also pass the text down to other <dfn>Robots</dfn> to filter documents that contain (or do not contain) certain phrases.
`),
  provider: aiProviderSchema.describe(`
Which AI provider to leverage. Valid values are \`"aws"\` and \`"gcp"\`.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.

AWS supports detection for the following languages: English, Arabic, Russian, German, French, Italian, Portuguese and Spanish. GCP allows for a wider range of languages, with varying levels of support which can be found on the [official documentation](https://cloud.google.com/vision/docs/languages/).
`),
  granularity: granularitySchema.describe(`
Whether to return a full response including coordinates for the text (\`"full"\`), or a flat list of the extracted phrases (\`"list"\`). This parameter has no effect if the \`format\` parameter is set to \`"text"\`.
`),
  format: external_exports.enum(["json", "meta", "text"]).default("json").describe(`
In what format to return the extracted text.
- \`"json"\` returns a JSON file.
- \`"meta"\` does not return a file, but stores the data inside Transloadit's file object (under \`\${file.meta.recognized_text}\`, which is an array of strings) that's passed around between encoding <dfn>Steps</dfn>, so that you can use the values to burn the data into videos, filter on them, etc.
- \`"text"\` returns the recognized text as a plain UTF-8 encoded text file.
`)
}).strict();
var robotDocumentOcrInstructionsWithHiddenFieldsSchema = robotDocumentOcrInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentOcrInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentOcrInstructionsSchema = interpolateRobot(robotDocumentOcrInstructionsSchema);
var interpolatableRobotDocumentOcrInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentOcrInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-optimize.js
init_esm();
var meta22 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      optimized: {
        robot: "/document/optimize",
        use: ":original",
        preset: "ebook"
      }
    }
  },
  example_code_description: "Optimize PDF file size using the ebook preset:",
  extended_description: `
This <dfn>Robot</dfn> reduces PDF file sizes. It recompresses images, subsets fonts, and applies various optimizations to reduce file size while maintaining acceptable quality.

## Quality Presets

The Robot supports four quality presets that control the trade-off between file size and quality:

| Preset | DPI | Use Case | Typical Savings |
|--------|-----|----------|-----------------|
| \`screen\` | 72 | Screen viewing, smallest files | ~86% |
| \`ebook\` | 150 | Good balance of quality/size | ~71% |
| \`printer\` | 300 | Print quality | Moderate |
| \`prepress\` | Highest | Press-ready, largest files | Minimal |

## Use Cases

- Reducing storage costs for archived documents
- Faster document delivery and download
- Meeting email attachment size limits
- Mobile-optimized document viewing
`,
  minimum_charge: 2097152,
  output_factor: 0.5,
  override_lvl1: "Document Processing",
  purpose_sentence: "reduces the file size of PDF documents",
  purpose_verb: "optimize",
  purpose_word: "optimize PDF",
  purpose_words: "Optimize PDF file size",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Reduce PDF file size",
  typical_file_size_mb: 2,
  typical_file_type: "document",
  name: "DocumentOptimizeRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumCharge: 2097152,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "beta"
};
var robotDocumentOptimizeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/optimize").describe(`
This Robot reduces PDF file sizes. It recompresses images, subsets fonts, and applies various optimizations to reduce file size while maintaining acceptable quality.

## Quality Presets

The Robot supports four quality presets that control the trade-off between file size and quality:

| Preset | DPI | Use Case | Typical Savings |
|--------|-----|----------|-----------------|
| \`screen\` | 72 | Screen viewing, smallest files | ~86% |
| \`ebook\` | 150 | Good balance of quality/size | ~71% |
| \`printer\` | 300 | Print quality | Moderate |
| \`prepress\` | Highest | Press-ready, largest files | Minimal |
`),
  preset: external_exports.enum(["screen", "ebook", "printer", "prepress"]).default("ebook").describe(`
The quality preset to use for optimization. Each preset provides a different balance between file size and quality:

- \`screen\` - Lowest quality, smallest file size. Best for screen viewing only. Images are downsampled to 72 DPI.
- \`ebook\` - Good balance of quality and size. Suitable for most purposes. Images are downsampled to 150 DPI.
- \`printer\` - High quality suitable for printing. Images are kept at 300 DPI.
- \`prepress\` - Highest quality for professional printing. Minimal compression applied.
`),
  image_dpi: external_exports.number().int().min(36).max(600).optional().describe(`
Target DPI (dots per inch) for embedded images. When specified, this overrides the DPI setting from the preset.

Higher DPI values result in better image quality but larger file sizes. Lower values produce smaller files but may result in pixelated images when printed.

Common values:
- 72 - Screen viewing
- 150 - eBooks and general documents
- 300 - Print quality
- 600 - High-quality print
`),
  compress_fonts: external_exports.boolean().default(true).describe(`
Whether to compress embedded fonts. When enabled, fonts are compressed to reduce file size.
`),
  subset_fonts: external_exports.boolean().default(true).describe(`
Whether to subset embedded fonts, keeping only the glyphs that are actually used in the document. This can significantly reduce file size for documents that only use a small portion of a font's character set.
`),
  remove_metadata: external_exports.boolean().default(false).describe(`
Whether to strip document metadata (title, author, keywords, etc.) from the PDF. This can provide a small reduction in file size and may be useful for privacy.
`),
  linearize: external_exports.boolean().default(true).describe(`
Whether to linearize (optimize for Fast Web View) the output PDF. Linearized PDFs can begin displaying in a browser before they are fully downloaded, improving the user experience for web delivery.
`),
  compatibility: external_exports.enum(["1.4", "1.5", "1.6", "1.7", "2.0"]).default("1.7").describe(`
The PDF version compatibility level. Lower versions have broader compatibility but fewer features. Higher versions support more advanced features but may not open in older PDF readers.

- \`1.4\` - Acrobat 5 compatibility, most widely supported
- \`1.5\` - Acrobat 6 compatibility
- \`1.6\` - Acrobat 7 compatibility
- \`1.7\` - Acrobat 8+ compatibility (default)
- \`2.0\` - PDF 2.0 standard
`)
}).strict();
var robotDocumentOptimizeInstructionsWithHiddenFieldsSchema = robotDocumentOptimizeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentOptimizeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentOptimizeInstructionsSchema = interpolateRobot(robotDocumentOptimizeInstructionsSchema);
var interpolatableRobotDocumentOptimizeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentOptimizeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-split.js
init_esm();
var meta23 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code_description: "Extract single or multiple pages from a PDF document:",
  minimum_charge: 2097152,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "extracts pages from documents",
  purpose_verb: "extract",
  purpose_word: "extracts pages",
  purpose_words: "Extracts pages",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Extract pages from a document",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  name: "DocumentSplitRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumCharge: 1048576,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentSplitInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/document/split"),
  pages: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).describe("The pages to select from the input PDF and to be included in the output PDF. Each entry can be a single page number (e.g. 5), or a range (e.g. `5-10`). Page numbers start at 1. By default all pages are extracted.").optional()
}).strict();
var robotDocumentSplitInstructionsWithHiddenFieldsSchema = robotDocumentSplitInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentSplitInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotDocumentSplitInstructionsSchema = interpolateRobot(robotDocumentSplitInstructionsSchema);
var interpolatableRobotDocumentSplitInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentSplitInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/document-thumbs.js
init_esm();
var meta24 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      thumbnailed: {
        use: ":original",
        robot: "/document/thumbs",
        width: 200,
        resize_strategy: "fit",
        trim_whitespace: false
      }
    }
  },
  example_code_description: "Convert all pages of a PDF document into separate 200px-wide images:",
  minimum_charge: 524288,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "generates an image for each page in a PDF file or an animated GIF file that loops through all pages",
  purpose_verb: "extract",
  purpose_word: "thumbnail",
  purpose_words: "Extract thumbnail images from documents",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Extract thumbnail images from documents",
  typical_file_size_mb: 0.8,
  typical_file_type: "document",
  uses_tools: ["imagemagick"],
  name: "DocumentThumbsRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  minimumCharge: 524288,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDocumentThumbsInstructionsSchema = robotBase.merge(robotUse).merge(robotImagemagick).extend({
  robot: external_exports.literal("/document/thumbs").describe(`
## Things to keep in mind

- If you convert a multi-page PDF file into several images, all result images will be sorted with the first image being the thumbnail of the first document page, etc.
- You can also check the \`meta.thumb_index\` key of each result image to find out which page it corresponds to. Keep in mind that these thumb indices **start at 0,** not at 1.
`),
  page: external_exports.number().int().nullable().default(null).describe(`
The PDF page that you want to convert to an image. By default the value is \`null\` which means that all pages will be converted into images.
`),
  format: external_exports.enum(["gif", "jpeg", "jpg", "png"]).default("png").describe(`
The format of the extracted image(s).

If you specify the value \`"gif"\`, then an animated gif cycling through all pages is created. Please check out [this demo](/demos/document-processing/convert-all-pages-of-a-document-into-an-animated-gif/) to learn more about this.
`),
  delay: external_exports.number().int().min(0).optional().describe(`
If your output format is \`"gif"\` then this parameter sets the number of 100th seconds to pass before the next frame is shown in the animation. Set this to \`100\` for example to allow 1 second to pass between the frames of the animated gif.

If your output format is not \`"gif"\`, then this parameter does not have any effect.
`),
  width: external_exports.number().int().min(1).max(5e3).optional().describe(`
Width of the new image, in pixels. If not specified, will default to the width of the input image
`),
  height: external_exports.number().int().min(1).max(5e3).optional().describe(`
Height of the new image, in pixels. If not specified, will default to the height of the input image
`),
  resize_strategy: external_exports.enum(["crop", "fillcrop", "fit", "min_fit", "pad", "stretch"]).default("pad").describe(`
One of the [available resize strategies](/docs/topics/resize-strategies/).
`),
  // TODO: Determine the allowed colors
  background: external_exports.string().default("#FFFFFF").describe(`
Either the hexadecimal code or [name](https://www.imagemagick.org/script/color.php#color_names) of the color used to fill the background (only used for the pad resize strategy).

By default, the background of transparent images is changed to white. For details about how to preserve transparency across all image types, see [this demo](/demos/image-manipulation/properly-preserve-transparency-across-all-image-types/).
`),
  // TODO: Update options list. Why are they capitalized? They are lowercase in th ImageMagick docs.
  alpha: external_exports.enum(["Remove", "Set"]).optional().describe(`
Change how the alpha channel of the resulting image should work. Valid values are \`"Set"\` to enable transparency and \`"Remove"\` to remove transparency.

For a list of all valid values please check the ImageMagick documentation [here](http://www.imagemagick.org/script/command-line-options.php#alpha).
`),
  density: external_exports.string().regex(/\d+(x\d+)?/).optional().describe(`
While in-memory quality and file format depth specifies the color resolution, the density of an image is the spatial (space) resolution of the image. That is the density (in pixels per inch) of an image and defines how far apart (or how big) the individual pixels are. It defines the size of the image in real world terms when displayed on devices or printed.

You can set this value to a specific \`width\` or in the format \`width\`x\`height\`.

If your converted image has a low resolution, please try using the density parameter to resolve that.
`),
  antialiasing: external_exports.boolean().default(false).describe(`
Controls whether or not antialiasing is used to remove jagged edges from text or images in a document.
`),
  colorspace: colorspaceSchema.optional().describe(`
Sets the image colorspace. For details about the available values, see the [ImageMagick documentation](https://www.imagemagick.org/script/command-line-options.php#colorspace).

Please note that if you were using \`"RGB"\`, we recommend using \`"sRGB"\`. ImageMagick might try to find the most efficient \`colorspace\` based on the color of an image, and default to e.g. \`"Gray"\`. To force colors, you might then have to use this parameter.
`),
  trim_whitespace: external_exports.boolean().default(true).describe(`
This determines if additional whitespace around the PDF should first be trimmed away before it is converted to an image. If you set this to \`true\` only the real PDF page contents will be shown in the image.

If you need to reflect the PDF's dimensions in your image, it is generally a good idea to set this to \`false\`.
`),
  pdf_use_cropbox: external_exports.boolean().default(true).describe(`
Some PDF documents lie about their dimensions. For instance they'll say they are landscape, but when opened in decent Desktop readers, it's really in portrait mode. This can happen if the document has a cropbox defined. When this option is enabled (by default), the cropbox is leading in determining the dimensions of the resulting thumbnails.
`),
  turbo: external_exports.boolean().default(true).describe(`
If you set this to \`false\`, the robot will not emit files as they become available. This is useful if you are only interested in the final result and not in the intermediate steps.

Also, extracted pages will be resized a lot faster as they are sent off to other machines for the resizing. This is especially useful for large documents with many pages to get up to 20 times faster processing.

Turbo Mode increases pricing, though, in that the input document's file size is added for every extracted page. There are no performance benefits nor increased charges for single-page documents.
`)
}).strict();
var robotDocumentThumbsInstructionsWithHiddenFieldsSchema = robotDocumentThumbsInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDocumentThumbsInstructionsSchema.shape.result]).optional(),
  stack: external_exports.string().optional().describe(`
The image processing stack to use. Defaults to the robot's preferred stack (ImageMagick).
`),
  // Override to support lowercase for BC:
  alpha: external_exports.enum(["Remove", "Set", "remove", "set"]).optional().describe(`
Change how the alpha channel of the resulting image should work. Valid values are \`"Set"\` to enable transparency and \`"Remove"\` to remove transparency. Lowercase values are also accepted for backwards compatibility.
`),
  // Override to support 'none' for BC
  resize_strategy: external_exports.enum(["crop", "fillcrop", "fit", "min_fit", "pad", "stretch", "none"]).optional().describe(`
One of the [available resize strategies](/docs/transcoding/image-manipulation/image-resize/#resize-strategies). The 'none' value is supported for backwards compatibility.
`)
});
var interpolatableRobotDocumentThumbsInstructionsSchema = interpolateRobot(robotDocumentThumbsInstructionsSchema);
var interpolatableRobotDocumentThumbsInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDocumentThumbsInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/dropbox-import.js
init_esm();
var meta25 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/dropbox/import",
        credentials: "YOUR_DROPBOX_CREDENTIALS",
        path: "path/to/files/"
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Dropbox",
  purpose_verb: "import",
  purpose_word: "Dropbox",
  purpose_words: "Import files from Dropbox",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Dropbox",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "DropboxImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotDropboxImportInstructionsSchema = robotBase.merge(robotImport).merge(dropboxBase).extend({
  robot: external_exports.literal("/dropbox/import"),
  path: path.describe(`
The path in your Dropbox to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are descendants of this directory are recursively imported. For example: \`images/\`.

If you want to import all files from the root directory, please use \`/\` as the value here.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`)
}).strict();
var robotDropboxImportInstructionsWithHiddenFieldsSchema = robotDropboxImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDropboxImportInstructionsSchema.shape.result]).optional(),
  access_token: external_exports.string().optional()
  // Legacy field for backward compatibility
});
var interpolatableRobotDropboxImportInstructionsSchema = interpolateRobot(robotDropboxImportInstructionsSchema);
var interpolatableRobotDropboxImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDropboxImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/dropbox-store.js
init_esm();
var meta26 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/dropbox/store",
        use: ":original",
        credentials: "YOUR_DROPBOX_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Dropbox:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Dropbox",
  purpose_verb: "export",
  purpose_word: "Dropbox",
  purpose_words: "Export files to Dropbox",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Dropbox",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "DropboxStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotDropboxStoreInstructionsSchema = robotBase.merge(robotUse).merge(dropboxBase).extend({
  robot: external_exports.literal("/dropbox/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  create_sharing_link: external_exports.boolean().default(false).describe(`
Whether to create a URL to this file for sharing with other people. This will overwrite the file's \`"url"\` property.
`)
}).strict();
var robotDropboxStoreInstructionsWithHiddenFieldsSchema = robotDropboxStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotDropboxStoreInstructionsSchema.shape.result]).optional(),
  access_token: external_exports.string().optional()
  // Legacy field for backward compatibility
});
var interpolatableRobotDropboxStoreInstructionsSchema = interpolateRobot(robotDropboxStoreInstructionsSchema);
var interpolatableRobotDropboxStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotDropboxStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/edgly-deliver.js
init_esm();
var meta27 = {
  allowed_for_url_transform: false,
  bytescount: 20,
  discount_factor: 0.05,
  discount_pct: 95,
  minimum_charge: 102400,
  output_factor: 1,
  override_lvl1: "Content Delivery",
  purpose_sentence: "caches and delivers files globally",
  purpose_verb: "cache & deliver",
  purpose_word: "Cache and deliver files",
  purpose_words: "Cache and deliver files globally",
  service_slug: "content-delivery",
  slot_count: 0,
  title: "Cache and deliver files globally",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "EdglyDeliverRobot",
  priceFactor: 20,
  queueSlotCount: 0,
  minimumCharge: 102400,
  downloadInputFiles: false,
  preserveInputFileUrls: true,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: false,
  isInternal: true,
  stage: "removed",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotEdglyDeliverInstructionsSchema = robotBase.extend({
  robot: external_exports.literal("/edgly/deliver").describe(`
When you want Transloadit to tranform files on the fly, this <dfn>Robot</dfn> can cache and deliver the results close to your end-user, saving on latency and encoding volume. The use of this <dfn>Robot</dfn> is implicit when you use the <code>edgly.net</code> domain.
`)
}).strict();
var robotEdglyDeliverInstructionsWithHiddenFieldsSchema = robotEdglyDeliverInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotEdglyDeliverInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotEdglyDeliverInstructionsSchema = interpolateRobot(robotEdglyDeliverInstructionsSchema);
var interpolatableRobotEdglyDeliverInstructionsWithHiddenFieldsSchema = interpolateRobot(robotEdglyDeliverInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-compress.js
init_esm();
var meta28 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      compressed: {
        robot: "/file/compress",
        use: {
          steps: [":original"],
          bundle_steps: true
        },
        format: "zip"
      }
    }
  },
  example_code_description: "Compress uploaded files into a ZIP archive:",
  extended_description: `
### Archive structure for the \`"advanced"\` file layout.

There are a few things that we kept in mind when designing the \`"advanced"\` archive structure:

- There could be naming collisions.
- You want to know which <dfn>Step</dfn> a result file belongs to.
- You want to know from which originally uploaded file a result file was generated.
- Ideally, you want subfolders for a better structure of files.

To achieve all this, we have created the following archive file structure.

- There is a subfolder for each <dfn>Step</dfn> name that has result files in the archive.
- Files are named according to the first two letters of the unique original prefix + "_" + the first two letters of the unique prefix + "_" + the original file name. If you do not know what the original prefixes are, please check [our available Assembly variables](/docs/topics/assembly-instructions/#assembly-variables) and look for \`\${unique_original_prefix}\` and \`\${unique_prefix}\`.
- Files that belong to the \`:original\` <dfn>Step</dfn> (originally uploaded files) do **not** include the first two letters of the \`unique_original_prefix\`.
- If you are dealing with thumbnails from [/video/thumbs](/docs/robots/video-thumbs/), there is an additional digit representing the order in the file name.

Here is an example:

\`\`\`yaml
":original":
  - gh_a.mov          # "gh" are the first 2 letters of the unique prefix.
                      # "a.mov" was the file name of the uploaded file.
  - ff_b.mov
"thumbed":
  - gh_e8_thumb_1.jpg # "gh" is the unique original prefix, meaning it's a result of a.mov.
                      # "e8" is the file's unique prefix.
                      # The "1" shows the thumbnail order.
  - gh_cv_thumb_2.jpg
  - ff_9b_thumb_3.jpg
"resized":
  - gh_ll_thumb.jpg
  - gh_df_thumb.jpg
  - ff_jk_thumb.jpg   # is a child of b.mov, as it starts with "ff"
\`\`\`
`,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Compressing",
  purpose_sentence: "creates archives of files or file conversion results",
  purpose_verb: "compress",
  purpose_word: "compress",
  purpose_words: "Compress files",
  service_slug: "file-compressing",
  slot_count: 15,
  title: "Compress files",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileCompressRobot",
  priceFactor: 1,
  queueSlotCount: 15,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileCompressInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/compress"),
  format: external_exports.enum(["tar", "zip"]).default("tar").describe(`
The format of the archive to be created. Supported values are \`"tar"\` and \`"zip"\`.

Note that \`"tar"\` without setting \`gzip\` to \`true\` results in an archive that's not compressed in any way.
`),
  gzip: external_exports.boolean().default(false).describe(`
Determines if the result archive should also be gzipped. Gzip compression is only applied if you use the \`"tar"\` format.
`),
  password: external_exports.string().nullable().default(null).describe(`
This allows you to encrypt all archive contents with a password and thereby protect it against unauthorized use. To unzip the archive, the user will need to provide the password in a text input field prompt.

This parameter has no effect if the format parameter is anything other than \`"zip"\`.
`),
  compression_level: external_exports.number().int().min(-9).max(0).default(-6).describe(`
Determines how fiercely to try to compress the archive. \`-0\` is compressionless, which is suitable for media that is already compressed. \`-1\` is fastest with lowest compression. \`-9\` is slowest with the highest compression.

If you are using \`-0\` in combination with the \`tar\` format with \`gzip\` enabled, consider setting \`gzip: false\` instead. This results in a plain Tar archive, meaning it already has no compression.
`),
  file_layout: external_exports.enum(["advanced", "simple", "relative-path"]).default("advanced").describe(`
Determines if the result archive should contain all files in one directory (value for this is \`"simple"\`) or in subfolders according to the explanation below (value for this is \`"advanced"\`). The \`"relative-path"\` option preserves the relative directory structure of the input files.

Files with same names are numbered in the \`"simple"\` file layout to avoid naming collisions.
`),
  archive_name: external_exports.string().optional().describe(`
The name of the archive file to be created (without the file extension).
`)
}).strict();
var robotFileCompressInstructionsWithHiddenFieldsSchema = robotFileCompressInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileCompressInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileCompressInstructionsSchema = interpolateRobot(robotFileCompressInstructionsSchema);
var interpolatableRobotFileCompressInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileCompressInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-decompress.js
init_esm();
var meta29 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 0.8,
  discount_pct: 20,
  example_code: {
    steps: {
      decompressed: {
        robot: "/file/decompress",
        use: ":original"
      }
    }
  },
  example_code_description: "Decompress an uploaded archive:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Compressing",
  purpose_sentence: "extracts entire archives of files to be consumed by other Robots or exported as individual files",
  purpose_verb: "decompress",
  purpose_word: "decompress",
  purpose_words: "Decompress archives",
  service_slug: "file-compressing",
  slot_count: 10,
  title: "Decompress archives",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileDecompressRobot",
  priceFactor: 1.25,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotFileDecompressInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/decompress").describe(`
This Robot supports the following archive formats:

- ZIP archives (with uncompressed or "deflate"-compressed entries)
- 7-Zip archives
- RAR archives
- GNU tar format (including GNU long filenames, long link names, and sparse files)
- Solaris 9 extended tar format (including ACLs)
- Old V7 tar archives
- POSIX ustar
- POSIX pax interchange format
- POSIX octet-oriented cpio
- SVR4 ASCII cpio
- POSIX octet-oriented cpio
- Binary cpio (big-endian or little-endian)
- ISO9660 CD-ROM images (with optional Rockridge or Joliet extensions)
- GNU and BSD "ar" archives
- "mtree" format
- Microsoft CAB format
- LHA and LZH archives
- XAR archives

This <dfn>Robot</dfn> also detects and handles any of the following before evaluating the archive file:

- uuencoded files
- Files with RPM wrapper
- gzip compression
- bzip2 compression
- compress/LZW compression
- lzma, lzip, and xz compression

For security reasons, archives that contain symlinks to outside the archived dir, will error out the <dfn>Assembly</dfn>. Decompressing password-protected archives (encrypted archives) is currently not fully supported but will not cause an <dfn>Assembly</dfn> to fail.
`),
  ignore_errors: external_exports.union([external_exports.boolean(), external_exports.array(external_exports.enum(["meta", "execute"]))]).transform((ignoreErrors) => ignoreErrors === true ? ["meta", "execute"] : ignoreErrors === false ? [] : ignoreErrors).default([]).describe(`
A possible array member is only \`"meta"\`.

You might see an error when trying to extract metadata from the files inside your archive. This happens, for example, for files with a size of zero bytes. Setting this to \`true\` will cause the <dfn>Robot</dfn> to not stop the file decompression (and the entire <dfn>Assembly</dfn>) when that happens.

To keep backwards compatibility, setting this parameter to \`true\` will set it to \`["meta"]\` internally.
`)
}).strict();
var robotFileDecompressInstructionsWithHiddenFieldsSchema = robotFileDecompressInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileDecompressInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileDecompressInstructionsSchema = interpolateRobot(robotFileDecompressInstructionsSchema);
var interpolatableRobotFileDecompressInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileDecompressInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-filter.js
init_esm();
var meta30 = {
  allowed_for_url_transform: true,
  bytescount: 0,
  discount_factor: 0,
  discount_pct: 100,
  example_code: {
    steps: {
      filtered: {
        robot: "/file/filter",
        use: ":original",
        declines: [["${file.size}", ">", "20971520"]],
        error_on_decline: true,
        error_msg: "File size must not exceed 20 MB"
      }
    }
  },
  example_code_description: "Reject files that are larger than 20 MB:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Filtering",
  purpose_sentence: "directs files to different encoding Steps based on your conditions",
  purpose_verb: "filter",
  purpose_word: "filter",
  purpose_words: "Filter files",
  service_slug: "file-filtering",
  slot_count: 0,
  title: "Filter files",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileFilterRobot",
  priceFactor: 100,
  queueSlotCount: 0,
  downloadInputFiles: false,
  preserveInputFileUrls: true,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileFilterInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/filter").describe(`
Think of this <dfn>Robot</dfn> as an \`if/else\` condition for building advanced file conversion workflows. With it, you can filter and direct certain uploaded files depending on their metadata.

The <dfn>Robot</dfn> has two modes of operation:

- Constructing conditions out of arrays with 3 members each. For example, \`["\${file.size}", "<=", "720"]\`
- Writing conditions in JavaScript. For example, \`\${file.size <= 720}\`. See also [Dynamic Evaluation](/docs/topics/dynamic-evaluation/).

Passing JavaScript allows you to implement logic as complex as you wish, however its slower than combining arrays of conditions, and will be charged for per invocation via [/script/run](/docs/robots/script-run/).

### Conditions as arrays

The \`accepts\` and \`declines\` parameters can each be set to an array of arrays with three members:

1. A value or job variable, such as \`\${file.mime}\`
2. One of the following operators: \`==\`, \`===\`, \`<\`, \`>\`, \`<=\`, \`>=\`, \`!=\`, \`!==\`, \`regex\`, \`!regex\`, \`includes\`, \`!includes\`
3. A value or job variable, such as \`50\` or \`"foo"\`

Examples:

- \`[["\${file.meta.width}", ">", "\${file.meta.height}"]]\`
- \`[["\${file.size}", "<=", "720"]]\`
- \`[["720", ">=", "\${file.size}"]]\`
- \`[["\${file.mime}", "regex", "image"]]\`

The \`includes\` and \`!includes\` operators work with arrays or strings (strings use substring checks).

> [!Warning]
> If you would like to match against a \`null\` value or a value that is not present (like an audio file does not have a \`video_codec\` property in its metadata), match against \`""\` (an empty string) instead. Well support proper matching against \`null\` in the future, but we cannot easily do so right now without breaking backwards compatibility.

### Conditions as JavaScript

The \`accepts\` and \`declines\` parameters can each be set to strings of JavaScript, which return a boolean value.

Examples:

- \`\${file.meta.width > file.meta.height}\`
- \`\${file.size <= 720}\`
- \`\${/image/.test(file.mime)}\`
- \`\${Math.max(file.meta.width, file.meta.height) > 100}\`

As indicated, we charge for this via [/script/run](/docs/robots/script-run/). See also [Dynamic Evaluation](/docs/topics/dynamic-evaluation/) for more details on allowed syntax and behavior.
`),
  accepts: filterCondition.describe(`
Files that match at least one requirement will be accepted, or declined otherwise. If the value is \`null\`, all files will be accepted. If the array is empty, no files will be accepted. Example:

\`[["\${file.mime}", "==", "image/gif"]]\`.

If the \`condition_type\` parameter is set to \`"and"\`, then all requirements must match for the file to be accepted.

If \`accepts\` and \`declines\` are both provided, the requirements in \`accepts\` will be evaluated first, before the conditions in \`declines\`.
`).optional(),
  declines: filterCondition.describe(`
Files that match at least one requirement will be declined, or accepted otherwise. If the value is \`null\` or an empty array, no files will be declined. Example:

\`[["\${file.size}",">","1024"]]\`.

If the \`condition_type\` parameter is set to \`"and"\`, then all requirements must match for the file to be declined.

If \`accepts\` and \`declines\` are both provided, the requirements in \`accepts\` will be evaluated first, before the conditions in \`declines\`.
`).optional(),
  condition_type: external_exports.enum(["and", "or"]).default("or").describe(`
Specifies the condition type according to which the members of the \`accepts\` or \`declines\` arrays should be evaluated. Can be \`"or"\` or \`"and"\`.
`),
  error_on_decline: external_exports.boolean().default(false).describe(`
If this is set to \`true\` and one or more files are declined, the Assembly will be stopped and marked with an error.
`),
  error_msg: external_exports.string().default("One of your files was declined").describe(`
The error message shown to your users (such as by Uppy) when a file is declined and \`error_on_decline\` is set to \`true\`.
`)
}).strict();
var robotFileFilterInstructionsWithHiddenFieldsSchema = robotFileFilterInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileFilterInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileFilterInstructionsSchema = interpolateRobot(robotFileFilterInstructionsSchema);
var interpolatableRobotFileFilterInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileFilterInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-hash.js
init_esm();
var meta31 = {
  allowed_for_url_transform: false,
  bytescount: 5,
  discount_factor: 0.2,
  discount_pct: 80,
  example_code: {
    steps: {
      hashed: {
        robot: "/file/hash",
        use: ":original",
        algorithm: "sha1"
      }
    }
  },
  example_code_description: "Hash each uploaded file using the SHA-1 algorithm:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "Media Cataloging",
  purpose_sentence: "hashes files in Assemblies",
  purpose_verb: "hash",
  purpose_word: "file",
  purpose_words: "Hash files",
  service_slug: "media-cataloging",
  slot_count: 60,
  title: "Hash Files",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileHashRobot",
  priceFactor: 5,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileHashInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/hash").describe(`
This <dfn>Robot</dfn> allows you to hash any file as part of the <dfn>Assembly</dfn> execution process. This can be useful for verifying the integrity of a file for example.
`),
  algorithm: external_exports.enum(["b2", "md5", "sha1", "sha224", "sha256", "sha384", "sha512"]).default("sha256").describe(`
The hashing algorithm to use.

The file hash is exported as \`file.meta.hash\`.
`)
}).strict();
var robotFileHashInstructionsWithHiddenFieldsSchema = robotFileHashInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileHashInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileHashInstructionsSchema = interpolateRobot(robotFileHashInstructionsSchema);
var interpolatableRobotFileHashInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileHashInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-preview.js
init_esm();
var meta32 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      previewed: {
        robot: "/file/preview",
        use: ":original",
        height: 400,
        width: 300,
        format: "png"
      }
    }
  },
  example_code_description: "Generate a preview thumbnail for any uploaded file:",
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Media Cataloging",
  purpose_sentence: "generates a thumbnail for any uploaded file to preview its content, similar to the thumbnails in desktop file managers",
  purpose_verb: "generate",
  purpose_word: "generate",
  purpose_words: "Generate a preview thumbnail",
  service_slug: "media-cataloging",
  slot_count: 15,
  title: "Generate a preview thumbnail",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FilePreviewRobot",
  priceFactor: 1,
  queueSlotCount: 15,
  minimumCharge: 1048576,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  importRanges: ["0-19999999", "-1000000"],
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "beta"
};
var robotFilePreviewInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/preview").describe(`
This <dfn>Robot</dfn>'s purpose is to generate a meaningful preview image for any file, in such a way that the resulting thumbnail highlights the file's content. The goal is not to losslessly present the original media in a smaller way. Instead, it is to maximize the chance of a person recognizing the media at a glance, while being visually pleasing and consistent with other previews. The generation process depends on the file type. For example, the <dfn>Robot</dfn> can extract artwork from media files, frames from videos, generate a waveform for audio files, and preview the content of documents and images. The details of all available strategies are provided in the next section.

If no file-specific thumbnail can be generated because the file type is not supported, a generic icon containing the file extension will be generated.

The default parameters ensure that the <dfn>Robot</dfn> always generates a preview image with the predefined dimensions and formats, to allow an easy integration into your application's UI. In addition, the generated preview images are optimized by default to reduce their file size while keeping their quality.
`),
  format: external_exports.enum(["gif", "jpg", "png"]).default("png").describe(`
The output format for the generated thumbnail image. If a short video clip is generated using the \`clip\` strategy, its format is defined by \`clip_format\`.
`),
  width: complexWidthSchema.default(300).describe(`
Width of the thumbnail, in pixels.
`),
  height: complexHeightSchema.default(200).describe(`
Height of the thumbnail, in pixels.
`),
  resize_strategy: resize_strategy.describe(`
To achieve the desired dimensions of the preview thumbnail, the <dfn>Robot</dfn> might have to resize the generated image. This happens, for example, when the dimensions of a frame extracted from a video do not match the chosen \`width\` and \`height\` parameters.

See the list of available [resize strategies](/docs/topics/resize-strategies/) for more details.
`),
  background: color_with_alpha.default("#ffffffff").describe(`
The hexadecimal code of the color used to fill the background (only used for the pad resize strategy). The format is \`#rrggbb[aa]\` (red, green, blue, alpha). Use \`#00000000\` for a transparent padding.
`),
  strategy: external_exports.object({
    archive: external_exports.array(external_exports.string()).default(["icon"]),
    audio: external_exports.array(external_exports.string()).default(["artwork", "waveform", "icon"]),
    document: external_exports.array(external_exports.string()).default(["page", "icon"]),
    image: external_exports.array(external_exports.string()).default(["image", "icon"]),
    unknown: external_exports.array(external_exports.string()).default(["icon"]),
    video: external_exports.array(external_exports.string()).default(["artwork", "frame", "icon"]),
    webpage: external_exports.array(external_exports.string()).default(["render", "icon"])
  }).optional().describe(`
Definition of the thumbnail generation process per file category. The parameter must be an object whose keys can be one of the file categories: \`audio\`, \`video\`, \`image\`, \`document\`, \`archive\`, \`webpage\`, and \`unknown\`. The corresponding value is an array of strategies for the specific file category. See the above section for a list of all available strategies.

For each file, the <dfn>Robot</dfn> will attempt to use the first strategy to generate the thumbnail. If this process fails (e.g., because no artwork is available in a video file), the next strategy is attempted. This is repeated until either a thumbnail is generated or the list is exhausted. Selecting the \`icon\` strategy as the last entry provides a fallback mechanism to ensure that an appropriate strategy is always available.

The parameter defaults to the following definition:

\`\`\`json
{
  "audio": ["artwork", "waveform", "icon"],
  "video": ["artwork", "frame", "icon"],
  "document": ["page", "icon"],
  "image": ["image", "icon"],
  "webpage": ["render", "icon"],
  "archive": ["icon"],
  "unknown": ["icon"]
}
\`\`\`
`),
  artwork_outer_color: color_with_alpha.optional().describe(`
  The color used in the outer parts of the artwork's gradient.
  `),
  artwork_center_color: color_with_alpha.optional().describe(`
  The color used in the center of the artwork's gradient.
  `),
  waveform_center_color: color_with_alpha.default("#000000ff").describe(`
The color used in the center of the waveform's gradient. The format is \`#rrggbb[aa]\` (red, green, blue, alpha). Only used if the \`waveform\` strategy for audio files is applied.
`),
  waveform_outer_color: color_with_alpha.default("#000000ff").describe(`
The color used in the outer parts of the waveform's gradient. The format is \`#rrggbb[aa]\` (red, green, blue, alpha). Only used if the \`waveform\` strategy for audio files is applied.
`),
  waveform_height: external_exports.number().int().min(1).max(5e3).default(100).describe(`
Height of the waveform, in pixels. Only used if the \`waveform\` strategy for audio files is applied. It can be utilized to ensure that the waveform only takes up a section of the preview thumbnail.
`),
  waveform_width: external_exports.number().int().min(1).max(5e3).default(300).describe(`
Width of the waveform, in pixels. Only used if the \`waveform\` strategy for audio files is applied. It can be utilized to ensure that the waveform only takes up a section of the preview thumbnail.
`),
  icon_style: external_exports.enum(["square", "with-text"]).default("with-text").describe(`
The style of the icon generated if the \`icon\` strategy is applied. The default style, \`with-text\`, includes an icon showing the file type and a text box below it, whose content can be controlled by the \`icon_text_content\` parameter and defaults to the file extension (e.g. MP4, JPEG). The \`square\` style only includes a square variant of the icon showing the file type. Below are exemplary previews generated for a text file utilizing the different styles:

<br><br> <strong>\`with-text\` style:</strong> <br>
![Image with text style]({{site.asset_cdn}}/assets/images/file-preview/icon-with-text.png)
<br><br> <strong>\`square\` style:</strong> <br>
![Image with square style]({{site.asset_cdn}}/assets/images/file-preview/icon-square.png)
`),
  icon_text_color: color_with_alpha.default("#a2a2a2").describe(`
The color of the text used in the icon. The format is \`#rrggbb[aa]\`. Only used if the \`icon\` strategy is applied.
`),
  // TODO: Determine the font enum.
  icon_text_font: external_exports.string().default("Roboto").describe(`
The font family of the text used in the icon. Only used if the \`icon\` strategy is applied. [Here](/docs/supported-formats/fonts/) is a list of all supported fonts.
`),
  icon_text_content: external_exports.enum(["extension", "none"]).default("extension").describe(`
The content of the text box in generated icons. Only used if the \`icon_style\` parameter is set to \`with-text\`. The default value, \`extension\`, adds the file extension (e.g. MP4, JPEG) to the icon. The value \`none\` can be used to render an empty text box, which is useful if no text should not be included in the raster image, but some place should be reserved in the image for later overlaying custom text over the image using HTML etc.
`),
  optimize: external_exports.boolean().default(true).describe(`
Specifies whether the generated preview image should be optimized to reduce the image's file size while keeping their quaility. If enabled, the images will be optimized using [/image/optimize](/docs/robots/image-optimize/).
`),
  optimize_priority: optimize_priority.describe(`
Specifies whether conversion speed or compression ratio is prioritized when optimizing images. Only used if \`optimize\` is enabled. Please see the [/image/optimize documentation](/docs/robots/image-optimize/#param-priority) for more details.
`),
  optimize_progressive: external_exports.boolean().default(false).describe(`
Specifies whether images should be interlaced, which makes the result image load progressively in browsers. Only used if \`optimize\` is enabled. Please see the [/image/optimize documentation](/docs/robots/image-optimize/#param-progressive) for more details.
`),
  clip_format: external_exports.enum(["apng", "avif", "gif", "webp"]).default("webp").describe(`
The animated image format for the generated video clip. Only used if the \`clip\` strategy for video files is applied.

Please consult the [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types) for detailed information about the image formats and their characteristics. GIF enjoys the broadest support in software, but only supports a limit color palette. APNG supports a variety of color depths, but its lossless compression produces large images for videos. AVIF is a modern image format that offers great compression, but proper support for animations is still lacking in some browsers. WebP on the other hand, enjoys broad support while offering a great balance between small file sizes and good visual quality, making it the default clip format.
`),
  clip_offset: external_exports.number().min(0).default(1).describe(`
The start position in seconds of where the clip is cut. Only used if the \`clip\` strategy for video files is applied. Be aware that for larger video only the first few MBs of the file may be imported to improve speed. Larger offsets may seek to a position outside of the imported part and thus fail to generate a clip.
`),
  clip_duration: external_exports.number().min(0).default(5).describe(`
The duration in seconds of the generated video clip. Only used if the \`clip\` strategy for video files is applied. Be aware that a longer clip duration also results in a larger file size, which might be undesirable for previews.
`),
  clip_framerate: external_exports.number().int().min(1).max(60).default(5).describe(`
The framerate of the generated video clip. Only used if the \`clip\` strategy for video files is applied. Be aware that a higher framerate appears smoother but also results in a larger file size, which might be undesirable for previews.
`),
  clip_loop: external_exports.boolean().default(true).describe(`
Specifies whether the generated animated image should loop forever (\`true\`) or stop after playing the animation once (\`false\`). Only used if the \`clip\` strategy for video files is applied.
`)
}).strict();
var robotFilePreviewInstructionsWithHiddenFieldsSchema = robotFilePreviewInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFilePreviewInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFilePreviewInstructionsSchema = interpolateRobot(robotFilePreviewInstructionsSchema);
var interpolatableRobotFilePreviewInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFilePreviewInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-read.js
init_esm();
var meta33 = {
  allowed_for_url_transform: true,
  bytescount: 5,
  discount_factor: 0.2,
  discount_pct: 80,
  minimum_charge: 512e3,
  output_factor: 1,
  override_lvl1: "Document Processing",
  purpose_sentence: "reads file contents from supported file-types",
  purpose_verb: "read",
  purpose_word: "read files",
  purpose_words: "Read file contents",
  service_slug: "document-processing",
  slot_count: 5,
  title: "Read file contents",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileReadRobot",
  priceFactor: 5,
  queueSlotCount: 5,
  minimumCharge: 512e3,
  isAllowedForUrlTransform: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileReadInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/read").describe(`
This <dfn>Robot</dfn> accepts any file, and will read the file using UTF-8 encoding. The result is outputted to \`file.meta.content\` to be accessed in later <dfn>Steps</dfn>.

The <dfn>Robot</dfn> currently only accepts files under 500KB.
`)
}).strict();
var robotFileReadInstructionsWithHiddenFieldsSchema = robotFileReadInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileReadInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileReadInstructionsSchema = interpolateRobot(robotFileReadInstructionsSchema);
var interpolatableRobotFileReadInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileReadInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-serve.js
init_esm();
var meta34 = {
  allowed_for_url_transform: true,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  minimum_charge: 0,
  output_factor: 1,
  purpose_sentence: "serves files to web browsers",
  purpose_verb: "serve",
  purpose_word: "Serve files",
  purpose_words: "Serve files to web browsers",
  service_slug: "content-delivery",
  slot_count: 0,
  title: "Serve files to web browsers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileServeRobot",
  priceFactor: 4,
  queueSlotCount: 0,
  downloadInputFiles: false,
  preserveInputFileUrls: true,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  stage: "ga",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotFileServeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/serve").describe(`
When you want Transloadit to tranform files on the fly, you can use this <dfn>Robot</dfn> to determine which <dfn>Step</dfn> of a <dfn>Template</dfn> should be served to the end-user (via a CDN), as well as set extra information on the served files, such as headers. This way you can for instance suggest the CDN for how long to keep cached copies of the result around. By default, as you can see in the \`headers\` parameter, we instruct browsers to cache the result for 72h (\`259200\` seconds) and CDNs to cache the content for 24h (\`86400\` seconds). These values should be adjusted to suit your use case.

/file/serve merely acts as the glue layer between our <dfn>Assembly</dfn> engine and serving files over HTTP. It let's you pick the proper result of a series of <dfn>Steps</dfn> via the \`use\` parameter and configure headers on the original content. That is where its responsibilies end, and /tlcdn/deliver, then takes over to globally distribute this original content across the globe, and make sure that is cached close to your end-users, when they make requests such as <https://my-app.tlcdn.com/resize-img/canoe.jpg?w=500>, another. /tlcdn/deliver is not a part of your <dfn>Assembly Instructions</dfn>, but it may appear on your invoices as bandwidth charges incur when distributing the cached copies. /file/serve only charges when the CDN does not have a cached copy and requests to regenerate the original content, which depending on your caching settings could be just once a month, or year, per file/transformation.

While theoretically possible, you could use [/file/serve](/docs/robots/file-serve/) directly in HTML files, but we strongly recommend against this, because if your site gets popular and the media URL that /file/serve is handling gets hit one million times, that is one million new image resizes. Wrapping it with a CDN (and thanks to the caching that comes with it) makes sure encoding charges stay low, as well as latencies.

Also consider configuring caching headers and cache-control directives to control how content is cached and invalidated on the CDN edge servers, balancing between freshness and efficiency.

## Smart CDN Security with Signature Authentication

You can leverage [Signature Authentication](/docs/api/authentication/#smart-cdn) to avoid abuse of our encoding platform. Below is a quick Node.js example using our Node SDK, but there are [examples for other languages and SDKs](/docs/api/authentication/#example-code) as well.

\`\`\`javascript
// yarn add transloadit
// or
// npm install --save transloadit

import { Transloadit } from 'transloadit'

const transloadit = new Transloadit({
  authKey: 'YOUR_TRANSLOADIT_KEY',
  authSecret: 'YOUR_TRANSLOADIT_SECRET',
})

const url = transloadit.getSignedSmartCDNUrl({
  workspace: 'YOUR_WORKSPACE',
  template: 'YOUR_TEMPLATE',
  input: 'image.png',
  urlParams: { height: 100, width: 100 },
})

console.log(url)
\`\`\`

This will generate a signed Smart CDN URL that includes authentication parameters, preventing unauthorized access to your transformation endpoints.

## More information

- [Content Delivery](/services/content-delivery/)
- [/file/serve](/docs/robots/file-serve/) pricing
- [/tlcdn/deliver](/docs/robots/tlcdn-deliver/) pricing
- [File Preview Feature](/blog/2024/06/file-preview-with-smart-cdn/) blog post
`),
  headers: external_exports.record(external_exports.string()).default({
    "Access-Control-Allow-Headers": "X-Requested-With, Content-Type, Cache-Control, Accept, Content-Length, Transloadit-Client, Authorization",
    "Access-Control-Allow-Methods": "POST, GET, PUT, DELETE, OPTIONS",
    "Access-Control-Allow-Origin": "*",
    "Cache-Control": "public, max-age=259200, s-max-age=86400",
    "Content-Type": "${file.mime}; charset=utf-8",
    "Transfer-Encoding": "chunked",
    "Transloadit-Assembly": "",
    "Transloadit-RequestID": ""
  }).describe(`
An object containing a list of headers to be set for a file as we serve it to a CDN/web browser, such as \`{ FileURL: "\${file.url_name}" }\` which will be merged over the defaults, and can include any available [Assembly Variable](/docs/topics/assembly-instructions/#assembly-variables).
`)
}).strict();
var robotFileServeInstructionsWithHiddenFieldsSchema = robotFileServeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileServeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileServeInstructionsSchema = interpolateRobot(robotFileServeInstructionsSchema);
var interpolatableRobotFileServeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileServeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-verify.js
init_esm();
var meta35 = {
  allowed_for_url_transform: true,
  bytescount: 4,
  description: "/file/verify is a simple Robot that helps ensure that the files you upload are of the type you initially intended. This is especially useful when handling user-generated content, where you may not want to run certain Steps in your Template if the user hasnt uploaded a file of the correct type. Another use case for /file/verify is when a user uploads a ZIP file, but we find that it has a few damaged files inside when we extract it. Perhaps you dont want to error out, but only send the good files to a next processing step. With /file/verify, you can do exactly that (assuming the default of `error_on_decline`: `true`).",
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      scanned: {
        robot: "/file/verify",
        use: ":original",
        error_on_decline: true,
        error_msg: "At least one of the uploaded files was not the desired type",
        verify_to_be: "image"
      }
    }
  },
  example_code_description: "Scan the uploaded files and throw an error if they are not images:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Filtering",
  purpose_sentence: "verifies your files are the type that you want",
  purpose_verb: "verify",
  purpose_word: "verify the file type",
  purpose_words: "Verify the file type",
  service_slug: "file-filtering",
  slot_count: 10,
  title: "Verify the file type",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileVerifyRobot",
  priceFactor: 4,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileVerifyInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/verify"),
  error_on_decline: external_exports.boolean().default(false).describe(`
If this is set to \`true\` and one or more files are declined, the Assembly will be stopped and marked with an error.
`),
  error_msg: external_exports.string().default("One of your files was declined").describe(`
The error message shown to your users (such as by Uppy) when a file is declined and \`error_on_decline\` is set to \`true\`.
`),
  verify_to_be: external_exports.string().default("pdf").describe(`
The type that you want to match against to ensure your file is of this type. For example, \`image\` will verify whether uploaded files are images. This also works against file media types, in this case \`image/png\` would also work to match against specifically \`png\` files.
`)
}).strict();
var robotFileVerifyInstructionsWithHiddenFieldsSchema = robotFileVerifyInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileVerifyInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileVerifyInstructionsSchema = interpolateRobot(robotFileVerifyInstructionsSchema);
var interpolatableRobotFileVerifyInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileVerifyInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-virusscan.js
init_esm();
var meta36 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  description: "While 100% security is a myth, having /file/virusscan as a gatekeeper bot helps reject millions of trojans, viruses, malware &amp; other malicious threats before they reach your platform.",
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      scanned: {
        robot: "/file/virusscan",
        use: ":original",
        error_on_decline: true,
        error_msg: "At least one of the uploaded files is malicious and was declined"
      }
    }
  },
  example_code_description: "Scan uploaded files and throw an error if a malicious file is detected:",
  minimum_charge: 1048576,
  ogimage: "/assets/images/robots/ogimages/file-virusscan.jpg",
  output_factor: 1,
  override_lvl1: "File Filtering",
  purpose_sentence: "rejects millions of trojans, viruses, malware &amp; other malicious threats before they reach your platform",
  purpose_verb: "scan",
  purpose_word: "scan for viruses and reject malware",
  purpose_words: "Scan files for viruses",
  service_slug: "file-filtering",
  slot_count: 38,
  title: "Scan files for viruses",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FileVirusscanRobot",
  priceFactor: 1,
  queueSlotCount: 38,
  minimumCharge: 1048576,
  lazyLoad: true,
  installVersionFile: process.env.API2_CLAMD_INSTALL_VERSION_FILE || "",
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFileVirusscanInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/virusscan").describe(`
      This <dfn>Robot</dfn> is built on top of [ClamAV](https://www.clamav.net/), the best open source antivirus engine available. We update its signatures on a daily basis.

By default, this <dfn>Robot</dfn> excludes all malicious files from further processing without any additional notification. This behavior can be changed by setting \`error_on_decline\` to \`true\`, which will stop <dfn>Assemblies</dfn> as soon as malicious files are found. Such <dfn>Assemblies</dfn> will then be marked with an error.

We allow the use of industry standard [EICAR files](https://www.eicar.org/download-anti-malware-testfile/) for integration testing without needing to use potentially dangerous live virus samples.
`),
  error_on_decline: external_exports.boolean().default(false).describe(`
If this is set to \`true\` and one or more files are declined, the Assembly will be stopped and marked with an error.
`),
  error_msg: external_exports.string().default("One of your files was declined").describe(`
The error message shown to your users (such as by Uppy) when a file is declined and \`error_on_decline\` is set to \`true\`.
`)
}).strict();
var robotFileVirusscanInstructionsWithHiddenFieldsSchema = robotFileVirusscanInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileVirusscanInstructionsSchema.shape.result]).optional(),
  can_use_daemon_fallback: external_exports.boolean().optional().describe(`
Allow the robot to use a daemon fallback mechanism if the primary scanning method fails.
`)
});
var interpolatableRobotFileVirusscanInstructionsSchema = interpolateRobot(robotFileVirusscanInstructionsSchema);
var interpolatableRobotFileVirusscanInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileVirusscanInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/file-watermark.js
init_esm();
var robotFileWatermarkInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/file/watermark"),
  randomize: external_exports.boolean().optional()
}).strict();
var robotFileWatermarkInstructionsWithHiddenFieldsSchema = robotFileWatermarkInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFileWatermarkInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFileWatermarkInstructionsSchema = interpolateRobot(robotFileWatermarkInstructionsSchema);
var interpolatableRobotFileWatermarkInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFileWatermarkInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/ftp-import.js
init_esm();
var meta37 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/ftp/import",
        credentials: "YOUR_FTP_CREDENTIALS",
        path: "path/to/files/"
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole libraries of files from your FTP servers into Transloadit. This Robot relies on password access. For more security, consider our /sftp/import Robot",
  purpose_verb: "import",
  purpose_word: "FTP servers",
  purpose_words: "Import files from FTP servers",
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from FTP servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FtpImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotFtpImportInstructionsSchema = robotBase.merge(robotImport).merge(ftpBase).extend({
  robot: external_exports.literal("/ftp/import"),
  path: path.describe(`
The path on your FTP server where to search for files. Files are imported recursively from all sub-directories and sub-sub-directories (and so on) from this path.
`),
  passive_mode: external_exports.boolean().default(true).describe(`
Determines if passive mode should be used for the FTP connection.
`)
}).strict();
var robotFtpImportInstructionsWithHiddenFieldsSchema = robotFtpImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFtpImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotFtpImportInstructionsSchema = interpolateRobot(robotFtpImportInstructionsSchema);
var interpolatableRobotFtpImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFtpImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/ftp-store.js
init_esm();
var meta38 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/ftp/store",
        use: ":original",
        credentials: "YOUR_FTP_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on an FTP server:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to your FTP servers. This Robot relies on password access. For more security, consider our /sftp/store Robot",
  purpose_verb: "export",
  purpose_word: "FTP servers",
  purpose_words: "Export files to FTP servers",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to FTP servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "FtpStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotFtpStoreInstructionsSchema = robotBase.merge(robotUse).merge(ftpBase).extend({
  robot: external_exports.literal("/ftp/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This can contain any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).

Please note that you might need to include your homedir at the beginning of the path.
`),
  url_template: external_exports.string().default("https://{HOST}/{PATH}").describe(`
The URL of the file in the result JSON. The following [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables) are supported.
`),
  ssl_url_template: external_exports.string().default("https://{HOST}/{PATH}").describe(`
The SSL URL of the file in the result JSON. The following [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables) are supported.
`),
  secure: external_exports.boolean().default(false).describe(`
Determines whether to establish a secure connection to the FTP server using SSL.
`)
}).strict();
var robotFtpStoreInstructionsWithHiddenFieldsSchema = robotFtpStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotFtpStoreInstructionsSchema.shape.result]).optional(),
  use_remote_utime: external_exports.boolean().optional().describe(`
Use the remote file's modification time instead of the current time when storing the file.
`),
  version: external_exports.union([external_exports.string(), external_exports.number()]).optional().describe(`
Version identifier for the underlying tool used (2 is ncftp, 1 is ftp).
`),
  allowNetwork: external_exports.string().optional()
  // For internal test purposes
});
var interpolatableRobotFtpStoreInstructionsSchema = interpolateRobot(robotFtpStoreInstructionsSchema);
var interpolatableRobotFtpStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotFtpStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/google-import.js
init_esm();
var meta39 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/google/import",
        credentials: "YOUR_GOOGLE_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from Google Storage",
  purpose_verb: "import",
  purpose_word: "Google Storage",
  purpose_words: "Import files from Google Storage",
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Google Storage",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "GoogleImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotGoogleImportInstructionsSchema = robotBase.merge(robotImport).merge(googleBase).extend({
  robot: external_exports.literal("/google/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive a 404 \`GOOGLE_IMPORT_NOT_FOUND\` error.

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`start_file_name\` and \`files_per_page\` wisely here.
`),
  next_page_token: next_page_token.describe(`
A string token used for pagination. The returned files of one paginated call have the next page token inside of their meta data, which needs to be used for the subsequent paging call.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`)
}).strict();
var robotGoogleImportInstructionsWithHiddenFieldsSchema = robotGoogleImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotGoogleImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotGoogleImportInstructionsSchema = interpolateRobot(robotGoogleImportInstructionsSchema);
var interpolatableRobotGoogleImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotGoogleImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/google-store.js
init_esm();
var meta40 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/google/store",
        use: ":original",
        credentials: "YOUR_GOOGLE_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Google Storage:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Google Storage",
  purpose_verb: "export",
  purpose_word: "Google Storage",
  purpose_words: "Export files to Google Storage",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Google Storage",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "GoogleStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotGoogleStoreInstructionsSchema = robotBase.merge(robotUse).merge(googleBase).extend({
  robot: external_exports.literal("/google/store").describe(`
The URL to the exported file in your Google bucket will be presented in the Transloadit <dfn>Assembly Status</dfn> JSON. This <dfn>Robot</dfn> can also be used to export encoded files to Google's Firebase as demonstrated in [this blogpost](/blog/2018/12/2h-youtube-clone/).
`),
  result: external_exports.boolean().optional().describe("Whether the results of this Step should be present in the Assembly Status JSON"),
  credentials: external_exports.string().describe(`
Create a new [Google service account](https://cloud.google.com/storage/docs/authentication). Set its role to "Storage Object Creator". Choose "JSON" for the key file format and download it to your computer. You will need to upload this file when creating your <dfn>Template Credentials</dfn>.

Go back to your Google credentials project and enable the "Google Cloud Storage JSON API" for it. Wait around ten minutes for the action to propagate through the Google network. Grab the project ID from the dropdown menu in the header bar on the Google site. You will also need it later on.

Now you can set up the \`storage.objects.create\` and \`storage.objects.delete\` permissions. The latter is optional and only required if you intend to overwrite existing paths.

To do this from the Google Cloud console, navigate to "IAM &amp; Admin" and select "Roles". From here, click "Create Role", enter a name, set the role launch stage to _General availability,_ and set the permissions stated above.

Next, go to Storage browser and select the ellipsis on your bucket to edit bucket permissions. From here, select "Add Member", enter your service account as a new member, and select your newly created role.

Then, create your associated [Template Credentials](/c/template-credentials/) in your Transloadit account and use the name of your <dfn>Template Credentials</dfn> as this parameter's value.
`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  acl: external_exports.enum([
    "authenticated-read",
    "bucket-owner-full-control",
    "private",
    "project-private",
    "public-read"
  ]).nullable().default("public-read").describe(`
The permissions used for this file.
`),
  cache_control: external_exports.string().optional().describe(`
The \`Cache-Control\` header determines how long browsers are allowed to cache your object for. Values specified with this parameter will be added to the object's metadata under the \`Cache-Control\` header. For more information on valid values, take a look at the [official Google documentation](https://cloud.google.com/storage/docs/metadata#cache-control).
`),
  url_template: external_exports.string().default("https://{HOST}/{PATH}").describe(`
The URL of the file in the result JSON. This may include any of the following supported [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  ssl_url_template: external_exports.string().default("https://{HOST}/{PATH}").describe(`
The SSL URL of the file in the result JSON. The following [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables) are supported.
`)
}).strict();
var robotGoogleStoreInstructionsWithHiddenFieldsSchema = robotGoogleStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotGoogleStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotGoogleStoreInstructionsSchema = interpolateRobot(robotGoogleStoreInstructionsSchema);
var interpolatableRobotGoogleStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotGoogleStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/html-convert.js
init_esm();
var meta41 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      captured: {
        robot: "/html/convert",
        url: "https://transloadit.com"
      }
    }
  },
  example_code_description: "Take a full screenshot of the Transloadit homepage:",
  extended_description: `
> [!Warning]
> A validation error will occur if neither an HTML file is uploaded nor a URL parameter is given.

> [!Note]
> Any files imported within the HTML page will be included in the cost.
`,
  minimum_charge: 1048576,
  output_factor: 0.5,
  override_lvl1: "Document Processing",
  purpose_sentence: "takes screenshots of web pages or uploaded HTML pages",
  purpose_verb: "take",
  purpose_word: "take screenshots of a webpage",
  purpose_words: "Take screenshots of webpages or HTML files",
  service_slug: "document-processing",
  slot_count: 10,
  title: "Take screenshots of webpages or uploaded HTML files",
  typical_file_size_mb: 0.6,
  typical_file_type: "webpage",
  name: "HtmlConvertRobot",
  priceFactor: 1,
  queueSlotCount: 30,
  minimumCharge: 1048576,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotHtmlConvertInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/html/convert").describe(`
A URL can be provided instead of an input HTML file, to capture a screenshot from the website referenced by the URL.

Use [/image/resize](/docs/robots/image-resize/) to resize or crop the screenshot as needed.
`),
  url: external_exports.string().nullable().default(null).describe(`
The URL of the web page to be converted. Optional, as you can also upload/import HTML files and pass it to this <dfn>Robot</dfn>.
`),
  format: external_exports.enum(["jpeg", "jpg", "pdf", "png"]).default("png").describe(`
The format of the resulting image.
`),
  fullpage: external_exports.boolean().default(true).describe(`
Determines if a screenshot of the full page should be taken or not.

If set to \`true\`, the \`height\` parameter will not have any effect, as heights of websites vary. You can control the size of the resulting image somewhat, though, by setting the \`width\` parameter.

If set to \`false\`, an image will be cropped from the top of the webpage according to your \`width\` and \`height\` parameters.
`),
  omit_background: external_exports.boolean().default(false).describe(`
Determines whether to preserve a transparent background in HTML pages. Useful if you're generating artwork in HTML that you want to overlay on e.g. a video.

The default of \`false\` fills transparent areas with a white background, for easier reading/printing.

This parameter is only used when \`format\` is not \`pdf\`.
`),
  width: external_exports.number().int().min(1).default(1024).describe(`
The screen width that will be used, in pixels. Change this to change the  dimensions of the resulting image.
`),
  height: external_exports.number().int().min(1).optional().describe(`
The screen height that will be used, in pixels. By default this equals the length of the web page in pixels if \`fullpage\` is set to \`true\`. If \`fullpage\` is set to \`false\`, the height parameter takes effect and defaults to the value \`768\`.
`),
  delay: external_exports.number().int().min(0).default(0).describe(`
The delay (in milliseconds) applied to allow the page and all of its JavaScript to render before taking the screenshot.
`),
  headers: external_exports.record(external_exports.string()).optional().describe(`
An object containing optional headers that will be passed along with the original request to the website. For example, this parameter can be used to pass along an authorization token along with the request.
`),
  wait_until: external_exports.enum(["domcontentloaded", "load", "networkidle", "commit"]).default("networkidle").describe(`
The event to wait for before taking the screenshot. Used for loading Javascript, and images.

See [Playwright's documentation](https://playwright.dev/docs/api/class-page#page-wait-for-load-state) for more information.
`)
}).strict();
var robotHtmlConvertInstructionsWithHiddenFieldsSchema = robotHtmlConvertInstructionsSchema.extend({
  debuginfo: external_exports.boolean().optional(),
  timeouts: external_exports.record(external_exports.unknown()).optional(),
  actions: external_exports.array(external_exports.record(external_exports.unknown())).optional(),
  result: external_exports.union([external_exports.literal("debug"), robotHtmlConvertInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotHtmlConvertInstructionsSchema = interpolateRobot(robotHtmlConvertInstructionsSchema);
var interpolatableRobotHtmlConvertInstructionsWithHiddenFieldsSchema = interpolateRobot(robotHtmlConvertInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/http-import.js
init_esm();
var meta42 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/http/import",
        url: "https://demos.transloadit.com/inputs/chameleon.jpg"
      }
    }
  },
  example_code_description: "Import an image from a specific URL:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports any file that is publicly available via a web URL into Transloadit",
  purpose_verb: "import",
  purpose_word: "Webservers",
  purpose_words: "Import files from web servers",
  service_slug: "file-importing",
  slot_count: 10,
  title: "Import files from web servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "HttpImportRobot",
  priceFactor: 10,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotHttpImportInstructionsSchema = robotBase.merge(robotImport).extend({
  robot: external_exports.literal("/http/import").describe(`
The result of this <dfn>Robot</dfn> will carry a field \`import_url\` in their metadata, which references the URL from which they were imported. Further conversion results that use this file will also carry this \`import_url\` field. This allows you to to match conversion results with the original import URL that you used.

This <dfn>Robot</dfn> knows to interpret links to files on these services:

- Dropbox
- Google Drive
- Google Docs
- OneDrive

Instead of downloading the HTML page previewing the file, the actual file itself will be imported.
`),
  url: external_exports.union([external_exports.string().url(), external_exports.array(external_exports.string().url())]).describe(`
The URL from which the file to be imported can be retrieved.

You can also specify an array of URLs or a string of \`|\` delimited URLs to import several files at once. Please also check the \`url_delimiter\` parameter for that.
`),
  url_delimiter: external_exports.string().default("|").describe(`
Provides the delimiter that is used to split the URLs in your \`url\` parameter value.
`),
  headers: external_exports.union([
    external_exports.array(external_exports.string()),
    external_exports.array(external_exports.record(external_exports.string())),
    external_exports.string()
    // For JSON strings like '{"X-Database":"volt"}'
  ]).default([]).describe(`
Custom headers to be sent for file import.

This is an empty array by default, such that no additional headers except the necessary ones (e.g. Host) are sent.

Headers can be specified as:
- An array of strings in the format "Header-Name: value"
- An array of objects with header names as keys and values as values
- A JSON string that will be parsed into an object
`),
  import_on_errors: external_exports.array(external_exports.string()).default([]).describe(`
Setting this to \`"meta"\` will still import the file on metadata extraction errors. \`ignore_errors\` is similar, it also ignores the error and makes sure the Robot doesn't stop, but it doesn't import the file.
`),
  fail_fast: external_exports.boolean().default(false).describe(`
Disable the internal retry mechanism, and fail immediately if a resource can't be imported. This can be useful for performance critical applications.
`),
  return_file_stubs,
  range: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional().describe(`
Allows you to specify one or more byte ranges to import from the file. The server must support range requests for this to work.

**Single range**: Use a string like \`"0-99"\` to import bytes 0-99 (the first 100 bytes).

**Multiple ranges**: Use an array like \`["0-99", "200-299"]\` to import multiple separate ranges. The resulting file will contain all requested ranges concatenated together, with zero bytes (\\0) filling any gaps between non-contiguous ranges.

**Range formats**:
- \`"0-99"\`: Bytes 0 through 99 (inclusive)
- \`"100-199"\`: Bytes 100 through 199 (inclusive)
- \`"-100"\`: The last 100 bytes of the file

**Important notes**:
- The server must support HTTP range requests (respond with 206 Partial Content)
- If the server doesn't support range requests, the entire file will be imported instead
- Overlapping ranges are allowed and will be included as requested
- The resulting file size will be the highest byte position requested, with gaps filled with zero bytes
`)
}).strict();
var robotHttpImportInstructionsWithHiddenFieldsSchema = robotHttpImportInstructionsSchema.extend({
  force_original_id: external_exports.string().optional(),
  force_name: external_exports.union([external_exports.string(), external_exports.record(external_exports.string())]).optional().describe(`
Force a specific filename for imported files. Can be a string to apply to all imports, or an object mapping URLs to filenames.
`),
  result: external_exports.union([external_exports.literal("debug"), robotHttpImportInstructionsSchema.shape.result]).optional(),
  credentials: external_exports.string().optional(),
  // For test purposes
  bucket: external_exports.string().optional(),
  // For test purposes
  // Override url to support relative URLs in tests with bucket
  url: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional()
});
var interpolatableRobotHttpImportInstructionsSchema = interpolateRobot(robotHttpImportInstructionsSchema);
var interpolatableRobotHttpImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotHttpImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-bgremove.js
init_esm();
var meta43 = {
  allowed_for_url_transform: true,
  discount_factor: 1,
  bytescount: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      remove_background: {
        robot: "/image/bgremove",
        use: ":original"
      }
    }
  },
  example_code_description: "Remove the background from the uploaded image:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Image Manipulation",
  purpose_sentence: "removes the background from images",
  purpose_verb: "remove",
  purpose_word: "remove",
  purpose_words: "Remove the background from images",
  service_slug: "image-manipulation",
  slot_count: 10,
  title: "Remove the background from images",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageBgremoveRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsd: 6e-3,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageBgremoveInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/bgremove"),
  select: external_exports.enum(["foreground", "background"]).optional().describe("Region to select and keep in the image. The other region is removed."),
  format: external_exports.enum(["png", "gif", "webp"]).optional().describe("Format of the generated image."),
  provider: external_exports.enum(["transloadit", "replicate", "fal"]).optional().describe("Provider to use for removing the background."),
  model: external_exports.string().optional().describe("Provider-specific model to use for removing the background. Mostly intended for testing and evaluation.")
}).strict();
var robotImageBgremoveInstructionsWithHiddenFieldsSchema = robotImageBgremoveInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageBgremoveInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageBgremoveInstructionsSchema = interpolateRobot(robotImageBgremoveInstructionsSchema);
var interpolatableRobotImageBgremoveInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageBgremoveInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-describe.js
init_esm();
var meta44 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      described: {
        robot: "/image/describe",
        use: ":original",
        provider: "aws"
      }
    }
  },
  example_code_description: "Recognize objects in an uploaded image and store the labels in a JSON file:",
  extended_description: `
> [!Warning]
> Transloadit aims to be deterministic, but this <dfn>Robot</dfn> uses third-party AI services. The providers (AWS, GCP) will evolve their models over time, giving different responses for the same input images. Avoid relying on exact responses in your tests and application.
`,
  minimum_charge: 1572864,
  output_factor: 0.05,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "recognizes objects in images and returns them as English words",
  purpose_verb: "recognize",
  purpose_word: "recognize objects",
  purpose_words: "Recognize objects in images",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Recognize objects in images",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageDescribeRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsd: 13e-4,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageDescribeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/describe").describe(`
You can use the labels that we return in your application to automatically classify images. You can also pass the labels down to other <dfn>Robots</dfn> to filter images that contain (or do not contain) certain content.
`),
  provider: aiProviderSchema.optional().describe(`
Which AI provider to leverage.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.
`),
  granularity: granularitySchema.describe(`
Whether to return a full response (\`"full"\`) including confidence percentages for each found label, or just a flat list of labels (\`"list"\`).
`),
  format: external_exports.enum(["json", "meta", "text"]).default("json").describe(`
In what format to return the descriptions.

- \`"json"\` returns a JSON file.
- \`"meta"\` does not return a file, but stores the data inside Transloadit's file object (under \`\${file.meta.descriptions}\`) that's passed around between encoding <dfn>Steps</dfn>, so that you can use the values to burn the data into videos, filter on them, etc.
`),
  explicit_descriptions: external_exports.boolean().default(false).describe(`
Whether to return only explicit or only non-explicit descriptions of the provided image. Explicit descriptions include labels for NSFW content (nudity, violence, etc). If set to \`false\`, only non-explicit descriptions (such as human or chair) will be returned. If set to \`true\`, only explicit descriptions will be returned.

The possible descriptions depend on the chosen provider. The list of labels from AWS can be found [in their documentation](https://docs.aws.amazon.com/rekognition/latest/dg/moderation.html#moderation-api). GCP labels the image based on five categories, as described [in their documentation](https://cloud.google.com/vision/docs/detecting-safe-search).

For an example of how to automatically reject NSFW content and malware, please check out this [blog post](/blog/2022/07/deny-image-uploads/).
`)
}).strict();
var robotImageDescribeInstructionsWithHiddenFieldsSchema = robotImageDescribeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageDescribeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageDescribeInstructionsSchema = interpolateRobot(robotImageDescribeInstructionsSchema);
var interpolatableRobotImageDescribeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageDescribeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-facedetect.js
init_esm();
var meta45 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      faces_detected: {
        robot: "/image/facedetect",
        use: ":original",
        crop: true,
        faces: "each",
        crop_padding: "10px"
      }
    }
  },
  example_code_description: "Detect all faces in uploaded images, crop them, and save as separate images:",
  minimum_charge: 5242880,
  output_factor: 0.2,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "detects faces in images and can return either their coordinates or the faces themselves as new images",
  purpose_verb: "detect",
  purpose_word: "detect faces",
  purpose_words: "Detect faces in images",
  service_slug: "artificial-intelligence",
  slot_count: 20,
  title: "Detect faces in images",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageFacedetectRobot",
  priceFactor: 1,
  queueSlotCount: 20,
  minimumChargeUsd: 13e-4,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageFacedetectInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/facedetect").describe(`
You can specify padding around the extracted faces, tailoring the output for your needs.

This <dfn>Robot</dfn> works well together with [/image/resize](/docs/robots/image-resize/) to bring the full power of resized and optimized images to your website or app.

<div class="alert alert-note">

**How to improve the accuracy:**

- Ensure that your pictures have the correct orientation. This <dfn>Robot</dfn> achieves the best performance when the faces in the image are oriented upright and not rotated.
- If the <dfn>Robot</dfn> detects objects other than a face, you can use \`"faces": "max-confidence"\` within your <dfn>Template</dfn> for selecting only the detection with the highest confidence.
- The number of returned detections can also be controlled using the \`min_confidence\` parameter. Increasing its value will yield less results but each with a higher confidence. Decreasing the value, on the other hand, will provide more results but may also include objects other than faces.

</div>
`),
  provider: aiProviderSchema.optional().describe(`
Which AI provider to leverage.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.
`),
  crop: external_exports.boolean().default(false).describe(`
Determine if the detected faces should be extracted. If this option is set to \`false\`, then the <dfn>Robot</dfn> returns the input image again, but with the coordinates of all detected faces attached to \`file.meta.faces\` in the result JSON. If this parameter is set to \`true\`, the <dfn>Robot</dfn> will output all detected faces as images.
`),
  crop_padding: external_exports.string().regex(/^\d+(px|%)$/).default("5px").describe(`
Specifies how much padding is added to the extracted face images if \`crop\` is set to \`true\`. Values can be in \`px\` (pixels) or \`%\` (percentage of the width and height of the particular face image).
`),
  format: external_exports.enum(["jpg", "png", "preserve", "tiff"]).default("preserve").describe(`
Determines the output format of the extracted face images if \`crop\` is set to \`true\`.

The default value \`"preserve"\` means that the input image format is re-used.
`),
  min_confidence: external_exports.number().int().min(0).max(100).default(70).describe(`
Specifies the minimum confidence that a detected face must have. Only faces which have a higher confidence value than this threshold will be included in the result.
`),
  faces: external_exports.union([external_exports.enum(["each", "group", "max-confidence", "max-size"]), external_exports.number().int()]).default("each").describe(`
Determines which of the detected faces should be returned. Valid values are:

- \`"each"\`  each face is returned individually.
- \`"max-confidence"\`  only the face with the highest confidence value is returned.
- \`"max-size"\`  only the face with the largest area is returned.
- \`"group"\`  all detected faces are grouped together into one rectangle that contains all faces.
- any integer  the faces are sorted by their top-left corner and the integer determines the index of the returned face. Be aware the values are zero-indexed, meaning that \`faces: 0\` will return the first face. If no face for a given index exists, no output is produced.

For the following examples, the input image is:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-unsplash.jpg)

<br>

\`faces: "each"\` applied:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-0.jpg)
![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-1.jpg)

<br>

\`faces: "max-confidence"\` applied:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-1.jpg)

<br>

\`faces: "max-size"\` applied:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-1.jpg)

<br>

\`faces: "group"\` applied:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-group.jpg)

<br>

\`faces: 0\` applied:

![](/assets/images/abbas-malek-hosseini-22NnY93qaOk-face-0.jpg)
`)
}).strict();
var robotImageFacedetectInstructionsWithHiddenFieldsSchema = robotImageFacedetectInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageFacedetectInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageFacedetectInstructionsSchema = interpolateRobot(robotImageFacedetectInstructionsSchema);
var interpolatableRobotImageFacedetectInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageFacedetectInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-generate.js
init_esm();
var meta46 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  minimum_charge: 0,
  output_factor: 0.6,
  purpose_sentence: "generates images from text prompts using AI",
  purpose_verb: "generate",
  purpose_word: "generate",
  purpose_words: "Generate images from text prompts",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Generate images from text prompts",
  typical_file_size_mb: 1.2,
  typical_file_type: "image",
  name: "ImageGenerateRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsd: 0.06,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageGenerateInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/generate"),
  model: external_exports.string().optional().describe("The AI model to use for image generation. Defaults to google/nano-banana."),
  prompt: external_exports.string().describe("The prompt describing the desired image content."),
  format: external_exports.enum(["jpeg", "jpg", "png", "gif", "webp", "svg"]).optional().describe("Format of the generated image."),
  seed: external_exports.number().optional().describe("Seed for the random number generator."),
  aspect_ratio: external_exports.string().optional().describe("Aspect ratio of the generated image."),
  height: external_exports.number().optional().describe("Height of the generated image."),
  width: external_exports.number().optional().describe("Width of the generated image."),
  style: external_exports.string().optional().describe("Style of the generated image."),
  num_outputs: external_exports.number().int().min(1).max(10).optional().describe("Number of image variants to generate.")
}).strict();
var robotImageGenerateInstructionsWithHiddenFieldsSchema = robotImageGenerateInstructionsSchema.extend({
  provider: external_exports.string().optional().describe("Provider for generating the image."),
  result: external_exports.union([external_exports.literal("debug"), robotImageGenerateInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageGenerateInstructionsSchema = interpolateRobot(robotImageGenerateInstructionsWithHiddenFieldsSchema);
var interpolatableRobotImageGenerateInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageGenerateInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-merge.js
init_esm();
var meta47 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      merged: {
        robot: "/image/merge",
        use: {
          steps: [":original"],
          bundle_steps: true
        },
        border: 5
      }
    }
  },
  example_code_description: "Merge uploaded images into one, with a 5px gap between them on the spritesheet:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Image Manipulation",
  purpose_sentence: "merges several images into a single spritesheet",
  purpose_verb: "merge",
  purpose_word: "merge",
  purpose_words: "Merge several images into one image",
  service_slug: "image-manipulation",
  slot_count: 10,
  title: "Merge several images into a single image",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageMergeRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageMergeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/merge").describe(`
The final result will be a spritesheet, with the images displayed horizontally or vertically.

It's recommended to use this Robot with
[/image/resize](/docs/robots/image-resize/) so your images are of a
similar size before merging them.
`),
  format: external_exports.enum(["jpg", "png"]).default("png").describe("The output format for the modified image."),
  direction: external_exports.enum(["horizontal", "vertical"]).default("horizontal").describe("Specifies the direction which the images are displayed."),
  // TODO: default is not between 1 and 10
  border: external_exports.number().int().default(0).describe(`
An integer value which defines the gap between images on the spritesheet.

A value of \`10\` would cause the images to have the largest gap between them, while a value of \`1\` would place the images side-by-side.
`),
  background: color_without_alpha.default("#FFFFFF").describe(`
Either the hexadecimal code or [name](https://www.imagemagick.org/script/color.php#color_names) of the color used to fill the background (only shown with a border > 1).

By default, the background of transparent images is changed to white.

For details about how to preserve transparency across all image types, see [this demo](/demos/image-manipulation/properly-preserve-transparency-across-all-image-types/).
`),
  adaptive_filtering: external_exports.boolean().default(false).describe(`
Controls the image compression for PNG images. Setting to \`true\` results in smaller file size, while increasing processing time. It is encouraged to keep this option disabled.
`),
  quality: imageQualitySchema
}).strict();
var robotImageMergeInstructionsWithHiddenFieldsSchema = robotImageMergeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageMergeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageMergeInstructionsSchema = interpolateRobot(robotImageMergeInstructionsSchema);
var interpolatableRobotImageMergeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageMergeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-ocr.js
init_esm();
var meta48 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      recognized: {
        robot: "/image/ocr",
        use: ":original",
        provider: "gcp",
        format: "text"
      }
    }
  },
  example_code_description: "Recognize text in an uploaded image and save it to a text file:",
  extended_description: `
> [!Warning]
> Transloadit aims to be deterministic, but this <dfn>Robot</dfn> uses third-party AI services. The providers (AWS, GCP) will evolve their models over time, giving different responses for the same input images. Avoid relying on exact responses in your tests and application.
`,
  minimum_charge: 1048576,
  output_factor: 0.6,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "recognizes text in images and returns it in a machine-readable format",
  purpose_verb: "recognize",
  purpose_word: "recognize text",
  purpose_words: "Recognize text in images (OCR)",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Recognize text in images",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageOcrRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsd: 13e-4,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageOcrInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/ocr").describe(`
With this <dfn>Robot</dfn> you can detect and extract text from images using optical character recognition (OCR).

For example, you can use the results to obtain the content of traffic signs, name tags, package labels and many more. You can also pass the text down to other <dfn>Robots</dfn> to filter images that contain (or do not contain) certain phrases. For images of dense documents, results may vary and be less accurate than for small pieces of text in photos.
`),
  provider: aiProviderSchema.describe(`
Which AI provider to leverage.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.

AWS supports detection for the following languages: English, Arabic, Russian, German, French, Italian, Portuguese and Spanish. GCP allows for a wider range of languages, with varying levels of support which can be found on the [official documentation](https://cloud.google.com/vision/docs/languages/).
`),
  granularity: granularitySchema.describe(`
Whether to return a full response including coordinates for the text (\`"full"\`), or a flat list of the extracted phrases (\`"list"\`). This parameter has no effect if the \`format\` parameter is set to \`"text"\`.
`),
  format: external_exports.enum(["json", "meta", "text"]).default("json").describe(`
In what format to return the extracted text.
- \`"json"\` returns a JSON file.
- \`"meta"\` does not return a file, but stores the data inside Transloadit's file object (under \`\${file.meta.recognized_text}\`, which is an array of strings) that's passed around between encoding <dfn>Steps</dfn>, so that you can use the values to burn the data into videos, filter on them, etc.
- \`"text"\` returns the recognized text as a plain UTF-8 encoded text file.
`)
}).strict();
var robotImageOcrInstructionsWithHiddenFieldsSchema = robotImageOcrInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageOcrInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageOcrInstructionsSchema = interpolateRobot(robotImageOcrInstructionsSchema);
var interpolatableRobotImageOcrInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageOcrInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-optimize.js
init_esm();
var meta49 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      optimized: {
        robot: "/image/optimize",
        use: ":original"
      }
    }
  },
  example_code_description: "Optimize uploaded images:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Image Manipulation",
  purpose_sentence: "reduces the size of images while maintaining the same visual quality",
  purpose_verb: "optimize",
  purpose_word: "optimize",
  purpose_words: "Optimize images without quality loss",
  service_slug: "image-manipulation",
  slot_count: 15,
  title: "Optimize images without quality loss",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  name: "ImageOptimizeRobot",
  priceFactor: 1,
  queueSlotCount: 15,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotImageOptimizeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/image/optimize").describe(`
With this <dfn>Robot</dfn> it's possible to reduce the file size of your JPEG, PNG, GIF, WEBP and SVG images by up to 80% for big images and 65% for small to medium sized ones  while keeping their original quality!

This <dfn>Robot</dfn> enables you to lower your storage and bandwidth costs, and improves your user experience and monetization by reducing the load time of image-intensive web pages.

It works well together with [/image/resize](/docs/robots/image-resize/) to bring the full power of resized and optimized images to your website or app.

> [!Note]
> This <dfn>Robot</dfn> accepts all image types and will just pass on unsupported image types unoptimized. Hence, there is no need to set up [/file/filter](/docs/robots/file-filter/) workflows for this.
`),
  priority: optimize_priority.describe(`
Provides different algorithms for better or worse compression for your images, but that run slower or faster. The value \`"conversion-speed"\` will result in an average compression ratio of 18%. \`"compression-ratio"\` will result in an average compression ratio of 31%.
`),
  progressive: external_exports.boolean().default(false).describe(`
Interlaces the image if set to \`true\`, which makes the result image load progressively in browsers. Instead of rendering the image from top to bottom, the browser will first show a low-res blurry version of the image which is then quickly replaced with the actual image as the data arrives. This greatly increases the user experience, but comes at a loss of about 10% of the file size reduction.
`),
  preserve_meta_data: external_exports.boolean().default(true).describe(`
Specifies if the image's metadata should be preserved during the optimization, or not. If it is not preserved, the file size is even further reduced. But be aware that this could strip a photographer's copyright information, which for obvious reasons can be frowned upon.
`),
  fix_breaking_images: external_exports.boolean().default(true).describe(`
If set to \`true\` this parameter tries to fix images that would otherwise make the underlying tool error out and thereby break your <dfn>Assemblies</dfn>. This can sometimes result in a larger file size, though.
`)
}).strict();
var robotImageOptimizeInstructionsWithHiddenFieldsSchema = robotImageOptimizeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageOptimizeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotImageOptimizeInstructionsSchema = interpolateRobot(robotImageOptimizeInstructionsSchema);
var interpolatableRobotImageOptimizeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageOptimizeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/image-resize.js
init_esm();
var meta50 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      resized: {
        robot: "/image/resize",
        use: ":original",
        width: 200
      }
    }
  },
  example_code_description: "Resize uploaded images to a width of 200px while keeping their original aspect ratio:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Image Manipulation",
  purpose_sentence: "resizes, crops, changes colorization, rotation, and applies text and watermarks to images",
  purpose_verb: "convert",
  purpose_word: "convert/resize/watermark",
  purpose_words: "Convert, resize, or watermark images",
  service_slug: "image-manipulation",
  slot_count: 5,
  title: "Convert, resize, or watermark images",
  typical_file_size_mb: 0.8,
  typical_file_type: "image",
  uses_tools: ["imagemagick"],
  name: "ImageResizeRobot",
  priceFactor: 1,
  queueSlotCount: 5,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var oneTextSchema = external_exports.object({
  // TODO: Determine valid fonts
  text: external_exports.string(),
  font: external_exports.string().default("Arial").describe(`
The font family to use. Also includes boldness and style of the font.

[Here](/docs/supported-formats/fonts/) is a list of all
supported fonts.
`),
  size: external_exports.number().int().min(1).default(12).describe(`
The text size in pixels.
`),
  rotate: external_exports.number().int().default(0).describe(`
The rotation angle in degrees.
`),
  color: color_without_alpha_with_named.default("#000000").describe(`
The text color. All hex colors in the form \`"#xxxxxx"\` are supported, where each x can be \`0-9\` or \`a-f\`. Named colors like \`"black"\`, \`"white"\`, \`"transparent"\` etc. are also supported. If you want a transparent text color, use "stroke" instead, otherwise your text will not be visible.
`),
  background_color: color_without_alpha_with_named.default("transparent").describe(`
The background color behind the text. All hex colors in the form \`"#xxxxxx"\` are supported, where each x can be \`0-9\` or \`a-f\`. Named colors like \`"black"\`, \`"white"\`, \`"transparent"\` etc. are also supported.
`),
  stroke_width: external_exports.number().int().min(0).default(0).describe(`
The stroke's width in pixels.
`),
  stroke_color: color_without_alpha_with_named.default("transparent").describe(`
The stroke's color. All hex colors in the form \`"#xxxxxx"\` are supported, where each x can be \`0-9\` or \`a-f\`. Named colors like \`"black"\`, \`"white"\`, \`"transparent"\` etc. are also supported.
`),
  align: external_exports.enum(["center", "left", "right"]).default("center").describe(`
The horizontal text alignment. Can be \`"left"\`, \`"center"\` and \`"right"\`.
`),
  valign: external_exports.enum(["bottom", "center", "top"]).default("center").describe(`
The vertical text alignment. Can be \`"top"\`, \`"center"\` and \`"bottom"\`.
`),
  x_offset: external_exports.number().int().default(0).describe(`
The horizontal offset for the text in pixels that is added (positive integer) or removed (negative integer) from the horizontal alignment.
`),
  y_offset: external_exports.number().int().default(0).describe(`
The vertical offset for the text in pixels that is added (positive integer) or removed (negative integer) from the vertical alignment.
`)
});
var TEXT_DESCRIPTION = `
Text overlays to be applied to the image. Can be either a single text object or an array of text objects. Each text object contains text rules. The following text parameters are intended to be used as properties for your text overlays. Here is an example:

\`\`\`json
"watermarked": {
  "use": "resized",
  "robot": "/image/resize",
  "text": [
    {
      "text": " 2018 Transloadit.com",
      "size": 12,
      "font": "Ubuntu",
      "color": "#eeeeee",
      "valign": "bottom",
      "align": "right",
      "x_offset": 16,
      "y_offset": -10
    }
  ]
}
\`\`\``;
var robotImageResizeInstructionsSchema = robotBase.merge(robotUse).merge(robotImagemagick).extend({
  robot: external_exports.literal("/image/resize"),
  // TODO: Use an enum
  format: external_exports.string().nullable().default(null).describe(`
The output format for the modified image.

Some of the most important available formats are \`"jpg"\`, \`"png"\`, \`"gif"\`, and \`"tiff"\`. For a complete lists of all formats that we can write to please check [our supported image formats list](/docs/supported-formats/image-formats/).

If \`null\` (default), then the input image's format will be used as the output format.

If you wish to convert to \`"pdf"\`, please consider [/document/convert](/docs/robots/document-convert/) instead.
`),
  width: complexWidthSchema.optional().describe(`
Width of the result in pixels. If not specified, will default to the width of the original.
`),
  height: complexHeightSchema.optional().describe(`
Height of the new image, in pixels. If not specified, will default to the height of the input image.
`),
  resize_strategy: external_exports.union([
    external_exports.literal("crop").describe(`Cuts an area out of an image, discarding any overlapping parts. If the source image is smaller than the crop frame, it will be zoomed. This strategy is implied when you specify coordinates in the \`crop\` parameter, and cannot be used without it.

To crop around human faces, see [/image/facedetect](https://transloadit.com/docs/robots/image-facedetect/) instead.`),
    external_exports.literal("fillcrop").describe(`Scales the image to fit into our 100100 target while preserving aspect ratio, while trimming away any excess surface. This means both sides will become exactly 100 pixels, at the tradeoff of destroying parts of the image.

By default the resulting image is horizontally/vertically centered to fill the target rectangle. Use the \`gravity\` parameter to change where to crop the image, such as \`"bottom\`" or \`"left\`".`),
    external_exports.literal("fit").describe(`Uses the larger side of the original image as a base for the resize. Aspect ratio is preserved. Either side will become at most 100 pixels.

For example: resizing a 400300 image into 100100, would produce a 10075 image.`),
    external_exports.literal("min_fit").describe(`Uses the **smaller** side of the original image as a base for the resize. After resizing, the larger side will have a larger value than specified. Aspect ratio is preserved. Either side will become at least 100 pixels.

For example: resizing a 400300 image into 100100, would produce a 133100 image.`),
    external_exports.literal("pad").describe(`Scales the image to fit while preserving aspect ratio. Both sides of the resized image become exactly 100 pixels, and any remaining surface is filled with a background color.

In this example, the background color is determined by the [Assembly Variable](https://transloadit.com/docs/topics/assembly-instructions/#assembly-variables) \`\${file.meta.average_color}\`. If you set \`zoom\` to \`false\` (default is \`true\`), smaller images will be centered horizontally and vertically, and have the background padding all around them.`),
    external_exports.literal("stretch").describe("Ignores aspect ratio, resizing the image to the exact width and height specified. This may result in a stretched or distorted image.")
  ]).default("fit").describe(`
See the list of available [resize strategies](/docs/topics/resize-strategies/).
`),
  zoom: external_exports.boolean().default(true).describe(`
If this is set to \`false\`, smaller images will not be stretched to the desired width and height. For details about the impact of zooming for your preferred resize strategy, see the list of available [resize strategies](/docs/topics/resize-strategies/).
`),
  crop: unsafeCoordinatesSchema.optional().describe(`
Specify an object containing coordinates for the top left and bottom right corners of the rectangle to be cropped from the original image(s). The coordinate system is rooted in the top left corner of the image. Values can be integers for absolute pixel values or strings for percentage based values.

For example:

\`\`\`json
{
  "x1": 80,
  "y1": 100,
  "x2": "60%",
  "y2": "80%"
}
\`\`\`

This will crop the area from \`(80, 100)\` to \`(600, 800)\` from a 10001000 pixels image, which is a square whose width is 520px and height is 700px. If \`crop\` is set, the width and height parameters are ignored, and the \`resize_strategy\` is set to \`crop\` automatically.

You can also use a JSON string of such an object with coordinates in similar fashion:

\`\`\`json
"{\\"x1\\": <Integer>, \\"y1\\": <Integer>, \\"x2\\": <Integer>, \\"y2\\": <Integer>}"
\`\`\`

To crop around human faces, see [/image/facedetect](/docs/robots/image-facedetect/).
`),
  gravity: positionSchema.default("center").describe(`
The direction from which the image is to be cropped, when \`"resize_strategy"\` is set to \`"crop"\`, but no crop coordinates are defined.
`),
  strip: external_exports.boolean().default(false).describe(`
Strips all metadata from the image. This is useful to keep thumbnails as small as possible.
`),
  alpha: external_exports.enum([
    "Activate",
    "Background",
    "Copy",
    "Deactivate",
    "Extract",
    "Off",
    "On",
    "Opaque",
    "Remove",
    "Set",
    "Shape",
    "Transparent"
  ]).optional().describe(`
Gives control of the alpha/matte channel of an image.
`),
  preclip_alpha: external_exports.enum([
    "Activate",
    "Background",
    "Copy",
    "Deactivate",
    "Extract",
    "Off",
    "On",
    "Opaque",
    "Remove",
    "Set",
    "Shape",
    "Transparent"
  ]).optional().describe(`
Gives control of the alpha/matte channel of an image before applying the clipping path via \`clip: true\`.
`),
  flatten: external_exports.boolean().default(true).describe(`
Flattens all layers onto the specified background to achieve better results from transparent formats to non-transparent formats, as explained in the [ImageMagick documentation](https://www.imagemagick.org/script/command-line-options.php#layers).

To preserve animations, GIF files are not flattened when this is set to \`true\`. To flatten GIF animations, use the \`frame\` parameter.
`),
  correct_gamma: external_exports.boolean().default(false).describe(`
Prevents gamma errors [common in many image scaling algorithms](https://www.4p8.com/eric.brasseur/gamma.html).
`),
  quality: imageQualitySchema,
  adaptive_filtering: external_exports.boolean().default(false).describe(`
Controls the image compression for PNG images. Setting to \`true\` results in smaller file size, while increasing processing time. It is encouraged to keep this option disabled.
`),
  background: color_without_alpha_with_named.default("#FFFFFF").describe(`
Either the hexadecimal code or [name](https://www.imagemagick.org/script/color.php#color_names) of the color used to fill the background (used for the \`pad\` resize strategy).

**Note:** By default, the background of transparent images is changed to white. To preserve transparency, set \`"background"\` to \`"none"\`.
`),
  frame: external_exports.number().int().min(1).nullable().default(null).describe(`
Use this parameter when dealing with animated GIF files to specify which frame of the GIF is used for the operation. Specify \`1\` to use the first frame, \`2\` to use the second, and so on. \`null\` means all frames.
`),
  colorspace: colorspaceSchema.optional().describe(`
Sets the image colorspace. For details about the available values, see the [ImageMagick documentation](https://www.imagemagick.org/script/command-line-options.php#colorspace). Please note that if you were using \`"RGB"\`, we recommend using \`"sRGB"\` instead as of 2014-02-04. ImageMagick might try to find the most efficient \`colorspace\` based on the color of an image, and default to e.g. \`"Gray"\`. To force colors, you might have to use this parameter in combination with \`type: "TrueColor"\`.
`),
  type: external_exports.enum([
    "Bilevel",
    "ColorSeparation",
    "ColorSeparationAlpha",
    "Grayscale",
    "GrayscaleAlpha",
    "Palette",
    "PaletteAlpha",
    "TrueColor",
    "TrueColorAlpha"
  ]).optional().describe(`
Sets the image color type. For details about the available values, see the [ImageMagick documentation](https://www.imagemagick.org/script/command-line-options.php#type). If you're using \`colorspace\`, ImageMagick might try to find the most efficient based on the color of an image, and default to e.g. \`"Gray"\`. To force colors, you could e.g. set this parameter to \`"TrueColor"\`
`),
  sepia: external_exports.number().int().min(0).max(99).nullable().default(null).describe(`
Applies a sepia tone effect in percent.
`),
  rotation: external_exports.union([
    external_exports.number(),
    // Support any numeric rotation value (including precise angles like 2.9)
    external_exports.boolean(),
    external_exports.literal("auto")
    // Support 'auto' string value
  ]).default(true).describe(`
Determines whether the image should be rotated. Use any number to specify the rotation angle in degrees (e.g., \`90\`, \`180\`, \`270\`, \`360\`, or precise values like \`2.9\`). Use the value \`true\` or \`"auto"\` to auto-rotate images that are rotated incorrectly or depend on EXIF rotation settings. Otherwise, use \`false\` to disable auto-fixing altogether.
`),
  compress: external_exports.enum(["BZip", "Fax", "Group4", "JPEG", "JPEG2000", "Lossless", "LZW", "None", "RLE", "Zip"]).nullable().default(null).describe(`
Specifies pixel compression for when the image is written. Compression is disabled by default.

Please also take a look at [/image/optimize](/docs/robots/image-optimize/).
`),
  blur: external_exports.string().regex(/^\d+(\.\d+)?x\d+(\.\d+)?$/).nullable().default(null).describe(`
Specifies gaussian blur, using a value with the form \`{radius}x{sigma}\`. The radius value specifies the size of area the operator should look at when spreading pixels, and should typically be either \`"0"\` or at least two times the sigma value. The sigma value is an approximation of how many pixels the image is "spread"; think of it as the size of the brush used to blur the image. This number is a floating point value, enabling small values like \`"0.5"\` to be used.
`),
  blur_regions: external_exports.array(external_exports.object({
    // TODO: These types are not documented.
    x: complexWidthSchema,
    y: complexHeightSchema,
    width: complexWidthSchema,
    height: complexHeightSchema
  })).nullable().default(null).describe(`
Specifies an array of ellipse objects that should be blurred on the image. Each object has the following keys: \`x\`, \`y\`, \`width\`, \`height\`.  If \`blur_regions\` has a value, then the \`blur\` parameter is used as the strength of the blur for each region.
`),
  // TODO: An int according to the docs, a float in the example
  brightness: external_exports.number().min(0).default(1).describe(`
Increases or decreases the brightness of the image by using a multiplier. For example \`1.5\` would increase the brightness by 50%, and \`0.75\` would decrease the brightness by 25%.
`),
  // TODO: An int according to the docs, a float in the example
  saturation: external_exports.number().min(0).default(1).describe(`
Increases or decreases the saturation of the image by using a multiplier. For example \`1.5\` would increase the saturation by 50%, and \`0.75\` would decrease the saturation by 25%.
`),
  hue: external_exports.number().min(0).default(100).describe(`
Changes the hue by rotating the color of the image. The value \`100\` would produce no change whereas \`0\` and \`200\` will negate the colors in the image.
`),
  contrast: external_exports.number().min(0).max(2).default(1).describe(`
Adjusts the contrast of the image. A value of \`1\` produces no change. Values below \`1\` decrease contrast (with \`0\` being minimum contrast), and values above \`1\` increase contrast (with \`2\` being maximum contrast). This works like the \`brightness\` parameter.
`),
  watermark_url: external_exports.string().optional().describe(`
A URL indicating a PNG image to be overlaid above this image. Please note that you can also  [supply the watermark via another Assembly Step](/docs/topics/use-parameter/#supplying-the-watermark-via-an-assembly-step). With watermarking you can add an image onto another image. This is usually used for logos.
`),
  watermark_position: external_exports.union([positionSchema, external_exports.array(positionSchema)]).default("center").describe(`
The position at which the watermark is placed. The available options are \`"center"\`, \`"top"\`, \`"bottom"\`, \`"left"\`, and \`"right"\`. You can also combine options, such as \`"bottom-right"\`.

An array of possible values can also be specified, in which case one value will be selected at random, such as \`[ "center", "left", "bottom-left", "bottom-right" ]\`.

This setting puts the watermark in the specified corner. To use a specific pixel offset for the watermark, you will need to add the padding to the image itself.
`),
  watermark_x_offset: external_exports.number().int().default(0).describe(`
The x-offset in number of pixels at which the watermark will be placed in relation to the position it has due to \`watermark_position\`.

Values can be both positive and negative and yield different results depending on the \`watermark_position\` parameter. Positive values move the watermark closer to the image's center point, whereas negative values move the watermark further away from the image's center point.
`),
  watermark_y_offset: external_exports.number().int().default(0).describe(`
The y-offset in number of pixels at which the watermark will be placed in relation to the position it has due to \`watermark_position\`.

Values can be both positive and negative and yield different results depending on the \`watermark_position\` parameter. Positive values move the watermark closer to the image's center point, whereas negative values move the watermark further away from the image's center point.
`),
  watermark_size: percentageSchema.optional().describe(`
The size of the watermark, as a percentage.

For example, a value of \`"50%"\` means that size of the watermark will be 50% of the size of image on which it is placed. The exact sizing depends on \`watermark_resize_strategy\`, too.
`),
  watermark_resize_strategy: external_exports.enum(["area", "fit", "min_fit", "stretch"]).default("fit").describe(`
Available values are \`"fit"\`, \`"min_fit"\`, \`"stretch"\` and \`"area"\`.

To explain how the resize strategies work, let's assume our target image size is 800800 pixels and our watermark image is 400300 pixels. Let's also assume, the \`watermark_size\` parameter is set to \`"25%"\`.

For the \`"fit"\` resize strategy, the watermark is scaled so that the longer side of the watermark takes up 25% of the corresponding image side. And the other side is scaled according to the aspect ratio of the watermark image. So with our watermark, the width is the longer side, and 25% of the image size would be 200px. Hence, the watermark would be resized to 200150 pixels. If the \`watermark_size\` was set to \`"50%"\`, it would be resized to 400300 pixels (so just left at its original size).

For the \`"min_fit"\` resize strategy, the watermark is scaled so that the shorter side of the watermark takes up 25% of the corresponding image side. And the other side is scaled according to the aspect ratio of the watermark image. So with our watermark, the height is the shorter side, and 25% of the image size would be 200px. Hence, the watermark would be resized to 267200 pixels. If the \`watermark_size\` was set to \`"50%"\`, it would be resized to 533400 pixels (so larger than its original size).

For the \`"stretch"\` resize strategy, the watermark is stretched (meaning, it is resized without keeping its aspect ratio in mind) so that both sides take up 25% of the corresponding image side. Since our image is 800800 pixels, for a watermark size of 25% the watermark would be resized to 200200 pixels. Its height would appear stretched, because keeping the aspect ratio in mind it would be resized to 200150 pixels instead.

For the \`"area"\` resize strategy, the watermark is resized (keeping its aspect ratio in check) so that it covers \`"xx%"\` of the image's surface area. The value from \`watermark_size\` is used for the percentage area size.
`),
  watermark_opacity: external_exports.number().min(0).max(1).default(1).describe(`
The opacity of the watermark, where \`0.0\` is fully transparent and \`1.0\` is fully opaque.

For example, a value of \`0.5\` means the watermark will be 50% transparent, allowing the underlying image to show through. This is useful for subtle branding or when you want the watermark to be less obtrusive.
`),
  watermark_repeat_x: external_exports.boolean().default(false).describe(`
When set to \`true\`, the watermark will be repeated horizontally across the entire width of the image.

This is useful for creating tiled watermark patterns that cover the full image and make it more difficult to crop out the watermark.
`),
  watermark_repeat_y: external_exports.boolean().default(false).describe(`
When set to \`true\`, the watermark will be repeated vertically across the entire height of the image.

This is useful for creating tiled watermark patterns that cover the full image. Can be combined with \`watermark_repeat_x\` to tile in both directions.
`),
  text: external_exports.union([
    // Support single text object (backward compatibility)
    oneTextSchema,
    // Support array of text objects (current schema)
    external_exports.array(oneTextSchema)
  ]).optional().describe(TEXT_DESCRIPTION),
  progressive: external_exports.boolean().default(false).describe(`
Interlaces the image if set to \`true\`, which makes the image load progressively in browsers. Instead of rendering the image from top to bottom, the browser will first show a low-res blurry version of the images which is then quickly replaced with the actual image as the data arrives. This greatly increases the user experience, but comes at a cost of a file size increase by around 10%.
`),
  transparent: external_exports.union([color_without_alpha_with_named, external_exports.string().regex(/^\d+,\d+,\d+$/)]).optional().describe(`
Make this color transparent within the image. Example: \`"255,255,255"\`.
`),
  trim_whitespace: external_exports.boolean().default(false).describe(`
This determines if additional whitespace around the image should first be trimmed away. If you set this to \`true\` this parameter removes any edges that are exactly the same color as the corner pixels.
`),
  clip: external_exports.union([external_exports.string(), external_exports.boolean()]).default(false).describe(`
Apply the clipping path to other operations in the resize job, if one is present. If set to \`true\`, it will automatically take the first clipping path. If set to a String it finds a clipping path by that name.
`),
  negate: external_exports.boolean().default(false).describe(`
Replace each pixel with its complementary color, effectively negating the image. Especially useful when testing clipping.
`),
  density: external_exports.string().regex(/\d+(x\d+)?/).nullable().default(null).describe(`
While in-memory quality and file format depth specifies the color resolution, the density of an image is the spatial (space) resolution of the image. That is the density (in pixels per inch) of an image and defines how far apart (or how big) the individual pixels are. It defines the size of the image in real world terms when displayed on devices or printed.

You can set this value to a specific \`width\` or in the format \`width\`x\`height\`.

If your converted image is unsharp, please try increasing density.
`),
  monochrome: external_exports.boolean().default(false).describe(`
Transform the image to black and white. This is a shortcut for setting the colorspace to Gray and type to Bilevel.
`),
  shave: external_exports.union([
    external_exports.string().regex(/^\d+(x\d+)?$/),
    external_exports.number().int().min(0).transform(String)
    // Accept numbers and convert to string
  ]).optional().describe(`
Shave pixels from the image edges. The value should be in the format \`width\` or \`width\`x\`height\` to specify the number of pixels to remove from each side.
`)
}).strict();
var robotImageResizeInstructionsWithHiddenFieldsSchema = robotImageResizeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotImageResizeInstructionsSchema.shape.result]).optional(),
  stack: external_exports.string().optional().describe("Legacy parameter, use imagemagick_stack instead"),
  text: external_exports.union([
    // Support single text object (backward compatibility)
    oneTextSchema.extend({
      gravity: positionSchema.default("top-left").optional().describe(`
            Legacy. The direction from which to start the offsets.
            `)
    }),
    // Support array of text objects (current schema)
    external_exports.array(oneTextSchema.extend({
      gravity: positionSchema.default("top-left").optional().describe(`
              Legacy. The direction from which to start the offsets.
              `)
    }))
  ]).optional().describe(TEXT_DESCRIPTION),
  watermark_position_x: external_exports.number().int().optional().describe(`
      Legacy alias for \`watermark_x_offset\`. The x-offset in number of pixels at which the watermark will be placed.
      `),
  watermark_position_y: external_exports.number().int().optional().describe(`
      Legacy alias for \`watermark_y_offset\`. The y-offset in number of pixels at which the watermark will be placed.
      `)
});
var interpolatableRobotImageResizeInstructionsSchema = interpolateRobot(robotImageResizeInstructionsSchema);
var interpolatableRobotImageResizeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotImageResizeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/meta-read.js
init_esm();
var robotMetaReadInstructionsSchema = robotBase.extend({
  robot: external_exports.literal("/meta/read").describe("Reads metadata from a file.")
}).strict();
var robotMetaReadInstructionsWithHiddenFieldsSchema = robotMetaReadInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotMetaReadInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotMetaReadInstructionsSchema = interpolateRobot(robotMetaReadInstructionsSchema);
var interpolatableRobotMetaReadInstructionsWithHiddenFieldsSchema = interpolateRobot(robotMetaReadInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/meta-write.js
init_esm();
var meta51 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      attributed: {
        robot: "/meta/write",
        use: ":original",
        data_to_write: {
          copyright: " Transloadit"
        },
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "Add a copyright notice to uploaded images:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "Media Cataloging",
  purpose_sentence: "writes metadata into files",
  purpose_verb: "write",
  purpose_word: "write metadata",
  purpose_words: "Write metadata to media",
  service_slug: "media-cataloging",
  slot_count: 10,
  title: "Write metadata to media",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  uses_tools: ["ffmpeg"],
  name: "MetaWriteRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotMetaWriteInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpeg).extend({
  robot: external_exports.literal("/meta/write").describe(`
**Note:** This <dfn>Robot</dfn> currently accepts images, videos and audio files.
`),
  data_to_write: external_exports.record(external_exports.unknown()).default({}).describe(`
A key/value map defining the metadata to write into the file.

Valid metadata keys can be found [here](https://exiftool.org/TagNames/EXIF.html). For example: \`ProcessingSoftware\`.
`)
}).strict();
var robotMetaWriteInstructionsWithHiddenFieldsSchema = robotMetaWriteInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotMetaWriteInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotMetaWriteInstructionsSchema = interpolateRobot(robotMetaWriteInstructionsSchema);
var interpolatableRobotMetaWriteInstructionsWithHiddenFieldsSchema = interpolateRobot(robotMetaWriteInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/minio-import.js
init_esm();
var meta52 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/minio/import",
        credentials: "YOUR_MINIO_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your MinIO bucket",
  purpose_verb: "import",
  purpose_word: "MinIO",
  purpose_words: "Import files from MinIO",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from MinIO",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "MinioImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotMinioImportInstructionsSchema = robotBase.merge(robotImport).merge(minioBase).extend({
  robot: external_exports.literal("/minio/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotMinioImportInstructionsWithHiddenFieldsSchema = robotMinioImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotMinioImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotMinioImportInstructionsSchema = interpolateRobot(robotMinioImportInstructionsSchema);
var interpolatableRobotMinioImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotMinioImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/minio-store.js
init_esm();
var meta53 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/minio/store",
        use: ":original",
        credentials: "YOUR_MINIO_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on MinIO:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to MinIO buckets",
  purpose_verb: "export",
  purpose_word: "MinIO",
  purpose_words: "Export files to MinIO",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to MinIO",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "MinioStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotMinioStoreInstructionsSchema = robotBase.merge(robotUse).merge(minioBase).extend({
  robot: external_exports.literal("/minio/store").describe(`
The URL to the result file will be returned in the <dfn>Assembly Status JSON</dfn>.
`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  acl: external_exports.enum(["private", "public-read"]).default("public-read").describe(`
The permissions used for this file.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on MinIO Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds.

If this parameter is not used, no URL signing is done.
`)
}).strict();
var robotMinioStoreInstructionsWithHiddenFieldsSchema = robotMinioStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotMinioStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotMinioStoreInstructionsSchema = interpolateRobot(robotMinioStoreInstructionsSchema);
var interpolatableRobotMinioStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotMinioStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/progress-simulate.js
init_esm();
var robotProgressSimulateInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/progress/simulate"),
  duration: external_exports.number(),
  output_files: external_exports.number(),
  emit_progress: external_exports.boolean(),
  predict_output: external_exports.boolean()
}).strict();
var interpolatableRobotProgressSimulateInstructionsSchema = interpolateRobot(robotProgressSimulateInstructionsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/s3-import.js
init_esm();
var meta54 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/s3/import",
        credentials: "YOUR_AWS_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your S3 bucket",
  purpose_verb: "import",
  purpose_word: "Amazon S3",
  purpose_words: "Import files from Amazon S3",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 10,
  title: "Import files from Amazon S3",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "S3ImportRobot",
  priceFactor: 10,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotS3ImportInstructionsSchema = robotBase.merge(robotImport).merge(s3Base).extend({
  robot: external_exports.literal("/s3/import").describe(`
If you are new to Amazon S3, see our tutorial on [using your own S3 bucket](/docs/faq/how-to-set-up-an-amazon-s3-bucket/).

The URL to the result file in your S3 bucket will be returned in the <dfn>Assembly Status JSON</dfn>.

> [!Warning]
> **Use DNS-compliant bucket names**. Your bucket name [must be DNS-compliant](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html) and must not contain uppercase letters. Any non-alphanumeric characters in the file names will be replaced with an underscore, and spaces will be replaced with dashes. If your existing S3 bucket contains uppercase letters or is otherwise not DNS-compliant, rewrite the result URLs using the <dfn>Robot</dfn>s \`url_prefix\` parameter.

<span id="minimum-s3-iam-permissions" aria-hidden="true"></span>

## Limit access

You will also need to add permissions to your bucket so that Transloadit can access it properly. Here is an example IAM policy that you can use. Following the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), it contains the **minimum required permissions** to export a file to your S3 bucket using Transloadit. You may require more permissions (especially viewing permissions) depending on your application.

Please change \`{BUCKET_NAME}\` in the values for \`Sid\` and \`Resource\` accordingly. Also, this policy will grant the minimum required permissions to all your users. We advise you to create a separate Amazon IAM user, and use its User ARN (can be found in the "Summary" tab of a user [here](https://console.aws.amazon.com/iam/home#users)) for the \`Principal\` value. More information about this can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/AccessPolicyLanguage_UseCases_s3_a.html).

\`\`\`json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowTransloaditToImportFilesIn{BUCKET_NAME}Bucket",
      "Effect": "Allow",
      "Action": ["s3:GetBucketLocation", "s3:ListBucket"],
      "Resource": ["arn:aws:s3:::{BUCKET_NAME}", "arn:aws:s3:::{BUCKET_NAME}/*"]
    }
  ]
}
\`\`\`

The \`Sid\` value is just an identifier for you to recognize the rule later. You can name it anything you like.

The policy needs to be separated into two parts, because the \`ListBucket\` action requires permissions on the bucket while the other actions require permissions on the objects in the bucket. When targeting the objects there's a trailing slash and an asterisk in the \`Resource\` parameter, whereas when the policy targets the bucket, the slash and the asterisk are omitted.

In order to build proper result URLs we need to know the region in which your S3 bucket resides. For this we require the \`GetBucketLocation\` permission. Figuring out your bucket's region this way will also slow down your Assemblies. To make this much faster and to also not require the \`GetBucketLocation\` permission, we have added the \`bucket_region\` parameter to the /s3/store and /s3/import Robots. We recommend using them at all times.

Please keep in mind that if you use bucket encryption you may also need to add \`"sts:*"\` and \`"kms:*"\` to the bucket policy. Please read [here](https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html) and [here](https://aws.amazon.com/blogs/security/how-to-restrict-amazon-s3-bucket-access-to-a-specific-iam-role/) in case you run into trouble with our example bucket policy.
`),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants to this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.optional().describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.optional().describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs,
  range: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional().describe(`
Allows you to specify one or more byte ranges to import from the file. S3 must support range requests for this to work.

**Single range**: Use a string like \`"0-99"\` to import bytes 0-99 (the first 100 bytes).

**Multiple ranges**: Use an array like \`["0-99", "200-299"]\` to import multiple separate ranges. The resulting file will contain all requested ranges concatenated together, with zero bytes (\\0) filling any gaps between non-contiguous ranges.

**Range formats**:
- \`"0-99"\`: Bytes 0 through 99 (inclusive)
- \`"100-199"\`: Bytes 100 through 199 (inclusive)
- \`"-100"\`: The last 100 bytes of the file

**Important notes**:
- S3 supports range requests by default
- Overlapping ranges are allowed and will be included as requested
- The resulting file size will be the highest byte position requested, with gaps filled with zero bytes
- Each range is fetched in a separate request to ensure compatibility with S3
`)
}).strict();
var robotS3ImportInstructionsWithHiddenFieldsSchema = robotS3ImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotS3ImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotS3ImportInstructionsSchema = interpolateRobot(robotS3ImportInstructionsSchema);
var interpolatableRobotS3ImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotS3ImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/s3-store.js
init_esm();
var meta55 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      exported: {
        robot: "/s3/store",
        use: ":original",
        credentials: "YOUR_AWS_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` in an S3 bucket:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Amazon S3",
  purpose_verb: "export",
  purpose_word: "Amazon S3",
  purpose_words: "Export files to Amazon S3",
  service_slug: "file-exporting",
  slot_count: 2,
  title: "Export files to Amazon S3",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "S3StoreRobot",
  priceFactor: 10,
  queueSlotCount: 2,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  stage: "ga",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotS3StoreInstructionsSchema = robotBase.merge(robotUse).merge(s3Base).extend({
  robot: external_exports.literal("/s3/store").describe(`
If you are new to Amazon S3, see our tutorial on [using your own S3 bucket](/docs/faq/how-to-set-up-an-amazon-s3-bucket/).

The URL to the result file in your S3 bucket will be returned in the <dfn>Assembly Status JSON</dfn>. If your S3 bucket has versioning enabled, the version ID of the file will be returned within \`meta.version_id\`

> [!Warning]
> **Avoid permission errors.** By default, \`acl\` is set to \`"public"\`. AWS S3 has a bucket setting called "Block new public ACLs and uploading public objects". Set this to <strong>False</strong> in your bucket if you intend to leave \`acl\` as \`"public"\`. Otherwise, youll receive permission errors in your Assemblies despite your S3 credentials being configured correctly.

> [!Warning]
> **Use DNS-compliant bucket names.** Your bucket name [must be DNS-compliant](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html) and must not contain uppercase letters. Any non-alphanumeric characters in the file names will be replaced with an underscore, and spaces will be replaced with dashes. If your existing S3 bucket contains uppercase letters or is otherwise not DNS-compliant, rewrite the result URLs using the <dfn>Robot</dfn>s \`url_prefix\` parameter.

<span id="minimum-s3-iam-permissions" aria-hidden="true"></span>

## Limit access

You will also need to add permissions to your bucket so that Transloadit can access it properly. Here is an example IAM policy that you can use. Following the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), it contains the **minimum required permissions** to export a file to your S3 bucket using Transloadit. You may require more permissions (especially viewing permissions) depending on your application.

Please change \`{BUCKET_NAME}\` in the values for \`Sid\` and \`Resource\` accordingly. Also, this policy will grant the minimum required permissions to all your users. We advise you to create a separate Amazon IAM user, and use its User ARN (can be found in the "Summary" tab of a user [here](https://console.aws.amazon.com/iam/home#users)) for the \`Principal\` value. More information about this can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/AccessPolicyLanguage_UseCases_s3_a.html).

\`\`\`json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowTransloaditToStoreFilesIn{BUCKET_NAME}Bucket",
      "Effect": "Allow",
      "Action": ["s3:GetBucketLocation", "s3:ListBucket", "s3:PutObject", "s3:PutObjectAcl"],
      "Resource": ["arn:aws:s3:::{BUCKET_NAME}", "arn:aws:s3:::{BUCKET_NAME}/*"]
    }
  ]
}
\`\`\`

The \`Sid\` value is just an identifier for you to recognize the rule later. You can name it anything you like.

The policy needs to be separated into two parts, because the \`ListBucket\` action requires permissions on the bucket while the other actions require permissions on the objects in the bucket. When targeting the objects there's a trailing slash and an asterisk in the \`Resource\` parameter, whereas when the policy targets the bucket, the slash and the asterisk are omitted.

Please note that if you give the <dfn>Robot</dfn>'s \`acl\` parameter a value of \`"bucket-default"\`, then you do not need the \`"s3:PutObjectAcl"\` permission in your bucket policy.

In order to build proper result URLs we need to know the region in which your S3 bucket resides. For this we require the \`GetBucketLocation\` permission. Figuring out your bucket's region this way will also slow down your Assemblies. To make this much faster and to also not require the \`GetBucketLocation\` permission, we have added the \`bucket_region\` parameter to the /s3/store and /s3/import Robots. We recommend using them at all times.

Please keep in mind that if you use bucket encryption you may also need to add \`"sts:*"\` and \`"kms:*"\` to the bucket policy. Please read [here](https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html) and [here](https://aws.amazon.com/blogs/security/how-to-restrict-amazon-s3-bucket-access-to-a-specific-iam-role/) in case you run into trouble with our example bucket policy.
`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  url_prefix: external_exports.string().default("http://{bucket}.s3.amazonaws.com/").describe(`
The URL prefix used for the returned URL, such as \`"http://my.cdn.com/some/path/"\`.
`),
  acl: external_exports.enum(["bucket-default", "private", "public", "public-read"]).default("public-read").describe(`
The permissions used for this file.

Please keep in mind that the default value \`"public-read"\` can lead to permission errors due to the \`"Block all public access"\` checkbox that is checked by default when creating a new Amazon S3 Bucket in the AWS console.
`),
  check_integrity: external_exports.boolean().default(false).describe(`
Calculate and submit the file's checksum in order for S3 to verify its integrity after uploading, which can help with occasional file corruption issues.

Enabling this option adds to the overall execution time, as integrity checking can be CPU intensive, especially for larger files.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on S3, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables). You can find a list of available headers [here](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUT.html).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  tags: external_exports.record(external_exports.string()).default({}).describe(`
Object tagging allows you to categorize storage. You can associate up to 10 tags with an object. Tags that are associated with an object must have unique tag keys.
`),
  host: external_exports.string().default("s3.amazonaws.com").describe(`
The host of the storage service used. This only needs to be set when the storage service used is not Amazon S3, but has a compatible API (such as hosteurope.de). The default protocol used is HTTP, for anything else the protocol needs to be explicitly specified. For example, prefix the host with \`https://\` or \`s3://\` to use either respective protocol.
`),
  no_vhost: external_exports.boolean().default(false).describe(`
Set to \`true\` if you use a custom host and run into access denied errors.
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_url\` and \`signed_ssl_url\` properties). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`),
  session_token: external_exports.string().optional().describe(`
The session token to use for the S3 store. This is only used if the credentials are from an IAM user with the \`sts:AssumeRole\` permission.
`)
}).strict();
var robotS3StoreInstructionsWithHiddenFieldsSchema = robotS3StoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotS3StoreInstructionsSchema.shape.result]).optional(),
  skip_region_lookup: external_exports.boolean().optional().describe(`
Internal parameter to skip region lookup for testing purposes.
`)
});
var interpolatableRobotS3StoreInstructionsSchema = interpolateRobot(robotS3StoreInstructionsSchema);
var interpolatableRobotS3StoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotS3StoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/script-run.js
init_esm();
var meta56 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "Code Evaluation",
  purpose_sentence: "runs scripts in Assemblies",
  purpose_verb: "run",
  purpose_word: "script",
  purpose_words: "Run scripts in Assemblies",
  service_slug: "code-evaluation",
  slot_count: 5,
  title: "Run Scripts",
  typical_file_size_mb: 1e-4,
  typical_file_type: "file",
  name: "ScriptRunRobot",
  priceFactor: 10,
  queueSlotCount: 5,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotScriptRunInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/script/run").describe(`
This <dfn>Robot</dfn> allows you to run arbitrary \`JavaScript\` as part of the <dfn>Assembly</dfn>
execution process. The <dfn>Robot</dfn> is invoked automatically when there are <dfn>Assembly
Instructions</dfn> containing \`\${...}\`:

\`\`\`json
{
  "robot": "/image/resize",
  "width": "\${Math.max(file.meta.width, file.meta.height)}"
}
\`\`\`

You can also invoke this <dfn>Robot</dfn> directly, leaving out the \`\${...}\`:

\`\`\`json
{
  "robot": "/script/run",
  "script": "Math.max(file.meta.width, file.meta.height)"
}
\`\`\`

When accessing arrays, the syntax is the same as in any JavaScript program:

\`\`\`json
{
  "robot": "/image/resize",
  "width": "\${file.meta.faces[0].width * 2}"
}
\`\`\`

Compared to only accessing an <dfn>Assembly Variable</dfn>:

\`\`\`json
{
  "robot": "/image/resize",
  "width": "\${file.meta.faces[0].width}"
}
\`\`\`

For more information, see [Dynamic Evaluation](/docs/topics/dynamic-evaluation/).
`),
  script: external_exports.string().describe(`
A string of JavaScript to evaluate. It has access to all JavaScript features available in a modern browser environment.

The script is expected to return a \`JSON.stringify\`-able value in the same tick, so no \`await\` or callbacks are allowed (yet).

If the script does not finish within 1000ms it times out with an error. The return value or error is exported as \`file.meta.result\`. If there was an error, \`file.meta.isError\` is \`true\`. Note that the <dfn>Assembly</dfn> will not crash in this case. If you need it to crash, you can check this value with a [/file/filter](/docs/robots/file-filter/) <dfn>Step</dfn>, setting \`error_on_decline\` to \`true\`.

You can check whether evaluating this script was free by inspecting \`file.meta.isFree\`. It is recommended to do this during development as to not see sudden unexpected costs in production.
`)
}).strict();
var robotScriptRunInstructionsWithHiddenFieldsSchema = robotScriptRunInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotScriptRunInstructionsSchema.shape.result]).optional(),
  contextJSON: external_exports.string().optional().describe(`
A JSON string that provides additional context data to the script. This will be parsed and made available to the script as a \`context\` variable. For example, if you pass \`'{"foo":{"bar":"baz"}}'\`, the script can access \`context.foo.bar\` to get the value \`"baz"\`.
`)
});
var interpolatableRobotScriptRunInstructionsSchema = interpolateRobot(robotScriptRunInstructionsSchema);
var interpolatableRobotScriptRunInstructionsWithHiddenFieldsSchema = interpolateRobot(robotScriptRunInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/sftp-import.js
init_esm();
var meta57 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/sftp/import",
        credentials: "YOUR_SFTP_CREDENTIALS",
        path: "path/to/files/"
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole libraries of files from your SFTP servers into Transloadit. This Robot relies on public key authentication",
  purpose_verb: "import",
  purpose_word: "SFTP servers",
  purpose_words: "Import files from SFTP servers",
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from SFTP servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SftpImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotSftpImportInstructionsSchema = robotBase.merge(robotImport).merge(sftpBase).extend({
  robot: external_exports.literal("/sftp/import"),
  path: external_exports.string().describe(`
The path on your SFTP server where to search for files.
`)
}).strict();
var robotSftpImportInstructionsWithHiddenFieldsSchema = robotSftpImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSftpImportInstructionsSchema.shape.result]).optional(),
  allowNetwork: external_exports.string().optional().describe(`
Network access permission for the SFTP connection. This is used to control which networks the SFTP robot can access.
`)
});
var interpolatableRobotSftpImportInstructionsSchema = interpolateRobot(robotSftpImportInstructionsSchema);
var interpolatableRobotSftpImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSftpImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/sftp-store.js
init_esm();
var meta58 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/sftp/store",
        use: ":original",
        credentials: "YOUR_SFTP_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on an SFTP server:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to your own SFTP server",
  purpose_verb: "export",
  purpose_word: "SFTP servers",
  purpose_words: "Export files to SFTP servers",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to SFTP servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SftpStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotSftpStoreInstructionsSchema = robotBase.merge(robotUse).merge(sftpBase).extend({
  robot: external_exports.literal("/sftp/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  url_template: external_exports.string().default("http://host/path").describe(`
The URL of the file in the result JSON. This may include any of the following supported [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables).
`),
  ssl_url_template: external_exports.string().default("https://{HOST}/{PATH}").describe(`
  The SSL URL of the file in the result JSON. The following [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables) are supported.
`),
  file_chmod: external_exports.string().regex(/([0-7]{3}|auto)/).default("auto").describe(`
This optional parameter controls how an uploaded file's permission bits are set. You can use any string format that the \`chmod\` command would accept, such as \`"755"\`. If you don't specify this option, the file's permission bits aren't changed at all, meaning it's up to your server's configuration (e.g. umask).
      `)
}).strict();
var robotSftpStoreInstructionsWithHiddenFieldsSchema = robotSftpStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSftpStoreInstructionsSchema.shape.result]).optional(),
  allowNetwork: external_exports.string().optional().describe(`
Network access permission for the SFTP connection. This is used to control which networks the SFTP robot can access.
`)
});
var interpolatableRobotSftpStoreInstructionsSchema = interpolateRobot(robotSftpStoreInstructionsSchema);
var interpolatableRobotSftpStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSftpStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/speech-transcribe.js
init_esm();
var meta59 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      transcribed: {
        robot: "/speech/transcribe",
        use: ":original",
        provider: "aws",
        source_language: "fr-FR",
        format: "text"
      }
    }
  },
  example_code_description: "Transcribe speech in French from uploaded audio or video, and save it to a text file:",
  extended_description: `
> [!Warning]
> Transloadit aims to be deterministic, but this <dfn>Robot</dfn> uses third-party AI services. The providers (AWS, GCP) will evolve their models over time, giving different responses for the same input media. Avoid relying on exact responses in your tests and application.
`,
  minimum_charge: 1048576,
  output_factor: 0.05,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "transcribes speech in audio or video files",
  purpose_verb: "transcribe",
  purpose_word: "transcribe speech",
  purpose_words: "Transcribe speech in audio or video files",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Transcribe speech in audio or video files",
  typical_file_size_mb: 2.4,
  typical_file_type: "audio or video file",
  name: "SpeechTranscribeRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsdPerSpeechTranscribeMinute: {
    aws: 0.024,
    gcp: 0.016
  },
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotSpeechTranscribeInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/speech/transcribe").describe(`
You can use the text that we return in your application, or you can pass the text down to other <dfn>Robots</dfn> to filter audio or video files that contain (or do not contain) certain content, or burn the text into images or video for example.

Another common use case is automatically subtitling videos, or making audio searchable.
`),
  provider: aiProviderSchema.describe(`
Which AI provider to leverage.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.
`),
  granularity: granularitySchema.describe(`
Whether to return a full response (\`"full"\`), or a flat list of descriptions (\`"list"\`).
`),
  format: external_exports.enum(["json", "meta", "srt", "meta", "text", "webvtt"]).default("json").describe(`
Output format for the transcription.

- \`"text"\` outputs a plain text file that you can store and process.
- \`"json"\` outputs a JSON file containing timestamped words.
- \`"srt"\` and \`"webvtt"\` output subtitle files of those respective file types, which can be stored separately or used in other encoding <dfn>Steps</dfn>.
- \`"meta"\` does not return a file, but stores the data inside  Transloadit's file object (under \`\${file.meta.transcription.text}\`) that's passed around between encoding <dfn>Steps</dfn>, so that you can use the values to burn the data into videos, filter on them, etc.
`),
  // TODO determine the list of languages
  source_language: external_exports.string().default("en-US").describe(`
The spoken language of the audio or video. This will also be the language of the transcribed text.

The language should be specified in the [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) format, such as \`"en-GB"\`, \`"de-DE"\` or \`"fr-FR"\`. Please also consult the list of supported languages for [the \`gcp\` provider](https://cloud.google.com/speech-to-text/docs/languages) and the [the \`aws\` provider](https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe.html).
`),
  // TODO determine the list of languages
  target_language: external_exports.string().default("en-US").describe(`
      This will also be the language of the written text.

      The language should be specified in the [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) format, such as \`"en-GB"\`, \`"de-DE"\` or \`"fr-FR"\`. Please consult the list of supported languages and voices.
    `)
}).strict();
var robotSpeechTranscribeInstructionsWithHiddenFieldsSchema = robotSpeechTranscribeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSpeechTranscribeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotSpeechTranscribeInstructionsSchema = interpolateRobot(robotSpeechTranscribeInstructionsSchema);
var interpolatableRobotSpeechTranscribeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSpeechTranscribeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/supabase-import.js
init_esm();
var meta60 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/supabase/import",
        credentials: "YOUR_SUPABASE_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Supabase bucket",
  purpose_verb: "import",
  purpose_word: "Supabase",
  purpose_words: "Import files from Supabase",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Supabase",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SupabaseImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotSupabaseImportInstructionsSchema = robotBase.merge(robotImport).merge(supabaseBase).extend({
  robot: external_exports.literal("/supabase/import").describe(`
The URL to the result file will be returned in the <dfn>Assembly Status JSON</dfn>.
`),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subfolders and sub-subfolders, etc. of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotSupabaseImportInstructionsWithHiddenFieldsSchema = robotSupabaseImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSupabaseImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotSupabaseImportInstructionsSchema = interpolateRobot(robotSupabaseImportInstructionsSchema);
var interpolatableRobotSupabaseImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSupabaseImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/supabase-store.js
init_esm();
var meta61 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/supabase/store",
        use: ":original",
        credentials: "YOUR_SUPABASE_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on supabase R2:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to supabase buckets",
  purpose_verb: "export",
  purpose_word: "Supabase",
  purpose_words: "Export files to Supabase",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Supabase",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SupabaseStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga",
  isInternal: false
};
var robotSupabaseStoreInstructionsSchema = robotBase.merge(robotUse).merge(supabaseBase).extend({
  robot: external_exports.literal("/supabase/store"),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on supabase Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`)
}).strict();
var robotSupabaseStoreInstructionsWithHiddenFieldsSchema = robotSupabaseStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSupabaseStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotSupabaseStoreInstructionsSchema = interpolateRobot(robotSupabaseStoreInstructionsSchema);
var interpolatableRobotSupabaseStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSupabaseStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/swift-import.js
init_esm();
var meta62 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/swift/import",
        credentials: "YOUR_SWIFT_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Openstack/Swift bucket",
  purpose_verb: "import",
  purpose_word: "Openstack/Swift",
  purpose_words: "Import files from Openstack/Swift",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Openstack/Swift",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SwiftImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotSwiftImportInstructionsSchema = robotBase.merge(robotImport).merge(swiftBase).extend({
  robot: external_exports.literal("/swift/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotSwiftImportInstructionsWithHiddenFieldsSchema = robotSwiftImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSwiftImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotSwiftImportInstructionsSchema = interpolateRobot(robotSwiftImportInstructionsSchema);
var interpolatableRobotSwiftImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSwiftImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/swift-store.js
init_esm();
var meta63 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/swift/store",
        use: ":original",
        credentials: "YOUR_SWIFT_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Swift:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to OpenStack Swift buckets",
  purpose_verb: "export",
  purpose_word: "OpenStack Swift",
  purpose_words: "Export files to OpenStack/Swift",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to OpenStack Swift Spaces",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "SwiftStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotSwiftStoreInstructionsSchema = robotBase.merge(robotUse).merge(swiftBase).extend({
  robot: external_exports.literal("/swift/store").describe(`
The URL to the result file in your OpenStack bucket will be returned in the <dfn>Assembly Status JSON</dfn>.`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  acl: external_exports.enum(["private", "public-read"]).default("public-read").describe(`
The permissions used for this file.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on swift Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`)
}).strict();
var robotSwiftStoreInstructionsWithHiddenFieldsSchema = robotSwiftStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotSwiftStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotSwiftStoreInstructionsSchema = interpolateRobot(robotSwiftStoreInstructionsSchema);
var interpolatableRobotSwiftStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotSwiftStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/text-speak.js
init_esm();
var meta64 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      synthesized: {
        robot: "/text/speak",
        use: ":original",
        provider: "aws",
        voice: "female-1",
        target_language: "en-US"
      }
    }
  },
  example_code_description: "Synthesize speech from uploaded text documents, using a female voice in American English:",
  extended_description: `
> [!Warning]
> Transloadit aims to be deterministic, but this <dfn>Robot</dfn> uses third-party AI services. The providers (AWS, GCP) will evolve their models over time, giving different responses for the same input media. Avoid relying on exact responses in your tests and application.

## Supported languages and voices

{% for provider in text_speak_voices %}

### {{provider[0] | upcase }}

<table class="table">
  <thead>
    <tr>
      <th>Language</th>
      <th>Voices</th>
    </tr>
  </thead>
  <tbody>
    {%- for language in provider[1] %}
      <tr>
        <td><strong>{{language[0]}}</strong></td>
        <td>{{ language[1] | join: ", " }}</td>
      </tr>
    {%- endfor %}
  </tbody>
</table>
{% endfor %}
`,
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "synthesizes speech in documents",
  purpose_verb: "speak",
  purpose_word: "synthesize speech",
  purpose_words: "Synthesize speech in documents",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Speak text",
  typical_file_size_mb: 1,
  typical_file_type: "document",
  name: "TextSpeakRobot",
  priceFactor: 1,
  queueSlotCount: 10,
  minimumChargeUsd: 0.05,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotTextSpeakInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/text/speak").describe(`
You can use the audio that we return in your application, or you can pass the audio down to other <dfn>Robots</dfn> to add a voice track to a video for example.

Another common use case is making your product accessible to people with a reading disability.
`),
  prompt: external_exports.string().nullish().describe(`
Which text to speak. You can also set this to \`null\` and supply an input text file.
`),
  provider: aiProviderSchema.describe(`
Which AI provider to leverage.

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.
`),
  // TODO determine the list of languages
  target_language: external_exports.string().default("en-US").describe(`
The written language of the document. This will also be the language of the spoken text.

The language should be specified in the [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) format, such as \`"en-GB"\`, \`"de-DE"\` or \`"fr-FR"\`. Please consult the list of supported languages and voices.
`),
  voice: external_exports.enum(["female-1", "female-2", "female-3", "female-child-1", "male-1", "male-child-1"]).default("female-1").describe(`
The gender to be used for voice synthesis. Please consult the list of supported languages and voices.
      `),
  ssml: external_exports.boolean().default(false).describe(`
Supply [Speech Synthesis Markup Language](https://en.wikipedia.org/wiki/Speech_Synthesis_Markup_Language) instead of raw text, in order to gain more control over how your text is voiced, including rests and pronounciations.

Please see the supported syntaxes for [AWS](https://docs.aws.amazon.com/polly/latest/dg/supportedtags.html) and [GCP](https://cloud.google.com/text-to-speech/docs/ssml).
`)
}).strict();
var robotTextSpeakInstructionsWithHiddenFieldsSchema = robotTextSpeakInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTextSpeakInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTextSpeakInstructionsSchema = interpolateRobot(robotTextSpeakInstructionsSchema);
var interpolatableRobotTextSpeakInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTextSpeakInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/text-translate.js
init_esm();
var meta65 = {
  allowed_for_url_transform: true,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      translated: {
        robot: "/text/translate",
        use: ":original",
        target_language: "de",
        provider: "aws"
      }
    }
  },
  example_code_description: "Translate uploaded text file contents to German:",
  extended_description: `
> [!Warning]
> This <dfn>Robot</dfn> uses third-party AI services. They may tweak their models over time, giving different responses for the same input media. Avoid relying on exact responses in your tests and application.

## Supported languages

{%- for provider in text_translate_languages %}

### {{provider[0] | upcase }}

<!-- prettier-ignore -->
{%- for language in provider[1] %}
  {{ language }}{% unless forloop.last %},{% endunless %}
{%- endfor %}

{%- endfor %}
`,
  minimum_charge: 1048576,
  output_factor: 1,
  override_lvl1: "Artificial Intelligence",
  purpose_sentence: "translates text in documents",
  purpose_verb: "translate",
  purpose_word: "text",
  purpose_words: "Translate text in documents",
  service_slug: "artificial-intelligence",
  slot_count: 10,
  title: "Translate text",
  typical_file_size_mb: 1,
  typical_file_type: "document",
  name: "TextTranslateRobot",
  priceFactor: 8e-5,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var translatableLanguages = external_exports.enum([
  "af",
  "am",
  "ar",
  "az",
  "be",
  "bg",
  "bn",
  "bs",
  "ca",
  "ceb",
  "co",
  "cs",
  "cy",
  "da",
  "de",
  "el",
  "en",
  "en-US",
  "eo",
  "es",
  "es-MX",
  "et",
  "eu",
  "fa",
  "fa-AF",
  "fi",
  "fr",
  "fr-CA",
  "fy",
  "ga",
  "gd",
  "gl",
  "gu",
  "ha",
  "haw",
  "he",
  "hi",
  "hmn",
  "hr",
  "ht",
  "hu",
  "hy",
  "id",
  "ig",
  "is",
  "it",
  "iw",
  "ja",
  "jv",
  "ka",
  "kk",
  "km",
  "kn",
  "ko",
  "ku",
  "ky",
  "la",
  "lb",
  "lo",
  "lt",
  "lv",
  "mg",
  "mi",
  "mk",
  "ml",
  "mn",
  "mr",
  "ms",
  "mt",
  "my",
  "ne",
  "nl",
  "no",
  "ny",
  "or",
  "pa",
  "pl",
  "ps",
  "pt",
  "ro",
  "ru",
  "rw",
  "sd",
  "si",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sq",
  "sr",
  "st",
  "su",
  "sv",
  "sw",
  "ta",
  "te",
  "tg",
  "th",
  "tk",
  "tl",
  "tr",
  "tt",
  "ug",
  "uk",
  "ur",
  "uz",
  "vi",
  "xh",
  "yi",
  "yo",
  "zh",
  "zh-CN",
  "zh-TW",
  "zu"
]).default("en");
var robotTextTranslateInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/text/translate").describe(`
You can use the text that we return in your application, or you can pass the text down to other <dfn>Robots</dfn> to add a translated subtitle track to a video for example.

> [!Note]
> **This <dfn>Robot</dfn> accepts only files with a \`text/*\` MIME-type,** including plain text and Markdown. For documents in other formats, use [/document/convert](/docs/robots/document-convert/) to first convert them into a compatible text format before proceeding.
`),
  provider: aiProviderSchema.describe(`
Which AI provider to leverage. Valid values are \`"aws"\` (Amazon Web Services) and \`"gcp"\` (Google Cloud Platform).

Transloadit outsources this task and abstracts the interface so you can expect the same data structures, but different latencies and information being returned. Different cloud vendors have different areas they shine in, and we recommend to try out and see what yields the best results for your use case.
`),
  target_language: translatableLanguages.describe(`
The desired language to translate to.

If the exact language can't be found, a generic variant can be fallen back to. For example, if you specify \`"en-US"\`, "en" will be used instead. Please consult the list of supported languages for each provider.
`),
  source_language: translatableLanguages.describe(`
The desired language to translate from.

By default, both providers will detect this automatically, but there are cases where specifying the source language prevents ambiguities.

If the exact language can't be found, a generic variant can be fallen back to. For example, if you specify \`"en-US"\`, "en" will be used instead. Please consult the list of supported languages for each provider.
`)
}).strict();
var robotTextTranslateInstructionsWithHiddenFieldsSchema = robotTextTranslateInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTextTranslateInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTextTranslateInstructionsSchema = interpolateRobot(robotTextTranslateInstructionsSchema);
var interpolatableRobotTextTranslateInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTextTranslateInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/tigris-import.js
init_esm();
var meta66 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/tigris/import",
        credentials: "YOUR_TIGRIS_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your Tigris bucket",
  purpose_verb: "import",
  purpose_word: "Tigris",
  purpose_words: "Import files from Tigris",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Tigris",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "TigrisImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotTigrisImportInstructionsSchema = robotBase.merge(robotImport).merge(tigrisBase).extend({
  robot: external_exports.literal("/tigris/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subdirectories and sub-subdirectories (etc.) of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs,
  bucket_region: external_exports.string().optional().describe("The region of your Tigris bucket. This is optional as it can often be derived.")
}).strict();
var robotTigrisImportInstructionsWithHiddenFieldsSchema = robotTigrisImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTigrisImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTigrisImportInstructionsSchema = interpolateRobot(robotTigrisImportInstructionsSchema);
var interpolatableRobotTigrisImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTigrisImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/tigris-store.js
init_esm();
var meta67 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/tigris/store",
        use: ":original",
        credentials: "YOUR_TIGRIS_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Tigris:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Tigris buckets",
  purpose_verb: "export",
  purpose_word: "Tigris",
  purpose_words: "Export files to Tigris",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Tigris",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "TigrisStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotTigrisStoreInstructionsSchema = robotBase.merge(robotUse).merge(tigrisBase).extend({
  robot: external_exports.literal("/tigris/store").describe(`
The URL to the result file will be returned in the <dfn>Assembly Status JSON</dfn>.
`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  acl: external_exports.enum(["private", "public-read"]).default("public-read").describe(`
The permissions used for this file.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on Tigris, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds.

If this parameter is not used, no URL signing is done.
`),
  bucket_region: external_exports.string().optional().describe("The region of your Tigris bucket. This is optional as it can often be derived.")
}).strict();
var robotTigrisStoreInstructionsWithHiddenFieldsSchema = robotTigrisStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTigrisStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTigrisStoreInstructionsSchema = interpolateRobot(robotTigrisStoreInstructionsSchema);
var interpolatableRobotTigrisStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTigrisStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/tlcdn-deliver.js
init_esm();
var meta68 = {
  allowed_for_url_transform: false,
  bytescount: 20,
  discount_factor: 0.05,
  discount_pct: 95,
  minimum_charge: 102400,
  output_factor: 1,
  override_lvl1: "Content Delivery",
  purpose_sentence: "caches and delivers files globally",
  purpose_verb: "cache & deliver",
  purpose_word: "Cache and deliver files",
  purpose_words: "Cache and deliver files globally",
  service_slug: "content-delivery",
  slot_count: 0,
  title: "Cache and deliver files globally",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "TlcdnDeliverRobot",
  priceFactor: 20,
  queueSlotCount: 0,
  minimumCharge: 102400,
  downloadInputFiles: false,
  preserveInputFileUrls: true,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: false,
  isInternal: true,
  stage: "ga",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotTlcdnDeliverInstructionsSchema = robotBase.extend({
  robot: external_exports.literal("/tlcdn/deliver").describe(`
When you want Transloadit to tranform files on the fly, this <dfn>Robot</dfn> can cache and deliver the results close to your end-user, saving on latency and encoding volume. The use of this <dfn>Robot</dfn> is implicit when you use the <code>tlcdn.com</code> domain.
`)
}).strict();
var robotTlcdnDeliverInstructionsWithHiddenFieldsSchema = robotTlcdnDeliverInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTlcdnDeliverInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTlcdnDeliverInstructionsSchema = interpolateRobot(robotTlcdnDeliverInstructionsSchema);
var interpolatableRobotTlcdnDeliverInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTlcdnDeliverInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/tus-store.js
init_esm();
var meta69 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      exported: {
        robot: "/tus/store",
        use: ":original",
        endpoint: "https://tusd.tusdemo.net/files/"
      }
    }
  },
  example_code_description: "Export uploaded files to the Tus live demo server:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to any Tus-compatible server",
  purpose_verb: "export",
  purpose_word: "Tus servers",
  purpose_words: "Export files to Tus-compatible servers",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Tus-compatible servers",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "TusStoreRobot",
  priceFactor: 10,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotTusStoreInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/tus/store").describe(`
> [!Note]
> This <dfn>Robot</dfn> only accepts videos.

> [!Warning]
> Vimeo's API limits the number of concurrent uploads per minute based on your Vimeo account plan. To see how many videos can be uploaded at once based on your plan, click the following [link](https://developer.vimeo.com/guidelines/rate-limiting#table-1).

## Installation

Since Vimeo works with OAuth, you will need to generate [Template Credentials](https://transloadit.com/c/template-credentials/) to use this <dfn>Robot</dfn>.

To change the \`title\` or \`description\` per video, we recommend to [inject variables into your Template](/docs/topics/templates/).
`),
  endpoint: external_exports.string().url().describe("The URL of the destination Tus server").describe(`
The URL of the Tus-compatible server, which you're uploading files to.
`),
  credentials: external_exports.string().optional().describe(`
Create <dfn>Template Credentials</dfn> for this <dfn>Robot</dfn> in your [Transloadit account](/c/template-credentials/) and use the name of the <dfn>Template Credentials</dfn> as this parameter's value. For this <dfn>Robot</dfn>, use the HTTP template, which allows request headers to be passed along to the destination server.
`),
  headers: external_exports.record(external_exports.string()).default({}).describe("Headers to pass along to destination").describe(`
Optional extra headers outside of the <dfn>Template Credentials</dfn> can be passed along within this parameter.

Although, we recommend to exclusively use <dfn>Template Credentials</dfn>, this may be necessary if you're looking to use dynamic credentials, which isn't a feature supported by <dfn>Template Credentials</dfn>.
`),
  metadata: external_exports.record(external_exports.string()).default({ filename: "example.png", basename: "example", extension: "png" }).describe(`
Metadata to pass along to destination. Includes some file info by default.
`),
  url_template: external_exports.string().optional().describe(`
The URL of the file in the <dfn>Assembly Status JSON</dfn>. The following [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables) are supported. If this is not specified, the upload URL specified by the destination server will be used instead.
`),
  ssl_url_template: external_exports.string().optional().describe(`
The SSL URL of the file in the <dfn>Assembly Status JSON</dfn>. The following [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables) are supported. If this is not specified, the upload URL specified by the destination server will be used instead, as long as it starts with \`https\`.
`)
}).strict();
var robotTusStoreInstructionsWithHiddenFieldsSchema = robotTusStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotTusStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotTusStoreInstructionsSchema = interpolateRobot(robotTusStoreInstructionsSchema);
var interpolatableRobotTusStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotTusStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/upload-handle.js
init_esm();
var meta70 = {
  allowed_for_url_transform: false,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      ":original": {
        robot: "/upload/handle"
      },
      exported: {
        robot: "/s3/store",
        use: ":original",
        credentials: "YOUR_S3_CREDENTIALS"
      }
    }
  },
  example_code_description: "Handle uploads and export the uploaded files to S3:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "Handling Uploads",
  purpose_sentence: "receives uploads that your users throw at you from browser or apps, or that you throw at us programmatically",
  purpose_verb: "handle",
  purpose_word: "handle uploads",
  purpose_words: "Handle uploads",
  service_slug: "handling-uploads",
  slot_count: 0,
  title: "Handle uploads",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "UploadHandleRobot",
  priceFactor: 10,
  queueSlotCount: 0,
  downloadInputFiles: false,
  preserveInputFileUrls: true,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotUploadHandleInstructionsSchema = robotBase.extend({
  robot: external_exports.literal("/upload/handle").describe(`
Transloadit handles file uploads by default, so specifying this <dfn>Robot</dfn> is optional.

It can still be a good idea to define this <dfn>Robot</dfn>, though. It makes your <dfn>Assembly Instructions</dfn> explicit, and allows you to configure exactly how uploads should be handled. For example, you can extract specific metadata from the uploaded files.

There are **3 important constraints** when using this <dfn>Robot</dfn>:

1. Dont define a \`use\` parameter, unlike with other <dfn>Robots</dfn>.
2. Use it only once in a single set of <dfn>Assembly Instructions</dfn>.
3. Name the Step as \`:original\`.
`)
}).strict();
var robotUploadHandleInstructionsWithHiddenFieldsSchema = robotUploadHandleInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotUploadHandleInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotUploadHandleInstructionsSchema = interpolateRobot(robotUploadHandleInstructionsSchema);
var interpolatableRobotUploadHandleInstructionsWithHiddenFieldsSchema = interpolateRobot(robotUploadHandleInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-adaptive.js
init_esm();
var meta71 = {
  allowed_for_url_transform: false,
  bytescount: Number.POSITIVE_INFINITY,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      ":original": {
        robot: "/upload/handle"
      },
      encoded_480p: {
        robot: "/video/encode",
        use: ":original",
        preset: "hls/480p",
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      },
      encoded_720p: {
        robot: "/video/encode",
        use: ":original",
        preset: "hls/720p",
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      },
      encoded_1080p: {
        robot: "/video/encode",
        use: ":original",
        preset: "hls/1080p",
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      },
      hls_bundled: {
        robot: "/video/adaptive",
        use: {
          steps: ["encoded_480p", "encoded_720p", "encoded_1080p"],
          bundle_steps: true
        },
        technique: "hls",
        playlist_name: "my_playlist.m3u8"
      }
    }
  },
  example_code_description: "Implementing HTTP Live Streaming: encode the uploaded video into three versions, then cut them into several segments and generate playlist files containing all the segments:",
  minimum_charge: 0,
  output_factor: 1.2,
  override_lvl1: "Video Encoding",
  purpose_sentence: "encodes videos into HTTP Live Streaming (HLS) and MPEG-Dash supported formats and generates the necessary manifest and playlist files",
  purpose_verb: "convert",
  purpose_word: "make adaptive",
  purpose_words: "Convert videos to HLS and MPEG-Dash",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Convert videos to HLS and MPEG-Dash",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  name: "VideoAdaptiveRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVideoAdaptiveInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegVideo).extend({
  robot: external_exports.literal("/video/adaptive").describe(`
This <dfn>Robot</dfn> accepts all types of video files and audio files. Do not forget to use <dfn>Step</dfn> bundling in your \`use\` parameter to make the <dfn>Robot</dfn> work on several input files at once.

This <dfn>Robot</dfn> is normally used in combination with [/video/encode](/docs/robots/video-encode/). We have implemented video and audio encoding presets specifically for MPEG-Dash and HTTP Live Streaming support. These presets are prefixed with \`"dash/"\` and \`"hls/"\`. [View a HTTP Live Streaming demo here](/demos/video-encoding/implement-http-live-streaming/).

### Required CORS settings for MPEG-Dash and HTTP Live Streaming

Playing back MPEG-Dash Manifest or HLS playlist files requires a proper CORS setup on the server-side. The file-serving server should be configured to add the following header fields to responses:

\`\`\`
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET
Access-Control-Allow-Headers: *
\`\`\`

If the files are stored in an Amazon S3 Bucket, you can use the following [CORS definition](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ManageCorsUsing.html) to ensure the CORS header fields are set correctly:

\`\`\`json
[
  {
    "AllowedHeaders": ["*"],
    "AllowedMethods": ["GET"],
    "AllowedOrigins": ["*"],
    "ExposeHeaders": []
  }
]
\`\`\`

To set up CORS for your S3 bucket:

1. Visit <https://s3.console.aws.amazon.com/s3/buckets/>
1. Click on your bucket
1. Click "Permissions"
1. Edit "Cross-origin resource sharing (CORS)"

### Storing Segments and Playlist files

The <dfn>Robot</dfn> gives its result files (segments, initialization segments, MPD manifest files and M3U8 playlist files) the right metadata property \`relative_path\`, so that you can store them easily using one of our storage <dfn>Robots</dfn>.

In the \`path\` parameter of the storage <dfn>Robot</dfn> of your choice, use the <dfn>Assembly Variable</dfn> \`\${file.meta.relative_path}\` to store files in the proper paths to make the playlist files work.
`),
  technique: external_exports.enum(["dash", "hls"]).default("dash").describe(`
Determines which streaming technique should be used. Currently supports \`"dash"\` for MPEG-Dash and \`"hls"\` for HTTP Live Streaming.
`),
  playlist_name: external_exports.string().optional().describe(`
The filename for the generated manifest/playlist file. The default is \`"playlist.mpd"\` if your \`technique\` is \`"dash"\`, and \`"playlist.m3u8"\` if your \`technique\` is \`"hls"\`.
`),
  segment_duration: external_exports.number().int().default(10).describe(`
The duration for each segment in seconds.
`),
  closed_captions: external_exports.boolean().default(true).describe(`
Determines whether you want closed caption support when using the \`"hls"\` technique.
`)
}).strict();
var robotVideoAdaptiveInstructionsWithHiddenFieldsSchema = robotVideoAdaptiveInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoAdaptiveInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotVideoAdaptiveInstructionsSchema = interpolateRobot(robotVideoAdaptiveInstructionsSchema);
var interpolatableRobotVideoAdaptiveInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoAdaptiveInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-concat.js
init_esm();
var meta72 = {
  allowed_for_url_transform: false,
  bytescount: 4,
  discount_factor: 0.25,
  discount_pct: 75,
  example_code: {
    steps: {
      concatenated: {
        robot: "/video/concat",
        use: {
          steps: [
            {
              name: ":original",
              fields: "first_video_file",
              as: "video_1"
            },
            {
              name: ":original",
              fields: "second_video_file",
              as: "video_2"
            },
            {
              name: ":original",
              fields: "third_video_file",
              as: "video_3"
            }
          ]
        }
      }
    }
  },
  example_code_description: "If you have a form with 3 file input fields and want to concatenate the uploaded videos in a specific order, instruct Transloadit using the `name` attribute of each input field. Use this attribute as the value for the `fields` key in the JSON, and set `as` to `video_[[index]]`. Transloadit will concatenate the files based on the ascending index order:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Video Encoding",
  purpose_sentence: "concatenates several videos together",
  purpose_verb: "concatenate",
  purpose_word: "concatenate",
  purpose_words: "Concatenate videos",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Concatenate videos",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  uses_tools: ["ffmpeg"],
  name: "VideoConcatRobot",
  priceFactor: 4,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVideoConcatInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegVideo).extend({
  robot: external_exports.literal("/video/concat").describe(`
> [!Note]
> Input videos may have differing dimensions and streams - the Robot can handle this fine. It will pre-transcode the input videos if necessary before concatenation at no additional cost.

Its possible to concatenate a virtually infinite number of video files using [/video/concat](/docs/robots/video-concat/).
`),
  video_fade_seconds: external_exports.number().default(1).describe(`
When used this adds a video fade in and out effect between each section of your concatenated video. The float value is used so if you want a video delay effect of 500 milliseconds between each video section you would select \`0.5\`, however, integer values can also be represented.

This parameter does not add a video fade effect at the beginning or end of your video. If you want to do so, create an additional [/video/encode](/docs/robots/video-encode/) Step and use our \`ffmpeg\` parameter as shown in this [demo](/demos/video-encoding/concatenate-fade-effect/).

Please note this parameter is independent of adding audio fades between sections.
`),
  audio_fade_seconds: external_exports.number().default(1).describe(`
When used this adds an audio fade in and out effect between each section of your concatenated video. The float value is used so if you want an audio delay effect of 500 milliseconds between each video section you would select \`0.5\`, however, integer values can also be represented.

This parameter does not add an audio fade effect at the beginning or end of your video. If you want to do so, create an additional [/video/encode](/docs/robots/video-encode/] Step and use our \`ffmpeg\` parameter as shown in this [demo](/demos/audio-encoding/ffmpeg-fade-in-and-out/).

Please note this parameter is independent of adding video fades between sections.
`)
}).strict();
var robotVideoConcatInstructionsWithHiddenFieldsSchema = robotVideoConcatInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoConcatInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotVideoConcatInstructionsSchema = interpolateRobot(robotVideoConcatInstructionsSchema);
var interpolatableRobotVideoConcatInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoConcatInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-encode.js
init_esm();
var meta73 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      hevc_encoded: {
        robot: "/video/encode",
        use: ":original",
        preset: "hevc"
      }
    }
  },
  example_code_description: "Transcode uploaded video to [HEVC](https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding) (H.265):",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Video Encoding",
  purpose_sentence: "encodes, resizes, applies watermarks to videos and animated GIFs",
  purpose_verb: "transcode",
  purpose_word: "transcode/resize/watermark",
  purpose_words: "Transcode, resize, or watermark videos",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Transcode, resize, or watermark videos",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  uses_tools: ["ffmpeg"],
  name: "VideoEncodeRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  stage: "ga",
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false
};
var robotVideoEncodeInstructionsSchema = robotBase.merge(robotUse).merge(videoEncodeSpecificInstructionsSchema).extend({
  robot: external_exports.literal("/video/encode").describe(`
The /video/encode Robot is a versatile tool for video processing that handles transcoding, resizing, and watermarking. It supports various formats including modern standards like HEVC (H.265), and provides features such as presets for common devices, custom FFmpeg parameters for powerusers, watermark positioning, and more.

## Adding text overlays with FFmpeg

You can add text overlays to videos using FFmpeg's \`drawtext\` filter through this <Definition term="Robot">Robot</Definition>'s \`ffmpeg\` parameter. Here are two examples  one with the default font and one with a custom font family name:

\`\`\`json
{
  "steps": {
    ":original": {
      "robot": "/upload/handle"
    },
    "text_overlay_default": {
      "use": ":original",
      "robot": "/video/encode",
      "preset": "empty",
      "ffmpeg_stack": "{{stacks.ffmpeg.recommended_version}}",
      "ffmpeg": {
        "codec:a": "copy",
        "vf": "drawtext=text='My text overlay':fontcolor=white:fontsize=24:box=1:boxcolor=black@0.5:boxborderw=5:x=(w-text_w)/2:y=(h-text_h)/2"
      },
      "result": true
    },
    "text_overlay_custom": {
      "use": ":original",
      "robot": "/video/encode",
      "preset": "empty",
      "ffmpeg_stack": "{{stacks.ffmpeg.recommended_version}}",
      "ffmpeg": {
        "codec:a": "copy",
        "vf": "drawtext=font='Times New Roman':text='My text overlay':fontcolor=white:fontsize=24:box=1:boxcolor=black@0.5:boxborderw=5:x=(w-text_w)/2:y=(h-text_h)/2"
      },
      "result": true
    }
  }
}
\`\`\`

**Notes:**

- Use the \`font\` attribute to reference a font by family name with FFmpeg's \`drawtext\`
- FFmpeg font family names typically do not contain dashes (e.g. \`Times New Roman\`), while
  ImageMagick uses dashed names (e.g. \`Times-New-Roman\`).
- Preserve the source audio by setting \`"codec:a": "copy"\`.
- Position text with the \`x\` and \`y\` expressions. The example above centers the text.

See the live demo [here](/demos/video-encoding/add-text-overlay/).
`),
  font_size: external_exports.number().optional(),
  font_color: external_exports.string().optional(),
  text_background_color: external_exports.string().optional()
}).strict();
var robotVideoEncodeInstructionsWithHiddenFieldsSchema = robotVideoEncodeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoEncodeInstructionsSchema.shape.result]).optional(),
  chunked_transcoding: external_exports.boolean().optional(),
  realtime: external_exports.boolean().optional()
});
var interpolatableRobotVideoEncodeInstructionsSchema = interpolateRobot(robotVideoEncodeInstructionsSchema);
var interpolatableRobotVideoEncodeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoEncodeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-merge.js
init_esm();
var meta74 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Video Encoding",
  purpose_sentence: "composes a new video by adding an audio track to existing still image(s) or video",
  purpose_verb: "merge",
  purpose_word: "merge",
  purpose_words: "Merge video, audio, images into one video",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Merge video, audio, images into one video",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  uses_tools: ["ffmpeg"],
  name: "VideoMergeRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVideoMergeInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegVideo).extend({
  robot: external_exports.literal("/video/merge"),
  resize_strategy: resize_strategy.describe(`
If the given width/height parameters are bigger than the input image's dimensions, then the \`resize_strategy\` determines how the image will be resized to match the provided width/height. See the [available resize strategies](/docs/topics/resize-strategies/).
`),
  background: color_with_alpha.default("#00000000").describe(`
The background color of the resulting video the \`"rrggbbaa"\` format (red, green, blue, alpha) when used with the \`"pad"\` resize strategy. The default color is black.
`),
  framerate: external_exports.union([external_exports.number().int().min(1), external_exports.string().regex(/^\d+(?:\/\d+)?$/)]).default("1/5").describe(`
When merging images to generate a video this is the input framerate. A value of "1/5" means each image is given 5 seconds before the next frame appears (the inverse of a framerate of "5"). Likewise for "1/10", "1/20", etc. A value of "5" means there are 5 frames per second.
`),
  image_durations: external_exports.array(external_exports.number()).default([]).describe(`
When merging images to generate a video this allows you to define how long (in seconds) each image will be shown inside of the video. So if you pass 3 images and define \`[2.4, 5.6, 9]\` the first image will be shown for 2.4s, the second image for 5.6s and the last one for 9s. The \`duration\` parameter will automatically be set to the sum of the image_durations, so \`17\` in our example. It can still be overwritten, though, in which case the last image will be shown until the defined duration is reached.
`),
  duration: external_exports.number().default(5).describe(`
When merging images to generate a video or when merging audio and video this is the desired target duration in seconds. The float value can take one decimal digit. If you want all images to be displayed exactly once, then you can set the duration according to this formula: \`duration = numberOfImages / framerate\`. This also works for the inverse framerate values like \`1/5\`.

If you set this value to \`null\` (default), then the duration of the input audio file will be used when merging images with an audio file.

When merging audio files and video files, the duration of the longest video or audio file is used by default.
`),
  audio_delay: external_exports.number().default(0).describe(`
When merging a video and an audio file, and when merging images and an audio file to generate a video, this is the desired delay in seconds for the audio file to start playing. Imagine you merge a video file without sound and an audio file, but you wish the audio to start playing after 5 seconds and not immediately, then this is the parameter to use.
`),
  loop: external_exports.boolean().default(false).describe(`
  Determines whether the shorter media file should be looped to match the duration of the longer one. For example, if you merge a 1-minute video with a 3-minute audio file and enable this option, the video will play three times in a row to match the audio length.`),
  replace_audio: external_exports.boolean().default(false).describe(`
Determines whether the audio of the video should be replaced with a provided audio file.
`),
  vstack: external_exports.boolean().default(false).describe(`
Stacks the input media vertically. All streams need to have the same pixel format and width - so consider using a [/video/encode](/docs/robots/video-encode/) <dfn>Step</dfn> before using this parameter to enforce this.
`),
  image_url: external_exports.string().url().optional().describe(`
The URL of an image to be merged with the audio or video. When this parameter is provided, the robot will download the image from the URL and merge it with the other media.
`)
}).strict();
var robotVideoMergeInstructionsWithHiddenFieldsSchema = robotVideoMergeInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoMergeInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotVideoMergeInstructionsSchema = interpolateRobot(robotVideoMergeInstructionsSchema);
var interpolatableRobotVideoMergeInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoMergeInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-ondemand.js
init_esm();
var meta75 = {
  allowed_for_url_transform: true,
  discount_factor: 1,
  discount_pct: 0,
  bytescount: 1,
  example_code: {
    steps: {
      import: {
        robot: "/s3/import",
        path: "${fields.input}",
        credentials: "YOUR_AWS_CREDENTIALS",
        return_file_stubs: true
      },
      vod: {
        robot: "/video/ondemand",
        use: "import",
        variants: {
          "480p": {
            preset: "hls/480p",
            ffmpeg_stack: "{{ stacks.ffmpeg.recommended_version }}"
          },
          "720p": {
            preset: "hls/720p",
            ffmpeg_stack: "{{ stacks.ffmpeg.recommended_version }}"
          },
          "1080p": {
            preset: "hls/1080p",
            ffmpeg_stack: "{{ stacks.ffmpeg.recommended_version }}"
          }
        }
      },
      serve: {
        use: "vod",
        robot: "/file/serve"
      }
    }
  },
  example_code_description: "Enable streaming of a video stored on S3 in three variants (480p, 720p, 1080p) with on-demand encoding:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Video Encoding",
  purpose_sentence: "generates HTTP Live Streaming (HLS) playlists and segments on-demand for adaptive and cost-efficient playback",
  purpose_verb: "stream",
  purpose_word: "stream",
  purpose_words: "Stream videos with on-demand encoding",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Stream videos with on-demand encoding",
  typical_file_size_mb: 300,
  typical_file_type: "video",
  name: "VideoOndemandRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  downloadInputFiles: false,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "beta"
};
var robotVideoOndemandInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/video/ondemand"),
  variants: external_exports.record(videoEncodeSpecificInstructionsSchema).describe("Defines the variants the video player can choose from. The keys are the names of the variant as they will appear in the generated playlists and URLs."),
  enabled_variants: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional().describe("Specifies which variants, defined in the variants parameter, are enabled. Non-enabled variants will not be included in the master playlist."),
  segment_duration: external_exports.number().optional().default(6).describe("The duration of each segment in seconds."),
  sign_urls_for: external_exports.number().optional().default(0).describe("When signing URLs is enabled, the URLs in the generated playlist files will be signed. This parameter specifies the duration (in seconds) that the signed URLs will remain valid."),
  asset: external_exports.string().optional().describe("Controls which file is generated. For example, if the parameter is unset, a master playlist referencing the variants is generated."),
  asset_param_name: external_exports.string().optional().default("asset").describe("Specifies from which URL parameter the asset parameter value is taken and which URL parameter to use when generating playlist files.")
}).strict();
var robotVideoOndemandInstructionsWithHiddenFieldsSchema = robotVideoOndemandInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoOndemandInstructionsSchema.shape.result]).optional(),
  cdn_required_bypass: external_exports.boolean().optional().default(false).describe("Internal parameter that indicates whether `cdn=required` should be added to the URLs in playlists. Useful for testing with URL Transform directly and not through Smart CDN."),
  url_transform_format: external_exports.boolean().optional().default(false).describe("Internal parameter that indicates whether the URLs in playlists should use the Smart CDN or the URL Transform format.")
});
var interpolatableRobotVideoOndemandInstructionsSchema = interpolateRobot(robotVideoOndemandInstructionsSchema);
var interpolatableRobotVideoOndemandInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoOndemandInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-subtitle.js
init_esm();
var meta76 = {
  allowed_for_url_transform: false,
  bytescount: 1,
  discount_factor: 1,
  discount_pct: 0,
  example_code: {
    steps: {
      subtitled: {
        robot: "/video/subtitle",
        use: {
          steps: [
            {
              name: ":original",
              fields: "input_video",
              as: "video"
            },
            {
              name: ":original",
              fields: "input_srt",
              as: "subtitles"
            }
          ]
        },
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "If you have two file input fields in a form  one for a video and another for an SRT or VTT subtitle, named `input_video` and `input_srt` respectively (with the HTML `name` attribute), heres how to embed the subtitles into the video with Transloadit:",
  minimum_charge: 0,
  output_factor: 0.6,
  override_lvl1: "Video Encoding",
  purpose_sentence: "adds subtitles and closed captions to videos",
  purpose_verb: "subtitle",
  purpose_word: "subtitle",
  purpose_words: "Add subtitles to videos",
  service_slug: "video-encoding",
  slot_count: 60,
  title: "Add subtitles to videos",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  uses_tools: ["ffmpeg"],
  name: "VideoSubtitleRobot",
  priceFactor: 1,
  queueSlotCount: 60,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVideoSubtitleInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpegVideo).extend({
  robot: external_exports.literal("/video/subtitle").describe(`
This <dfn>Robot</dfn> supports both SRT and VTT subtitle files.
`),
  subtitles_type: external_exports.enum(["burned", "external", "burn"]).transform((val) => val === "burn" ? "burned" : val).default("external").describe(`
Determines if subtitles are added as a separate stream to the video (value \`"external"\`) that then can be switched on and off in your video player, or if they should be burned directly into the video (value \`"burned"\` or \`"burn"\`) so that they become part of the video stream.
`),
  border_style: external_exports.enum(["box", "outline", "shadow"]).default("outline").describe(`
Specifies the style of the subtitle. Use the \`border_color\` parameter to specify the color of the border.
`),
  border_color: color_with_alpha.default("40000000").describe(`
The color for the subtitle border. The first two hex digits specify the alpha value of the color.
`),
  // TODO: Make font an enum
  font: external_exports.string().default("Arial").describe(`
The font family to use. Also includes boldness and style of the font.

[Here](/docs/supported-formats/fonts/) is a list of all supported fonts.
`),
  font_color: color_without_alpha.default("FFFFFF").describe(`
The color of the subtitle text. The first two hex digits specify the alpha value of the color.
`),
  font_size: external_exports.number().int().min(1).default(16).describe(`
Specifies the size of the text.
`),
  position: positionSchema.default("bottom").describe(`
Specifies the position of the subtitles.
`),
  language: external_exports.string().optional().nullable().describe(`
Specifies the language of the subtitles. Only used if the subtitles are external.
`),
  keep_subtitles: external_exports.boolean().default(false).describe(`
Specifies if existing subtitles in the input file should be kept or be replaced by the new subtitle. Only used if the subtitles are external.
`)
}).strict();
var robotVideoSubtitleInstructionsWithHiddenFieldsSchema = robotVideoSubtitleInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoSubtitleInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotVideoSubtitleInstructionsSchema = interpolateRobot(robotVideoSubtitleInstructionsSchema);
var interpolatableRobotVideoSubtitleInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoSubtitleInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/video-thumbs.js
init_esm();
var meta77 = {
  allowed_for_url_transform: false,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      thumbnailed: {
        robot: "/video/thumbs",
        use: ":original",
        count: 10,
        ffmpeg_stack: stackVersions.ffmpeg.recommendedVersion
      }
    }
  },
  example_code_description: "Extract 10 thumbnails from each uploaded video:",
  minimum_charge: 0,
  output_factor: 0.05,
  override_lvl1: "Video Encoding",
  purpose_sentence: "extracts any number of images from videos for use as previews",
  purpose_verb: "extract",
  purpose_word: "thumbnail",
  purpose_words: "Extract thumbnails from videos",
  service_slug: "video-encoding",
  slot_count: 15,
  title: "Extract thumbnails from videos",
  typical_file_size_mb: 80,
  typical_file_type: "video",
  uses_tools: ["ffmpeg"],
  name: "VideoThumbsRobot",
  priceFactor: 10,
  queueSlotCount: 15,
  isAllowedForUrlTransform: false,
  trackOutputFileSize: true,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVideoThumbsInstructionsSchema = robotBase.merge(robotUse).merge(robotFFmpeg).extend({
  robot: external_exports.literal("/video/thumbs").describe(`
> [!Note]
> Even though thumbnails are extracted from videos in parallel, we sort the thumbnails before adding them to the Assembly results. So the order in which they appear there reflects the order in which they appear in the video. You can also make sure by checking the <code>thumb_index</code> meta key.
`),
  count: external_exports.number().int().min(1).max(999).default(8).describe(`
The number of thumbnails to be extracted. As some videos have incorrect durations, the actual number of thumbnails generated may be less in rare cases. The maximum number of thumbnails we currently allow is 999.

The thumbnails are taken at regular intervals, determined by dividing the video duration by the count. For example, a count of 3 will produce thumbnails at 25%, 50% and 75% through the video.

To extract thumbnails for specific timestamps, use the \`offsets\` parameter.
`),
  offsets: external_exports.union([external_exports.array(external_exports.number()), external_exports.array(percentageSchema)]).default([]).describe(`
An array of offsets representing seconds of the file duration, such as \`[ 2, 45, 120 ]\`. Millisecond durations of a file can also be used by using decimal place values. For example, an offset from 1250 milliseconds would be represented with \`1.25\`. Offsets can also be percentage values such as \`[ "2%", "50%", "75%" ]\`.

This option cannot be used with the \`count\` parameter, and takes precedence if both are specified. Out-of-range offsets are silently ignored.
`),
  format: external_exports.enum(["jpeg", "jpg", "png"]).default("jpeg").describe(`
The format of the extracted thumbnail. Supported values are \`"jpg"\`, \`"jpeg"\` and \`"png"\`. Even if you specify the format to be \`"jpeg"\` the resulting thumbnails will have a \`"jpg"\` file extension.
`),
  width: external_exports.number().int().min(1).max(1920).optional().describe(`
The width of the thumbnail, in pixels. Defaults to the original width of the video.
`),
  height: external_exports.number().int().min(1).max(1080).optional().describe(`
The height of the thumbnail, in pixels. Defaults to the original height of the video.
`),
  resize_strategy: resize_strategy.describe(`
One of the [available resize strategies](/docs/topics/resize-strategies/).
`),
  background: color_with_alpha.default("#00000000").describe(`
The background color of the resulting thumbnails in the \`"rrggbbaa"\` format (red, green, blue, alpha) when used with the \`"pad"\` resize strategy. The default color is black.
`),
  rotate: external_exports.union([external_exports.literal(0), external_exports.literal(90), external_exports.literal(180), external_exports.literal(270), external_exports.literal(360)]).default(0).describe(`
Forces the video to be rotated by the specified degree integer. Currently, only multiples of 90 are supported. We automatically correct the orientation of many videos when the orientation is provided by the camera. This option is only useful for videos requiring rotation because it was not detected by the camera.
`),
  input_codec: external_exports.string().optional().describe(`
Specifies the input codec to use when decoding the video. This is useful for videos with special codecs that require specific decoders.
`)
}).strict();
var robotVideoThumbsInstructionsWithHiddenFieldsSchema = robotVideoThumbsInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVideoThumbsInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotVideoThumbsInstructionsSchema = interpolateRobot(robotVideoThumbsInstructionsSchema);
var interpolatableRobotVideoThumbsInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVideoThumbsInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/vimeo-import.js
init_esm();
var meta78 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/vimeo/import",
        credentials: "YOUR_VIMEO_CREDENTIALS",
        path: "me/videos",
        rendition: "720p",
        page_number: 1,
        files_per_page: 20
      }
    }
  },
  example_code_description: "Import videos from your Vimeo account:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports videos from your Vimeo account",
  purpose_verb: "import",
  purpose_word: "Vimeo",
  purpose_words: "Import videos from Vimeo",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import videos from Vimeo",
  typical_file_size_mb: 50,
  typical_file_type: "video",
  name: "VimeoImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotVimeoImportInstructionsSchema = robotBase.merge(robotImport).merge(vimeoBase).extend({
  robot: external_exports.literal("/vimeo/import"),
  path: path.default("me/videos").describe(`
The Vimeo API path to import from. The most common paths are:
- \`me/videos\`: Your own videos
- \`me/likes\`: Videos you've liked
- \`me/albums/:album_id/videos\`: Videos from a specific album
- \`me/channels/:channel_id/videos\`: Videos from a specific channel
- \`me/groups/:group_id/videos\`: Videos from a specific group
- \`me/portfolios/:portfolio_id/videos\`: Videos from a specific portfolio
- \`me/watchlater\`: Videos in your watch later queue

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  page_number: external_exports.number().int().positive().default(1).describe("The page number to import from. Vimeo API uses pagination for large result sets."),
  files_per_page: external_exports.number().int().positive().max(100).default(20).describe("The number of files to import per page. Maximum is 100 as per Vimeo API limits."),
  rendition: external_exports.enum(["240p", "360p", "540p", "720p", "1080p", "source"]).default("720p").describe("The quality of the video to import.")
}).strict();
var interpolatableRobotVimeoImportInstructionsSchema = interpolateRobot(robotVimeoImportInstructionsSchema);
var robotVimeoImportInstructionsWithHiddenFieldsSchema = robotVimeoImportInstructionsSchema.extend({
  access_token: external_exports.string().optional().describe("Legacy authentication field. Use credentials instead."),
  return_file_stubs: external_exports.boolean().optional().describe("When true, returns file stubs instead of downloading the actual files. Used for testing.")
});
var interpolatableRobotVimeoImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVimeoImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/vimeo-store.js
init_esm();
var meta79 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/vimeo/store",
        use: ":original",
        credentials: "YOUR_VIMEO_CREDENTIALS",
        title: "Transloadit: Video Example",
        description: "Some nice description"
      }
    }
  },
  example_code_description: "Export an uploaded video to Vimeo and set its title and description:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to vimeo",
  purpose_verb: "export",
  purpose_word: "Vimeo",
  purpose_words: "Export files to Vimeo",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Vimeo",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "VimeoStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotVimeoStoreInstructionsSchema = robotBase.merge(robotUse).merge(vimeoBase).extend({
  robot: external_exports.literal("/vimeo/store"),
  title: external_exports.string().describe(`
The title of the video to be displayed on Vimeo.
`),
  description: external_exports.string().describe(`
The description of the video to be displayed on Vimeo.
`),
  acl: external_exports.enum(["anybody", "contacts", "disable", "nobody", "password", "unlisted", "users"]).default("anybody").describe(`
Controls access permissions for the video. Here are the valid values:

- \`"anybody"\`  anyone can access the video.
- \`"contacts"\`  only those who follow the owner on Vimeo can access the video.
- \`"disable"\`  the video is embeddable, but it's hidden on Vimeo and can't be played.
- \`"nobody"\`  no one except the owner can access the video.
- \`"password"\`  only those with the password can access the video.
- \`"unlisted"\`  only those with the private link can access the video.
- \`"users"\`  only Vimeo members can access the video.
`),
  password: external_exports.string().optional().describe(`
The password to access the video if \`acl\` is \`"password"\`.
`),
  showcases: external_exports.array(external_exports.string()).default([]).describe(`
An array of string IDs of showcases that you want to add the video to. The IDs can be found when browsing Vimeo. For example \`https://vimeo.com/manage/showcases/[SHOWCASE_ID]/info\`.
`),
  downloadable: external_exports.boolean().default(false).describe(`
Whether or not the video can be downloaded from the Vimeo website.

Only set this to \`true\` if you have unlocked this feature in your Vimeo accounting by upgrading to their "Pro" plan. If you use it while on their Freemium plan, the Vimeo API will return an \`"Invalid parameter supplied"\` error.
`),
  folder_id: external_exports.string().nullable().default(null).describe(`
The ID of the folder to which the video is uploaded.

When visiting one of your folders, the URL is similar to \`https://vimeo.com/manage/folders/xxxxxxxx\`. The folder_id would be \`"xxxxxxxx"\`.
`),
  folder_uri: external_exports.string().optional().describe(`
Deprecated. Please use \`folder_id\` instead. The URI of the folder to which the video is uploaded.
`)
}).strict();
var robotVimeoStoreInstructionsWithHiddenFieldsSchema = robotVimeoStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotVimeoStoreInstructionsSchema.shape.result]).optional(),
  access_token: external_exports.string().optional().describe("Legacy authentication field. Use credentials instead.")
});
var interpolatableRobotVimeoStoreInstructionsSchema = interpolateRobot(robotVimeoStoreInstructionsSchema);
var interpolatableRobotVimeoStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotVimeoStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/wasabi-import.js
init_esm();
var meta80 = {
  allowed_for_url_transform: true,
  bytescount: 10,
  discount_factor: 0.1,
  discount_pct: 90,
  example_code: {
    steps: {
      imported: {
        robot: "/wasabi/import",
        credentials: "YOUR_WASABI_CREDENTIALS",
        path: "path/to/files/",
        recursive: true
      }
    }
  },
  example_code_description: "Import files from the `path/to/files` directory and its subdirectories:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Importing",
  purpose_sentence: "imports whole directories of files from your wasabi bucket",
  purpose_verb: "import",
  purpose_word: "Wasabi",
  purpose_words: "Import files from Wasabi",
  requires_credentials: true,
  service_slug: "file-importing",
  slot_count: 20,
  title: "Import files from Wasabi",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "WasabiImportRobot",
  priceFactor: 6.6666,
  queueSlotCount: 20,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: true,
  stage: "ga"
};
var robotWasabiImportInstructionsSchema = robotBase.merge(robotImport).merge(wasabiBase).extend({
  result: external_exports.boolean().optional().describe("Whether the results of this Step should be present in the Assembly Status JSON"),
  robot: external_exports.literal("/wasabi/import"),
  path: path.describe(`
The path in your bucket to the specific file or directory. If the path points to a file, only this file will be imported. For example: \`images/avatar.jpg\`.

If it points to a directory, indicated by a trailing slash (\`/\`), then all files that are direct descendants of this directory will be imported. For example: \`images/\`.

Directories are **not** imported recursively. If you want to import files from subdirectories and sub-subdirectories, enable the \`recursive\` parameter.

If you want to import all files from the root directory, please use \`/\` as the value here. In this case, make sure all your objects belong to a path. If you have objects in the root of your bucket that aren't prefixed with \`/\`, you'll receive an error: \`A client error (NoSuchKey) occurred when calling the GetObject operation: The specified key does not exist.\`

You can also use an array of path strings here to import multiple paths in the same <dfn>Robot</dfn>'s <dfn>Step</dfn>.
`),
  recursive: recursive.describe(`
Setting this to \`true\` will enable importing files from subfolders and sub-subfolders, etc. of the given path.

Please use the pagination parameters \`page_number\` and \`files_per_page\` wisely here.
`),
  page_number: page_number.describe(`
The pagination page number. For now, in order to not break backwards compatibility in non-recursive imports, this only works when recursive is set to \`true\`.

When doing big imports, make sure no files are added or removed from other scripts within your path, otherwise you might get weird results with the pagination.
`),
  files_per_page: files_per_page.describe(`
The pagination page size. This only works when recursive is \`true\` for now, in order to not break backwards compatibility in non-recursive imports.
`),
  return_file_stubs
}).strict();
var robotWasabiImportInstructionsWithHiddenFieldsSchema = robotWasabiImportInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotWasabiImportInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotWasabiImportInstructionsSchema = interpolateRobot(robotWasabiImportInstructionsSchema);
var interpolatableRobotWasabiImportInstructionsWithHiddenFieldsSchema = interpolateRobot(robotWasabiImportInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/wasabi-store.js
init_esm();
var meta81 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/wasabi/store",
        use: ":original",
        credentials: "YOUR_WASABI_CREDENTIALS",
        path: "my_target_folder/${unique_prefix}/${file.url_name}"
      }
    }
  },
  example_code_description: "Export uploaded files to `my_target_folder` on Wasabi:",
  has_small_icon: true,
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to Wasabi buckets",
  purpose_verb: "export",
  purpose_word: "Wasabi",
  purpose_words: "Export files to Wasabi",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to Wasabi",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "WasabiStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotWasabiStoreInstructionsSchema = robotBase.merge(robotUse).merge(wasabiBase).extend({
  robot: external_exports.literal("/wasabi/store").describe(`
The URL to the result file will be returned in the <dfn>Assembly Status JSON</dfn>.
`),
  path: external_exports.string().default("${unique_prefix}/${file.url_name}").describe(`
The path at which the file is to be stored. This may include any available [Assembly variables](/docs/topics/assembly-instructions/#assembly-variables). The path must not be a directory.
`),
  acl: external_exports.enum(["private", "public-read"]).default("public-read").describe(`
The permissions used for this file.
`),
  headers: external_exports.record(external_exports.string()).default({ "Content-Type": "${file.mime}" }).describe(`
An object containing a list of headers to be set for this file on Wasabi Spaces, such as \`{ FileURL: "\${file.url_name}" }\`. This can also include any available [Assembly Variables](/docs/topics/assembly-instructions/#assembly-variables).

Object Metadata can be specified using \`x-amz-meta-*\` headers. Note that these headers [do not support non-ASCII metadata values](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata).
`),
  sign_urls_for: external_exports.number().int().min(0).optional().describe(`
This parameter provides signed URLs in the result JSON (in the \`signed_ssl_url\` property). The number that you set this parameter to is the URL expiry time in seconds. If this parameter is not used, no URL signing is done.
`)
}).strict();
var robotWasabiStoreInstructionsWithHiddenFieldsSchema = robotWasabiStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotWasabiStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotWasabiStoreInstructionsSchema = interpolateRobot(robotWasabiStoreInstructionsSchema);
var interpolatableRobotWasabiStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotWasabiStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/youtube-store.js
init_esm();
var meta82 = {
  allowed_for_url_transform: true,
  bytescount: 6,
  discount_factor: 0.15000150001500018,
  discount_pct: 84.99984999849998,
  example_code: {
    steps: {
      exported: {
        robot: "/youtube/store",
        use: ":original",
        credentials: "YOUR_YOUTUBE_CREDENTIALS",
        title: "Transloadit: Video Example",
        description: "Some nice description",
        category: "science & technology",
        keywords: "transloadit, robots, botty",
        visibility: "private"
      }
    }
  },
  example_code_description: "Export an uploaded video to YouTube and set some basic parameters:",
  minimum_charge: 0,
  output_factor: 1,
  override_lvl1: "File Exporting",
  purpose_sentence: "exports encoding results to YouTube",
  purpose_verb: "export",
  purpose_word: "YouTube",
  purpose_words: "Export files to YouTube",
  service_slug: "file-exporting",
  slot_count: 10,
  title: "Export files to YouTube",
  typical_file_size_mb: 1.2,
  typical_file_type: "file",
  name: "YoutubeStoreRobot",
  priceFactor: 6.6666,
  queueSlotCount: 10,
  isAllowedForUrlTransform: true,
  trackOutputFileSize: false,
  isInternal: false,
  removeJobResultFilesFromDiskRightAfterStoringOnS3: false,
  stage: "ga"
};
var robotYoutubeStoreInstructionsSchema = robotBase.merge(robotUse).extend({
  robot: external_exports.literal("/youtube/store").describe(`
> [!Note]
> This <dfn>Robot</dfn> only accepts videos.

## Installation

Since YouTube works with OAuth, you will need to generate [Template Credentials](/c/template-credentials/) to use this <dfn>Robot</dfn>.

To change the \`title\`, \`description\`, \`category\`, or \`keywords\` per video, we recommend to [inject variables into your Template](/docs/topics/templates/).

## Adding a thumbnail image to your video

You can add a custom thumbnail to your video on YouTube by using our \`"as"\` syntax for the \`"use"\` parameter to supply both a video and an image to the step:

\`\`\`json
"exported": {
  "use": [
    { "name": "video_encode_step", "as": "video" },
    { "name": "image_resize_step", "as": "image" },
  ],
  ...
},
\`\`\`

If you encounter an error such as "The authenticated user doesnt have permissions to upload and set custom video thumbnails", you should go to your YouTube account and try adding a custom thumbnail to one of your existing videos. Youll be prompted to add your phone number. Once youve added it, the error should go away.
`),
  credentials: external_exports.string().describe(`
The authentication Template credentials used for your YouTube account. You can generate them on the [Template Credentials page](/c/template-credentials/). Simply add the name of your YouTube channel, and you will be redirected to a Google verification page. Accept the presented permissions and you will be good to go.
`),
  title: external_exports.string().max(80).describe(`
The title of the video to be displayed on YouTube.

Note that since the YouTube API requires titles to be within 80 characters, longer titles may be truncated.
`),
  description: external_exports.string().describe(`
The description of the video to be displayed on YouTube. This can be up to 5000 characters, including \`\\n\` for new-lines.
`),
  category: external_exports.preprocess((val) => typeof val === "string" ? val.toLowerCase() : val, external_exports.enum([
    "autos & vehicles",
    "comedy",
    "education",
    "entertainment",
    "film & animation",
    "gaming",
    "howto & style",
    "music",
    "news & politics",
    "people & blogs",
    "pets & animals",
    "science & technology",
    "sports",
    "travel & events"
  ])).describe(`
The category to which this video will be assigned.
`),
  keywords: external_exports.string().describe(`
Tags used to describe the video, separated by commas. These tags will also be displayed on YouTube.
`),
  visibility: external_exports.enum(["public", "private", "unlisted"]).describe(`
Defines the visibility of the uploaded video.
`)
}).strict();
var robotYoutubeStoreInstructionsWithHiddenFieldsSchema = robotYoutubeStoreInstructionsSchema.extend({
  result: external_exports.union([external_exports.literal("debug"), robotYoutubeStoreInstructionsSchema.shape.result]).optional()
});
var interpolatableRobotYoutubeStoreInstructionsSchema = interpolateRobot(robotYoutubeStoreInstructionsSchema);
var interpolatableRobotYoutubeStoreInstructionsWithHiddenFieldsSchema = interpolateRobot(robotYoutubeStoreInstructionsWithHiddenFieldsSchema);

// node_modules/transloadit/dist/alphalib/types/robots/_index.js
var robotStepsInstructions = [
  interpolatableRobotAudioArtworkInstructionsSchema,
  interpolatableRobotAudioConcatInstructionsSchema,
  interpolatableRobotAudioEncodeInstructionsSchema,
  interpolatableRobotAudioLoopInstructionsSchema,
  interpolatableRobotAudioMergeInstructionsSchema,
  interpolatableRobotAudioWaveformInstructionsSchema,
  interpolatableRobotAzureImportInstructionsSchema,
  interpolatableRobotAzureStoreInstructionsSchema,
  interpolatableRobotBackblazeImportInstructionsSchema,
  interpolatableRobotBackblazeStoreInstructionsSchema,
  interpolatableRobotCloudfilesImportInstructionsSchema,
  interpolatableRobotCloudfilesStoreInstructionsSchema,
  interpolatableRobotCloudflareImportInstructionsSchema,
  interpolatableRobotCloudflareStoreInstructionsSchema,
  interpolatableRobotDigitaloceanImportInstructionsSchema,
  interpolatableRobotDigitaloceanStoreInstructionsSchema,
  interpolatableRobotDocumentAutorotateInstructionsSchema,
  interpolatableRobotDocumentConvertInstructionsSchema,
  interpolatableRobotDocumentMergeInstructionsSchema,
  interpolatableRobotDocumentOcrInstructionsSchema,
  interpolatableRobotDocumentOptimizeInstructionsSchema,
  interpolatableRobotFileReadInstructionsSchema,
  interpolatableRobotDocumentSplitInstructionsSchema,
  interpolatableRobotDocumentThumbsInstructionsSchema,
  interpolatableRobotDropboxImportInstructionsSchema,
  interpolatableRobotDropboxStoreInstructionsSchema,
  interpolatableRobotEdglyDeliverInstructionsSchema,
  interpolatableRobotFileCompressInstructionsSchema,
  interpolatableRobotFileDecompressInstructionsSchema,
  interpolatableRobotFileFilterInstructionsSchema,
  interpolatableRobotFileHashInstructionsSchema,
  interpolatableRobotFilePreviewInstructionsSchema,
  interpolatableRobotFileServeInstructionsSchema,
  interpolatableRobotFileVerifyInstructionsSchema,
  interpolatableRobotFileVirusscanInstructionsSchema,
  interpolatableRobotFtpImportInstructionsSchema,
  interpolatableRobotFtpStoreInstructionsSchema,
  interpolatableRobotGoogleImportInstructionsSchema,
  interpolatableRobotGoogleStoreInstructionsSchema,
  interpolatableRobotHtmlConvertInstructionsSchema,
  interpolatableRobotHttpImportInstructionsSchema,
  interpolatableRobotImageBgremoveInstructionsSchema,
  interpolatableRobotImageDescribeInstructionsSchema,
  interpolatableRobotImageFacedetectInstructionsSchema,
  interpolatableRobotImageGenerateInstructionsSchema,
  interpolatableRobotImageMergeInstructionsSchema,
  interpolatableRobotImageOcrInstructionsSchema,
  interpolatableRobotImageOptimizeInstructionsSchema,
  interpolatableRobotImageResizeInstructionsSchema,
  interpolatableRobotMetaWriteInstructionsSchema,
  interpolatableRobotMinioImportInstructionsSchema,
  interpolatableRobotMinioStoreInstructionsSchema,
  interpolatableRobotS3ImportInstructionsSchema,
  interpolatableRobotS3StoreInstructionsSchema,
  interpolatableRobotScriptRunInstructionsSchema,
  interpolatableRobotSftpImportInstructionsSchema,
  interpolatableRobotSftpStoreInstructionsSchema,
  interpolatableRobotSpeechTranscribeInstructionsSchema,
  interpolatableRobotSupabaseImportInstructionsSchema,
  interpolatableRobotSupabaseStoreInstructionsSchema,
  interpolatableRobotSwiftImportInstructionsSchema,
  interpolatableRobotSwiftStoreInstructionsSchema,
  interpolatableRobotTextSpeakInstructionsSchema,
  interpolatableRobotTextTranslateInstructionsSchema,
  interpolatableRobotAiChatInstructionsSchema,
  interpolatableRobotTigrisImportInstructionsSchema,
  interpolatableRobotTigrisStoreInstructionsSchema,
  interpolatableRobotTlcdnDeliverInstructionsSchema,
  interpolatableRobotTusStoreInstructionsSchema,
  interpolatableRobotUploadHandleInstructionsSchema,
  interpolatableRobotVideoAdaptiveInstructionsSchema,
  interpolatableRobotVideoConcatInstructionsSchema,
  interpolatableRobotVideoEncodeInstructionsSchema,
  interpolatableRobotVideoMergeInstructionsSchema,
  interpolatableRobotVideoOndemandInstructionsSchema,
  interpolatableRobotVideoSubtitleInstructionsSchema,
  interpolatableRobotVideoThumbsInstructionsSchema,
  interpolatableRobotVimeoImportInstructionsSchema,
  interpolatableRobotVimeoStoreInstructionsSchema,
  interpolatableRobotWasabiImportInstructionsSchema,
  interpolatableRobotWasabiStoreInstructionsSchema,
  interpolatableRobotYoutubeStoreInstructionsSchema
];
var robotStepsInstructionsWithHiddenFields = [
  interpolatableRobotAudioArtworkInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAudioConcatInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAudioEncodeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAudioLoopInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAudioMergeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAudioWaveformInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAzureImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAzureStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotBackblazeImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotBackblazeStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotCloudfilesImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotCloudfilesStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotCloudflareImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotCloudflareStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDigitaloceanImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDigitaloceanStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentAutorotateInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentConvertInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentMergeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentOcrInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentOptimizeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileReadInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentSplitInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDocumentThumbsInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDropboxImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotDropboxStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotEdglyDeliverInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileCompressInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileDecompressInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileFilterInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileHashInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFilePreviewInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileServeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileVerifyInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileVirusscanInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFileWatermarkInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFtpImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotFtpStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotGoogleImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotGoogleStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotHtmlConvertInstructionsWithHiddenFieldsSchema,
  interpolatableRobotHttpImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageBgremoveInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageDescribeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageFacedetectInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageGenerateInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageMergeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageOcrInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageOptimizeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotImageResizeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotMetaWriteInstructionsWithHiddenFieldsSchema,
  interpolatableRobotMinioImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotMinioStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotS3ImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotS3StoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotScriptRunInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSftpImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSftpStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSpeechTranscribeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSupabaseImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSupabaseStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSwiftImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotSwiftStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTextSpeakInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTextTranslateInstructionsWithHiddenFieldsSchema,
  interpolatableRobotAiChatInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTigrisImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTigrisStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTlcdnDeliverInstructionsWithHiddenFieldsSchema,
  interpolatableRobotTusStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotUploadHandleInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoAdaptiveInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoConcatInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoEncodeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoMergeInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoOndemandInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoSubtitleInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVideoThumbsInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVimeoImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotVimeoStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotWasabiImportInstructionsWithHiddenFieldsSchema,
  interpolatableRobotWasabiStoreInstructionsWithHiddenFieldsSchema,
  interpolatableRobotYoutubeStoreInstructionsWithHiddenFieldsSchema
];
var robotsSchema = external_exports.discriminatedUnion("robot", [...robotStepsInstructions]);
var robotsWithHiddenFieldsSchema = external_exports.discriminatedUnion("robot", [
  ...robotStepsInstructionsWithHiddenFields
]);
var robotsWithHiddenBotsSchema = external_exports.discriminatedUnion("robot", [
  ...robotStepsInstructions,
  interpolatableRobotFileWatermarkInstructionsSchema,
  interpolatableRobotMetaReadInstructionsSchema,
  interpolatableRobotProgressSimulateInstructionsSchema
]);
var robotsWithHiddenBotsAndFieldsSchema = external_exports.discriminatedUnion("robot", [
  ...robotStepsInstructionsWithHiddenFields,
  interpolatableRobotMetaReadInstructionsWithHiddenFieldsSchema,
  interpolatableRobotProgressSimulateInstructionsSchema
]);
var robotsMeta = {
  aiChatMeta: meta,
  audioArtworkMeta: meta2,
  audioConcatMeta: meta3,
  audioEncodeMeta: meta4,
  audioLoopMeta: meta5,
  audioMergeMeta: meta6,
  audioWaveformMeta: meta7,
  azureImportMeta: meta8,
  azureStoreMeta: meta9,
  backblazeImportMeta: meta10,
  backblazeStoreMeta: meta11,
  cloudfilesImportMeta: meta12,
  cloudfilesStoreMeta: meta13,
  cloudflareImportMeta: meta14,
  cloudflareStoreMeta: meta15,
  digitaloceanImportMeta: meta16,
  digitaloceanStoreMeta: meta17,
  documentAutorotateMeta: meta18,
  documentConvertMeta: meta19,
  documentMergeMeta: meta20,
  documentOcrMeta: meta21,
  documentOptimizeMeta: meta22,
  documentSplitMeta: meta23,
  documentThumbsMeta: meta24,
  dropboxImportMeta: meta25,
  dropboxStoreMeta: meta26,
  edglyDeliverMeta: meta27,
  fileCompressMeta: meta28,
  fileDecompressMeta: meta29,
  fileFilterMeta: meta30,
  fileHashMeta: meta31,
  filePreviewMeta: meta32,
  fileReadMeta: meta33,
  fileServeMeta: meta34,
  fileVerifyMeta: meta35,
  fileVirusscanMeta: meta36,
  ftpImportMeta: meta37,
  ftpStoreMeta: meta38,
  googleImportMeta: meta39,
  googleStoreMeta: meta40,
  htmlConvertMeta: meta41,
  httpImportMeta: meta42,
  imageDescribeMeta: meta44,
  imageFacedetectMeta: meta45,
  imageBgremoveMeta: meta43,
  imageGenerateMeta: meta46,
  imageMergeMeta: meta47,
  imageOcrMeta: meta48,
  imageOptimizeMeta: meta49,
  imageResizeMeta: meta50,
  metaWriteMeta: meta51,
  minioImportMeta: meta52,
  minioStoreMeta: meta53,
  s3ImportMeta: meta54,
  s3StoreMeta: meta55,
  scriptRunMeta: meta56,
  sftpImportMeta: meta57,
  sftpStoreMeta: meta58,
  speechTranscribeMeta: meta59,
  supabaseImportMeta: meta60,
  supabaseStoreMeta: meta61,
  swiftImportMeta: meta62,
  swiftStoreMeta: meta63,
  textSpeakMeta: meta64,
  textTranslateMeta: meta65,
  tigrisImport: meta66,
  tigrisStore: meta67,
  tlcdnDeliverMeta: meta68,
  tusStoreMeta: meta69,
  uploadHandleMeta: meta70,
  videoAdaptiveMeta: meta71,
  videoConcatMeta: meta72,
  videoEncodeMeta: meta73,
  videoMergeMeta: meta74,
  videoOndemandMeta: meta75,
  videoSubtitleMeta: meta76,
  videoThumbsMeta: meta77,
  vimeoImportMeta: meta78,
  vimeoStoreMeta: meta79,
  wasabiImportMeta: meta80,
  wasabiStoreMeta: meta81,
  youtubeStoreMeta: meta82
};

// node_modules/transloadit/dist/alphalib/types/template.js
init_esm();
var stepSchema = external_exports.object({
  // This is a hack to get nicer robot hover messages in editors.
  robot: external_exports.string().describe("Identifier of the [robot](https://transloadit.com/docs/robots/) to execute")
}).and(robotsSchema);
var stepsSchema = external_exports.record(stepSchema).describe("Contains Assembly Instructions.");
var optionalStepsSchema = stepsSchema.optional();
var stepSchemaWithHiddenFields = external_exports.object({
  // This is a hack to get nicer robot hover messages in editors.
  robot: external_exports.string().describe("Identifier of the [robot](https://transloadit.com/docs/robots/) to execute")
}).and(robotsWithHiddenBotsAndFieldsSchema);
var stepsSchemaWithHiddenFields = external_exports.record(stepSchemaWithHiddenFields).describe("Contains Assembly Instructions.");
var optionalStepsWithHiddenFieldsSchema = stepsSchemaWithHiddenFields.optional();
var fieldsSchema = external_exports.record(external_exports.any()).optional().describe("An object of string keyed values (name -> value) that can be used as Assembly Variables, just like additional form fields can. You can use anything that is JSON stringifyable as a value");
var notifyUrlSchema = external_exports.string().optional().nullable().describe("Transloadit can send a Pingback to your server when the Assembly is completed. Well send the Assembly status in a form url-encoded JSON string inside of a transloadit field in a multipart POST request to the URL supplied here.");
var templateIdSchema = external_exports.string().optional().describe("The ID of the Template that contains your Assembly Instructions. If you set `allow_steps_override` to `false` in your Template, then `steps` and `template_id` will be mutually exclusive  you may supply only one of these parameters.");
var assemblyAuthInstructionsSchema = external_exports.object({
  key: external_exports.string().describe("Transloadit API key used to authenticate requests"),
  secret: external_exports.string().optional().describe("Transloadit API secret used to sign requests"),
  expires: external_exports.string().optional().describe("ISO 8601 expiration timestamp for signature authentication"),
  max_size: external_exports.number().optional().describe("Maximum allowed upload size in bytes"),
  nonce: external_exports.string().optional().describe("Unique, random nonce for this request"),
  referer: external_exports.string().optional().describe("Regular expression matched against the HTTP Referer to restrict upload origin")
}).describe(`Contains at least your Transloadit Auth Key in the \`key\` property.

If you enable Signature Authentication, you must also set an expiry date for the request in the expires property:

\`\`\`jsonc
{
  "key": "23c96d084c744219a2ce156772ec3211",
  "expires": "2009-08-28T01:02:03.000Z"
}
\`\`\`

We strongly recommend including the \`nonce\` property  a randomly generated, unique value per request that prevents duplicate processing upon retries, can aid in debugging, and avoids attack vectors such as signature key reuse:

\`\`\`jsonc
{
  // 
  "nonce": "04ac6cb6-df43-41fb-a7fd-e5dd711a64e1"
}
\`\`\`

The \`referer\` property is a regular expression to match against the HTTP referer of this upload, such as \`"example\\.org"\`. Specify this key to make sure that uploads only come from your domain.

Uploads without a referer will always pass (as they are turned off for some browsers) making this useful in just a handful of use cases. For details about regular expressions, see [Mozilla's RegExp documentation](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp).

The \`max_size\` property can be used to set a maximum size that an upload can have in bytes, such as \`1048576\` (1 MB). Specify this to prevent users from uploading excessively large files.

This can be set as part of the Assembly request or as part of the Template.

The file size is checked as soon as the upload is started and if it exceeds the maximum size, the entire upload process is canceled and the Assembly will error out, even if it contains files that do not exceed the \`max_size\` limitation.

If you want to just ignore the files that exceed a certain size, but process all others, then please use [/file/filter](https://transloadit.com/docs/robots/file-filter/).
`);
var assemblyInstructionsSharedShape = {
  allow_steps_override: external_exports.boolean().optional().describe("Set this to false to disallow Overruling Templates at Runtime. If you set this to false then template_id and steps will be mutually exclusive and you may only supply one of those parameters. Recommended when deploying Transloadit in untrusted environments. This makes sense to set as part of a Template, rather than on the Assembly itself when creating it."),
  notify_url: notifyUrlSchema,
  fields: fieldsSchema,
  quiet: external_exports.boolean().optional().describe("Set this to true to reduce the response from an Assembly POST request to only the necessary fields. This prevents any potentially confidential information being leaked to the end user who is making the Assembly request. A successful Assembly will only include the ok and assembly_id fields. An erroneous Assembly will only include the error, http_code, message and assembly_id fields. The full Assembly Status will then still be sent to the notify_url if one was specified."),
  // This is done to avoid heavy inference cost
  steps: optionalStepsSchema,
  template_id: templateIdSchema
};
var assemblyInstructionsSchema = external_exports.object({
  auth: assemblyAuthInstructionsSchema.optional(),
  ...assemblyInstructionsSharedShape
});
var assemblyInstructionsSchemaWithRequiredAuth = external_exports.object({
  auth: assemblyAuthInstructionsSchema,
  ...assemblyInstructionsSharedShape
});
var templateParamsSchema = external_exports.object({
  auth: assemblyAuthInstructionsSchema,
  name: external_exports.string().min(5).max(40).regex(/^[a-z-]+$/).describe("Name of this Template. Must be between 5-40 symbols (inclusive), lowercase, can only contain dashes and latin letters."),
  template: external_exports.string().describe(`All the [Assembly Instructions](/docs/topics/assembly-instructions/) and [Template options](/docs/topics/templates/#template-options) as a JSON encoded string.

Example value:

\`\`\`json
"{\\"allow_steps_override\\": false, \\"steps\\": { ... }}"
\`\`\`
`),
  require_signature_auth: external_exports.union([external_exports.literal(0), external_exports.literal(1)]).default(0).describe("Use `1` to deny requests that do not include a signature. With [Signature Authentication](/docs/api/authentication/) you can ensure no one else is sending requests on your behalf.")
}).strict();
var templateGetParamsSchema = external_exports.object({
  auth: assemblyAuthInstructionsSchema
}).strict();
var templateListParamsSchema = external_exports.object({
  auth: assemblyAuthInstructionsSchema,
  page: external_exports.number().int().default(1).describe("Specifies the current page, within the current pagination"),
  pagesize: external_exports.number().int().min(1).max(5e3).default(50).describe("Specifies how many Templates to be received per API request, which is useful for pagination."),
  sort: external_exports.enum(["id", "name", "created", "modified"]).default("created").describe("The field to sort by."),
  order: external_exports.enum(["asc", "desc"]).default("desc").describe('The sort direction. Can be `"desc"` for descending (default) or `"asc"` for ascending.'),
  fromdate: external_exports.string().describe("Specifies the minimum Assembly UTC creation date/time. Only Templates after this time will be retrieved. Use the format `Y-m-d H:i:s`."),
  todate: external_exports.string().default("NOW()").describe("Specifies the maximum Assembly UTC creation date/time. Only Templates before this time will be retrieved. Use the format `Y-m-d H:i:s`."),
  keywords: external_exports.array(external_exports.string()).default([]).describe("Specifies keywords to be matched in the Assembly Status. The Assembly fields checked include the `id`, `redirect_url`, `fields`, and `notify_url`, as well as error messages and files used.")
}).strict();
var assemblyInstructionsWithHiddenSchema = assemblyInstructionsSchema.extend({
  steps: optionalStepsWithHiddenFieldsSchema,
  imagemagick_stack: external_exports.string().optional(),
  exiftool_stack: external_exports.string().optional(),
  mplayer_stack: external_exports.string().optional(),
  mediainfo_stack: external_exports.string().optional(),
  ffmpeg_stack: external_exports.string().optional(),
  usage_tags: external_exports.string().optional(),
  response_headers: external_exports.object({
    cors: external_exports.object({
      "Access-Control-Allow-Methods": external_exports.string(),
      "Access-Control-Allow-Origin": external_exports.string(),
      "Access-Control-Allow-Headers": external_exports.string(),
      "Access-Control-Expose-Headers": external_exports.string(),
      "Access-Control-Allow-Credentials": external_exports.boolean(),
      "Access-Control-Max-Age": external_exports.number(),
      "Access-Control-Allow-Private-Network": external_exports.boolean(),
      "Access-Control-Allow-Public-Network": external_exports.boolean()
    }).optional()
  }).optional(),
  randomize_watermarks: external_exports.boolean().optional(),
  await: external_exports.union([
    external_exports.boolean(),
    external_exports.literal("notification"),
    external_exports.literal("persisting"),
    external_exports.literal("transcoding")
  ]).optional(),
  blocking: external_exports.boolean().optional(),
  reparse_template: external_exports.union([external_exports.literal(1), external_exports.boolean()]).optional(),
  ignore_upload_meta_data_errors: external_exports.boolean().optional(),
  emit_execution_progress: external_exports.boolean().optional()
});

// node_modules/transloadit/dist/alphalib/stepParsing.js
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
__name(isRecord, "isRecord");
function doesRobotSupportUse(robot) {
  return robot !== "/upload/handle" && robot !== "/google/import" && robot !== "/dropbox/import" && robot !== "/supabase/import" && robot !== "/swift/import" && robot !== "/backblaze/import" && robot !== "/ftp/import" && robot !== "/cloudfiles/import" && robot !== "/cloudflare/import" && robot !== "/digitalocean/import" && robot !== "/http/import" && robot !== "/s3/import" && robot !== "/azure/import" && robot !== "/minio/import" && robot !== "/wasabi/import" && robot !== "/edgly/deliver" && robot !== "/tlcdn/deliver" && robot !== "/sftp/import";
}
__name(doesRobotSupportUse, "doesRobotSupportUse");
function doesStepRobotSupportUse(step) {
  return "robot" in step && doesRobotSupportUse(step.robot);
}
__name(doesStepRobotSupportUse, "doesStepRobotSupportUse");
function simplifyUse(step) {
  if (!doesStepRobotSupportUse(step)) {
    return step;
  }
  if (!("use" in step)) {
    return step;
  }
  const zodRes2 = useParamArrayOfStringsSchema.safeParse(step.use);
  if (zodRes2.success) {
    if (zodRes2.data.length === 1) {
      step.use = zodRes2.data[0];
    }
  }
  return step;
}
__name(simplifyUse, "simplifyUse");
function addUseReference(step, newName, opts) {
  const { leading = false } = opts ?? {};
  if (!doesStepRobotSupportUse(step)) {
    return step;
  }
  if (!("use" in step)) {
    return { ...step, use: newName };
  }
  const zodRes1 = useParamStringSchema.safeParse(step.use);
  const zodRes2 = useParamArrayOfStringsSchema.safeParse(step.use);
  const zodRes3 = useParamArrayOfUseParamObjectSchema.safeParse(step.use);
  const zodRes4 = useParamObjectOfStepsSchema.safeParse(step.use);
  if (zodRes1.success) {
    step.use = leading ? [newName, zodRes1.data] : [zodRes1.data, newName];
  } else if (zodRes2.success) {
    step.use = leading ? [newName, ...zodRes2.data] : [...zodRes2.data, newName];
  } else if (zodRes3.success) {
    step.use = leading ? [{ name: newName }, ...zodRes3.data] : [...zodRes3.data, { name: newName }];
  } else if (zodRes4.success) {
    const zodRes41 = useParamStringSchema.safeParse(zodRes4.data.steps);
    const zodRes42 = useParamArrayOfStringsSchema.safeParse(zodRes4.data.steps);
    const zodRes43 = useParamArrayOfUseParamObjectSchema.safeParse(zodRes4.data.steps);
    if (zodRes41.success) {
      step.use = leading ? { ...zodRes4.data, steps: [newName, zodRes41.data] } : { ...zodRes4.data, steps: [zodRes41.data, newName] };
    } else if (zodRes42.success) {
      step.use = leading ? { ...zodRes4.data, steps: [newName, ...zodRes42.data] } : { ...zodRes4.data, steps: [...zodRes42.data, newName] };
    } else if (zodRes43.success) {
      step.use = leading ? { ...zodRes4.data, steps: [{ name: newName }, ...zodRes43.data] } : { ...zodRes4.data, steps: [...zodRes43.data, { name: newName }] };
    } else {
      throw new Error("Invalid use value");
    }
  }
  return simplifyUse(step);
}
__name(addUseReference, "addUseReference");
var getIndentation = /* @__PURE__ */ __name((templateContent) => {
  const lines = templateContent.split("\n");
  let baseIndent = "";
  let firstContentLine = "";
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.length > 0) {
      firstContentLine = line;
      baseIndent = line.slice(0, line.length - trimmed.length);
      break;
    }
  }
  let nestedIndent = "";
  let foundNested = false;
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.length === 0)
      continue;
    if (line === firstContentLine)
      continue;
    const currentIndent = line.slice(0, line.length - trimmed.length);
    if (currentIndent.length > baseIndent.length) {
      nestedIndent = currentIndent.slice(baseIndent.length);
      foundNested = true;
      break;
    }
  }
  if (foundNested) {
    if (nestedIndent.includes("	")) {
      return "	".repeat(nestedIndent.split("	").length - 1);
    }
    return nestedIndent;
  }
  return "  ";
}, "getIndentation");
var StepParsingError = class extends Error {
  static {
    __name(this, "StepParsingError");
  }
  zodIssuesWithContext;
  humanReadable;
  constructor(message, zodIssuesWithContext, humanReadable) {
    super(message);
    this.zodIssuesWithContext = zodIssuesWithContext;
    this.humanReadable = humanReadable;
  }
};
function formatZodIssuesForLog(issues) {
  return issues.map((issue) => ({
    path: issue.path,
    code: issue.code,
    message: issue.message
  }));
}
__name(formatZodIssuesForLog, "formatZodIssuesForLog");
var parseSafeTemplate = /* @__PURE__ */ __name((templateContent, opts) => {
  const silent = opts?.silent ?? (process.env.NODE_ENV ?? "production") === "production";
  let parsed;
  let indent = "  ";
  try {
    parsed = JSON.parse(templateContent);
    indent = getIndentation(templateContent);
  } catch (error) {
    if (!silent) {
      console.error("templateContent", { length: templateContent.length });
    }
    return [
      new StepParsingError(`Error parsing valid type from Template. ${error}. Input length: ${templateContent.length}`, [], ""),
      null
    ];
  }
  const { success, errors: zodIssuesWithContext, humanReadable } = zodParseWithContext(assemblyInstructionsSchema, parsed);
  if (!success) {
    if (!silent) {
      console.error("zodIssuesWithContext", formatZodIssuesForLog(zodIssuesWithContext));
    }
    return [
      new StepParsingError("Error validating Template against assemblyInstructionsSchema. ", zodIssuesWithContext, humanReadable),
      null
    ];
  }
  const safe = parsed;
  return [null, safe, indent];
}, "parseSafeTemplate");
function botNeedsInput(robotName, stepName, step) {
  if (robotName.endsWith("/import")) {
    return false;
  }
  if (robotName === "/upload/handle") {
    return false;
  }
  if (robotName === "/html/convert") {
    if (step && "url" in step && typeof step.url === "string" && step.url) {
      return false;
    }
  }
  if (robotName === "/text/speak") {
    if (step && "prompt" in step && typeof step.prompt === "string" && step.prompt) {
      return false;
    }
  }
  if (robotName === "/image/generate") {
    return false;
  }
  if (stepName === ":original") {
    return false;
  }
  return true;
}
__name(botNeedsInput, "botNeedsInput");
function getFirstStepNameThatDoesNotNeedInput(templateContent, excludeBots = []) {
  let parsed;
  try {
    parsed = JSON.parse(templateContent);
  } catch (_e) {
    return "";
  }
  if (!isRecord(parsed) || !("steps" in parsed)) {
    return "";
  }
  const stepsValue = parsed.steps;
  if (!isRecord(stepsValue)) {
    return "";
  }
  const stepsRecord = stepsValue;
  return getFirstStepNameThatDoesNotNeedInputFromSteps(stepsRecord, excludeBots);
}
__name(getFirstStepNameThatDoesNotNeedInput, "getFirstStepNameThatDoesNotNeedInput");
var getFirstStepNameThatDoesNotNeedInputFromSteps = /* @__PURE__ */ __name((steps, excludeBots = []) => {
  return Object.keys(steps).find((stepName) => {
    const step = steps[stepName];
    return typeof step === "object" && step !== null && typeof step.robot === "string" && !botNeedsInput(step.robot, stepName, step) && !excludeBots.includes(step.robot);
  }) ?? "";
}, "getFirstStepNameThatDoesNotNeedInputFromSteps");
var hasRobot = /* @__PURE__ */ __name((templateContent, rName, silent) => {
  const parseOpts = silent === void 0 ? void 0 : { silent };
  const [templateError, template] = parseSafeTemplate(templateContent, parseOpts);
  if (templateError) {
    return false;
  }
  return Object.values(template.steps ?? {}).some((step) => {
    return typeof rName === "string" ? step.robot === rName : rName.test(step.robot);
  });
}, "hasRobot");

// node_modules/transloadit/dist/alphalib/assembly-linter.js
var MAX_STEPS_PER_URLTRANSFORM_ASSEMBLY = 20;
var getStepLocation = /* @__PURE__ */ __name((steps, stepName) => ({
  row: steps.__line?.[stepName] ?? 0,
  column: steps.__column?.[stepName] ?? 0
}), "getStepLocation");
var fixWrongStackVersionSchema = external_exports.object({
  stepName: external_exports.string(),
  paramName: external_exports.string(),
  recommendedVersion: external_exports.string()
});
var fixMissingUseSchema = external_exports.object({
  stepName: external_exports.string()
});
var fixDuplicateKeyInStepSchema = external_exports.object({
  stepName: external_exports.string(),
  duplicateKeys: external_exports.array(external_exports.string())
});
var fixSmartCdnInputFieldSchema = external_exports.object({
  stepName: external_exports.string()
});
var fixMissingInputSchema = external_exports.object({});
var fixMissingStepsSchema = external_exports.object({});
var fixInvalidStepsTypeSchema = external_exports.object({});
var fixEmptyStepsSchema = external_exports.object({});
var fixMissingOriginalStorageSchema = external_exports.object({});
function isObject2(obj) {
  return typeof obj === "object" && !Array.isArray(obj) && obj !== null;
}
__name(isObject2, "isObject");
function has(object, key) {
  return Object.hasOwn(object, key);
}
__name(has, "has");
function isParseError(e) {
  return e instanceof Error && isObject2(e) && "line" in e && typeof e.line === "number" && "column" in e && typeof e.column === "number" && "rawMessage" in e && typeof e.rawMessage === "string";
}
__name(isParseError, "isParseError");
function getASTValue(ast) {
  switch (ast.type) {
    case "Literal":
      return ast.value;
    case "Array": {
      const value = [];
      const lines = [];
      const columns = [];
      for (const property of ast.children) {
        if (property.loc) {
          value.push(getASTValue(property));
          lines.push(property.loc.start.line - 1);
          columns.push(property.loc.start.column - 1);
        }
      }
      Object.defineProperty(value, "__line", { value: lines });
      Object.defineProperty(value, "__column", { value: columns });
      return value;
    }
    case "Object": {
      const value = {};
      const lines = {};
      const columns = {};
      for (const property of ast.children) {
        if (property.key && property.value && property.value.loc) {
          value[property.key.value] = getASTValue(property.value);
          lines[property.key.value] = property.value.loc.start.line - 1;
          columns[property.key.value] = property.value.loc.start.column - 1;
        }
      }
      Object.defineProperty(value, "__line", { value: lines });
      Object.defineProperty(value, "__column", { value: columns });
      return value;
    }
    default:
      return void 0;
  }
}
__name(getASTValue, "getASTValue");
function getRobotsUsingTool(tool) {
  return Object.entries(robotsMeta).filter(([, meta83]) => !tool || meta83.uses_tools?.includes(tool)).map(([varName]) => {
    const rName = `/${varName.replace(/([a-z0-9])([A-Z])/g, "$1/$2").toLowerCase().replace(/\/meta$/, "")}`;
    return rName;
  });
}
__name(getRobotsUsingTool, "getRobotsUsingTool");
var STORE_ROBOT_NAME = /^\/[a-z0-9]+\/store$/i;
function isStoreRobot(name) {
  return STORE_ROBOT_NAME.test(name);
}
__name(isStoreRobot, "isStoreRobot");
var IMPORT_ROBOT_NAME = /^\/[a-z0-9]+\/import$/i;
function isImportRobot(name) {
  return IMPORT_ROBOT_NAME.test(name);
}
__name(isImportRobot, "isImportRobot");
var FFMPEG_ROBOT_NAMES = getRobotsUsingTool("ffmpeg");
function isFfmpegRobot(name) {
  return FFMPEG_ROBOT_NAMES.some((x) => x === name);
}
__name(isFfmpegRobot, "isFfmpegRobot");
var IMAGICK_ROBOT_NAMES = getRobotsUsingTool("imagemagick");
function isImagickRobot(name) {
  return IMAGICK_ROBOT_NAMES.some((x) => x === name);
}
__name(isImagickRobot, "isImagickRobot");
var ALL_ROBOT_NAMES = getRobotsUsingTool();
function isRobot(name) {
  return ALL_ROBOT_NAMES.includes(name);
}
__name(isRobot, "isRobot");
function isHttpImportRobot(name) {
  return name === "/http/import";
}
__name(isHttpImportRobot, "isHttpImportRobot");
function lintStackParameter(step, stepName, steps, stackName, result) {
  const paramName = `${stackName}_stack`;
  if (has(step, paramName)) {
    const stackVersionValue = step[paramName];
    if (typeof stackVersionValue === "string") {
      if (!stackVersions[stackName].test.test(stackVersionValue)) {
        result.push({
          code: `wrong-${stackName}-version`,
          stepName,
          robot: step.robot,
          isAudioRobot: step.robot?.indexOf("/audio/") === 0,
          stackVersion: stackVersionValue,
          type: "error",
          row: steps.__line[stepName],
          column: steps.__column[stepName],
          fixId: "fix-wrong-stack-version",
          fixData: {
            stepName,
            paramName,
            recommendedVersion: stackVersions[stackName].recommendedVersion
          }
        });
      }
    } else {
    }
  }
}
__name(lintStackParameter, "lintStackParameter");
function lintUseArray(use, stepName, stepNames, result, row, column) {
  if (!Array.isArray(use))
    return;
  if (use.length === 0) {
    result.push({
      code: "empty-use-array",
      stepName,
      type: "warning",
      row: row ?? 0,
      column: column ?? 0
    });
    return;
  }
  use.forEach((obj, index) => {
    let name;
    if (typeof obj === "object" && obj !== null) {
      name = obj.name;
    } else if (typeof obj === "string") {
      name = obj;
    }
    if (name && stepNames.indexOf(name) === -1) {
      result.push({
        code: "undefined-step",
        stepName,
        wrongStepName: name,
        type: "error",
        row: typeof obj === "object" && obj !== null && obj.__line?.[index] ? obj.__line[index] : row ?? 0,
        column: typeof obj === "object" && obj !== null && obj.__column?.[index] ? obj.__column[index] : column ?? 0
      });
    }
  });
}
__name(lintUseArray, "lintUseArray");
function lintHttpImportUrl(step, stepName, result) {
  if (!has(step, "url")) {
    return;
  }
  const { url } = step;
  if (typeof url !== "string") {
    return;
  }
  const fieldVariableRegex = /^\$\{fields\.[^}]+\}$/;
  const protocolDomainRegex = /^(https?:\/\/|\/\/)[^/]+/i;
  if (fieldVariableRegex.test(url) && !protocolDomainRegex.test(url)) {
    result.push({
      code: "unqualified-http-import-url",
      stepName,
      type: "warning",
      row: step.__line.url,
      column: step.__column.url,
      message: "The /http/import url should include a protocol and domain name for security reasons."
    });
  }
}
__name(lintHttpImportUrl, "lintHttpImportUrl");
function lint(assembly) {
  const result = [];
  if (!isObject2(assembly) || !("steps" in assembly)) {
    result.push({
      code: "missing-steps",
      type: "error",
      row: 0,
      column: 0,
      message: "The 'steps' property is missing",
      fixId: "fix-missing-steps",
      fixData: {}
    });
    return result;
  }
  if (!isObject2(assembly.steps)) {
    result.push({
      code: "invalid-steps-type",
      type: "error",
      row: assembly.__line?.steps ?? 0,
      column: assembly.__column?.steps ?? 0,
      message: "The 'steps' property must be an object",
      fixId: "fix-invalid-steps-type",
      fixData: {}
    });
    return result;
  }
  if (Object.keys(assembly.steps).length === 0) {
    result.push({
      code: "empty-steps",
      type: "warning",
      row: assembly.__line?.steps ?? 0,
      column: assembly.__column?.steps ?? 0,
      message: "The 'steps' object is empty",
      fixId: "fix-empty-steps",
      fixData: {}
    });
    return result;
  }
  if (!isObject2(assembly.steps)) {
    return result;
  }
  const steps = assembly.steps;
  const stepNames = Object.keys(steps).filter((key) => key !== "__line" && key !== "__column");
  if (!stepNames.includes(":original")) {
    stepNames.push(":original");
  }
  let hasFileServe = false;
  let hasFieldsInput = false;
  let importStepName = "";
  for (const [stepName, step] of Object.entries(steps)) {
    if (stepName === "__line" || stepName === "__column")
      continue;
    if (!isObject2(step))
      continue;
    if (!("robot" in step || "use" in step)) {
      continue;
    }
    const typedStep = step;
    if (!typedStep.robot)
      continue;
    if (typedStep.robot === "/file/serve") {
      hasFileServe = true;
    }
    if (isImportRobot(typedStep.robot)) {
      importStepName = stepName;
      const stepStr = JSON.stringify(step);
      if (stepStr.includes("${fields.input}")) {
        hasFieldsInput = true;
      }
    }
  }
  if (hasFileServe && !hasFieldsInput && importStepName) {
    const { row, column } = getStepLocation(steps, importStepName);
    result.push({
      code: "smart-cdn-input-field-missing",
      type: "warning",
      row,
      column,
      message: "Smart CDN path component available as `${fields.input}`",
      stepName: importStepName,
      fixId: "fix-smart-cdn-input-field",
      fixData: { stepName: importStepName }
    });
  }
  let usesOriginalFiles = false;
  let storesOriginalFiles = false;
  let hasInputStep = false;
  for (const [stepName, step] of Object.entries(steps)) {
    if (stepName === "__line" || stepName === "__column")
      continue;
    const { row, column } = getStepLocation(steps, stepName);
    if (!step || typeof step !== "object" || Array.isArray(step)) {
      result.push({
        code: "step-is-not-an-object",
        stepName,
        type: "error",
        row,
        column
      });
      continue;
    }
    const stepKeys = Object.keys(step).filter((key) => key !== "__line" && key !== "__column");
    if (!("robot" in step || "use" in step)) {
      if (stepKeys.length > 0) {
        result.push({
          code: "missing-robot",
          stepName,
          type: "error",
          row,
          column
        });
      }
      continue;
    }
    const typedStep = step;
    if (!typedStep.robot) {
      result.push({
        code: "missing-robot",
        stepName,
        type: "error",
        row,
        column
      });
      continue;
    } else if (!isRobot(typedStep.robot)) {
      result.push({
        code: "undefined-robot",
        stepName,
        robot: typedStep.robot,
        type: "error",
        row: typedStep.__line.robot,
        column: typedStep.__column.robot
      });
    } else if (typedStep.robot === "/file/serve") {
      hasFileServe = true;
      if ("url" in typedStep && !("use" in typedStep)) {
        const stepStr = JSON.stringify(step);
        if (!stepStr.includes("${fields.input}")) {
          result.push({
            code: "smart-cdn-input-field-missing",
            type: "warning",
            row,
            column,
            message: "Smart CDN path component available as `${fields.input}`",
            stepName
          });
        }
      }
    } else if (isFfmpegRobot(typedStep.robot)) {
      lintStackParameter(typedStep, stepName, steps, "ffmpeg", result);
    } else if (isImagickRobot(typedStep.robot)) {
      lintStackParameter(typedStep, stepName, steps, "imagemagick", result);
    } else if (typedStep.robot === "/upload/handle") {
      if (stepName !== ":original") {
        result.push({
          code: "wrong-step-name",
          type: "error",
          row,
          column
        });
      }
    } else if (isHttpImportRobot(typedStep.robot)) {
      lintHttpImportUrl(typedStep, stepName, result);
    }
    if (!has(typedStep, "use")) {
      if (typedStep.robot === "/html/convert") {
        if (has(typedStep, "url")) {
          hasInputStep = true;
        } else {
          result.push({
            code: "missing-url",
            stepName,
            type: "warning",
            row,
            column
          });
        }
      } else if (
        // Check if this robot doesn't need input (like import robots, /upload/handle,
        // file-generating robots like /image/generate, /text/speak with prompt, etc.)
        !botNeedsInput(typedStep.robot, stepName, typedStep)
      ) {
        hasInputStep = true;
      } else {
        result.push({
          code: "missing-use",
          stepName,
          type: "warning",
          row,
          column,
          fixId: "fix-missing-use",
          fixData: { stepName }
        });
      }
    } else {
      if (Array.isArray(typedStep.use)) {
        const referencesOriginal = typedStep.use.some((item) => {
          if (typeof item === "string") {
            return item === ":original";
          }
          return typeof item === "object" && item !== null && "name" in item && item.name === ":original";
        });
        if (referencesOriginal) {
          hasInputStep = true;
        }
        lintUseArray(typedStep.use, stepName, stepNames, result, typedStep.__line.use, typedStep.__column.use);
      } else if (typeof typedStep.use === "object" && typedStep.use !== null) {
        const useObject = typedStep.use;
        if ("steps" in useObject) {
          const useStepsLine = useObject?.__line?.steps;
          const useStepsColumn = useObject?.__column?.steps;
          if (Array.isArray(useObject.steps)) {
            if (useObject.steps.some((step2) => {
              if (typeof step2 === "string") {
                return step2 === ":original";
              }
              return typeof step2 === "object" && step2 !== null && "name" in step2 && step2.name === ":original";
            })) {
              hasInputStep = true;
            }
            lintUseArray(
              useObject.steps,
              stepName,
              stepNames,
              result,
              useStepsLine ?? typedStep.__line.use,
              // Fallback to the line of the 'use' key itself
              useStepsColumn ?? typedStep.__column.use
            );
          } else if (typeof useObject.steps === "string") {
            if (useObject.steps === ":original") {
              hasInputStep = true;
            }
            lintUseArray([useObject.steps], stepName, stepNames, result, useStepsLine ?? typedStep.__line.use, useStepsColumn ?? typedStep.__column.use);
          } else if (typeof useObject.steps !== "string") {
            result.push({
              code: "missing-use-steps",
              // Or a more specific error like 'invalid-use-object-structure'
              stepName,
              type: "error",
              row: typedStep.__line.use,
              // Point to the start of the use object
              column: typedStep.__column.use
            });
          }
        }
      } else if (typeof typedStep.use === "string") {
        if (typedStep.use === ":original") {
          hasInputStep = true;
        }
        if (stepNames.indexOf(typedStep.use) === -1) {
          result.push({
            code: "undefined-step",
            stepName,
            wrongStepName: typedStep.use,
            type: "error",
            row: typedStep.__line.use,
            column: typedStep.__column.use
          });
        }
      } else {
        result.push({
          code: "wrong-use-type",
          stepName,
          type: "error",
          row: typedStep.__line.use,
          column: typedStep.__column.use
        });
      }
      const referencesOriginalFiles = JSON.stringify(typedStep.use).includes(":original");
      if (referencesOriginalFiles) {
        if (typedStep.robot && isStoreRobot(typedStep.robot)) {
          storesOriginalFiles = true;
        } else {
          usesOriginalFiles = true;
        }
      }
    }
  }
  if (!hasFileServe) {
    const hasStorageRobot = hasRobot(JSON.stringify(assembly), /\/store$/, true);
    if (!hasStorageRobot) {
      result.push({
        code: "no-storage",
        type: "warning",
        row: assembly.__line?.steps ?? 0,
        column: assembly.__column?.steps ?? 0
      });
    }
    if (usesOriginalFiles && !storesOriginalFiles && hasStorageRobot) {
      result.push({
        code: "missing-original-storage",
        type: "warning",
        row: assembly.__line?.steps ?? 0,
        column: assembly.__column?.steps ?? 0,
        fixId: "fix-missing-original-storage",
        fixData: {}
      });
    }
  }
  if (!hasInputStep) {
    result.push({
      code: "missing-input",
      type: "error",
      row: assembly.__line?.steps ?? 0,
      column: assembly.__column?.steps ?? 0,
      fixId: "fix-missing-input",
      fixData: {}
      // Add an empty object as fixData
    });
  }
  const cntErrors = result.filter((r) => r.type === "error").length;
  if (!cntErrors) {
    const parsed = zodParseWithContext(assemblyInstructionsSchema, assembly);
    if (!parsed.success) {
      for (const zodIssue of parsed.errors) {
        let row = assembly.__line?.steps ?? 1;
        let column = assembly.__column?.steps ?? 1;
        const { path: path2 } = zodIssue;
        if (path2.length > 0) {
          let current = assembly;
          let metadata = assembly;
          for (const segment of path2) {
            if (typeof segment === "string" && current && typeof current === "object") {
              current = current[segment];
              if (metadata && "__line" in metadata && "__column" in metadata) {
                const lines = metadata.__line;
                const columns = metadata.__column;
                if (segment in lines && segment in columns) {
                  row = lines[segment];
                  column = columns[segment];
                }
              }
              metadata = current;
            }
          }
        }
        result.push({
          code: "schema-violation",
          type: "error",
          row,
          column,
          message: zodIssue.humanReadable
        });
      }
    }
  }
  return result;
}
__name(lint, "lint");
function isInfiniteAssembly(template) {
  if (!template.steps)
    return [false];
  const graph = /* @__PURE__ */ new Map();
  for (const [stepName, stepValue] of Object.entries(template.steps)) {
    if (stepName === "__line" || stepName === "__column")
      continue;
    if (typeof stepValue !== "object" || stepValue === null || !("use" in stepValue) || !stepValue.use) {
      continue;
    }
    const stepUseValue = stepValue.use;
    if (typeof stepUseValue === "string") {
      graph.set(stepName, [stepUseValue]);
      continue;
    }
    if (Array.isArray(stepUseValue)) {
      const filteredUseArray = stepUseValue.filter((u2) => typeof u2 === "string" || typeof u2 === "object" && u2 !== null && "name" in u2 && typeof u2.name === "string");
      if (filteredUseArray.every((u2) => typeof u2 === "string")) {
        graph.set(stepName, filteredUseArray);
        continue;
      }
      if (filteredUseArray.every((u2) => typeof u2 === "object" && u2 !== null && "name" in u2)) {
        graph.set(stepName, filteredUseArray.map((u2) => u2.name));
        continue;
      }
    }
    if (typeof stepUseValue === "object" && stepUseValue !== null && "steps" in stepUseValue && Array.isArray(stepUseValue.steps)) {
      const useSteps = stepUseValue.steps;
      const filteredUseSteps = useSteps.filter((s) => typeof s === "string" || typeof s === "object" && s !== null && "name" in s && typeof s.name === "string");
      if (filteredUseSteps.every((s) => typeof s === "string")) {
        graph.set(stepName, filteredUseSteps);
      } else if (filteredUseSteps.every((s) => typeof s === "object" && s !== null && "name" in s)) {
        graph.set(stepName, filteredUseSteps.map((s) => s.name));
      }
    }
  }
  const visited = /* @__PURE__ */ new Set();
  const recursionStack = /* @__PURE__ */ new Set();
  function dfs(node) {
    if (recursionStack.has(node))
      return true;
    if (visited.has(node))
      return false;
    visited.add(node);
    recursionStack.add(node);
    const neighbors = graph.get(node) || [];
    for (const neighbor of neighbors) {
      if (node === ":original" && neighbor !== ":original") {
        continue;
      }
      if (dfs(neighbor)) {
        return true;
      }
    }
    recursionStack.delete(node);
    return false;
  }
  __name(dfs, "dfs");
  for (const [stepName, stepValue] of Object.entries(template.steps)) {
    if (stepName === "__line" || stepName === "__column")
      continue;
    if (!graph.has(stepName))
      continue;
    if (!visited.has(stepName) && dfs(stepName)) {
      const offendingStep = stepValue;
      return [
        true,
        {
          stepName,
          line: offendingStep.__line?.use ?? 0,
          // Assumes 'use' is a key in __line for the property itself
          column: offendingStep.__column?.use ?? 0
        }
      ];
    }
  }
  return [false];
}
__name(isInfiniteAssembly, "isInfiniteAssembly");
function findDuplicateKeysInAST(node, path2 = "", annotations = []) {
  if (node.type === "Object") {
    const keysSeen = /* @__PURE__ */ new Map();
    for (const property of node.children) {
      const key = property.key.value;
      const keyLocation = property.key.loc;
      const fullPath = path2 ? `${path2}.${key}` : key;
      if (keysSeen.has(key) && keyLocation) {
        const stepName = path2.includes("steps.") ? path2.split("steps.")[1] : void 0;
        annotations.push({
          code: "duplicate-key-in-step",
          type: "warning",
          row: keyLocation.start.line - 1,
          column: keyLocation.start.column - 1,
          message: `Duplicate key '${key}' found`,
          stepName,
          duplicateKeys: [key],
          fixId: "fix-duplicate-key-in-step",
          fixData: {
            stepName: stepName ?? "",
            duplicateKeys: [key]
          }
        });
      } else {
        keysSeen.set(key, property.value);
      }
      findDuplicateKeysInAST(property.value, fullPath, annotations);
    }
  } else if (node.type === "Array") {
    for (const item of node.children) {
      findDuplicateKeysInAST(item, path2, annotations);
    }
  }
}
__name(findDuplicateKeysInAST, "findDuplicateKeysInAST");
function isSmartCdnAssembly(assembly) {
  if (!isObject2(assembly) || !isObject2(assembly.steps)) {
    return false;
  }
  for (const [stepName, step] of Object.entries(assembly.steps)) {
    if (stepName === "__line" || stepName === "__column")
      continue;
    if (!isObject2(step))
      continue;
    const typedStep = step;
    if (typedStep.robot === "/file/serve") {
      return true;
    }
  }
  return false;
}
__name(isSmartCdnAssembly, "isSmartCdnAssembly");
function countSteps(steps) {
  return Object.keys(steps).filter((key) => key !== "__line" && key !== "__column").length;
}
__name(countSteps, "countSteps");
function isRobotAllowedForSmartCdn(robotName) {
  if (!robotName || typeof robotName !== "string") {
    return false;
  }
  const parts = robotName.substring(1).split("/");
  const keyBase = parts.map((part, index) => {
    if (index === 0)
      return part;
    return part.charAt(0).toUpperCase() + part.slice(1);
  }).join("");
  const robotMetaKey = `${keyBase}Meta`;
  const meta83 = robotsMeta[robotMetaKey];
  return meta83?.allowed_for_url_transform === true;
}
__name(isRobotAllowedForSmartCdn, "isRobotAllowedForSmartCdn");
function lintSmartCdn(assembly) {
  const results = [];
  if (!assembly.steps || typeof assembly.steps !== "object") {
    return results;
  }
  const steps = assembly.steps;
  const stepCount = countSteps(steps);
  if (stepCount > MAX_STEPS_PER_URLTRANSFORM_ASSEMBLY) {
    results.push({
      code: "smart-cdn-max-steps-exceeded",
      type: "error",
      row: assembly.__line?.steps ?? 0,
      column: assembly.__column?.steps ?? 0,
      message: `Smart CDN Assemblies are limited to ${MAX_STEPS_PER_URLTRANSFORM_ASSEMBLY} steps, but found ${stepCount} steps`,
      maxStepCount: MAX_STEPS_PER_URLTRANSFORM_ASSEMBLY,
      stepCount
    });
  }
  for (const [stepName, step] of Object.entries(steps)) {
    if (stepName === "__line" || stepName === "__column" || typeof step !== "object" || !step) {
      continue;
    }
    const typedStep = step;
    const robotNameValue = typedStep.robot;
    if (robotNameValue && !isRobotAllowedForSmartCdn(robotNameValue)) {
      const { row, column } = getStepLocation(steps, stepName);
      results.push({
        code: "smart-cdn-robot-not-allowed",
        type: "error",
        row,
        column,
        message: `Robot "${robotNameValue}" is not allowed in Smart CDN Assemblies`,
        stepName,
        robot: robotNameValue
      });
    }
  }
  return results;
}
__name(lintSmartCdn, "lintSmartCdn");
async function parseAndLint(json) {
  let ast;
  try {
    ast = (0, import_json_to_ast.default)(json, { loc: true });
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    if (e.name !== "SyntaxError") {
      throw e;
    }
    if (!isParseError(e)) {
      throw e;
    }
    return [
      {
        code: "invalid-json",
        type: "error",
        row: e.line - 1,
        column: e.column - 1,
        message: e.rawMessage
      }
    ];
  }
  const obj = getASTValue(ast);
  const templateMeta = obj;
  const annotations = lint(templateMeta);
  if (isSmartCdnAssembly(templateMeta)) {
    annotations.push(...lintSmartCdn(templateMeta));
  }
  findDuplicateKeysInAST(ast, void 0, annotations);
  const [isInfinite2, positionalInfo] = isInfiniteAssembly(templateMeta);
  if (isInfinite2 && positionalInfo) {
    annotations.push({
      code: "infinite-assembly",
      type: "error",
      row: positionalInfo.line,
      column: positionalInfo.column,
      stepName: positionalInfo.stepName
    });
  }
  annotations.sort((a2, b) => a2.row - b.row);
  return annotations;
}
__name(parseAndLint, "parseAndLint");
function fixWrongStackVersion(content, fixData) {
  let parsed;
  let indent = "  ";
  try {
    parsed = JSON.parse(content);
    indent = getIndentation(content);
  } catch (_e) {
    return content;
  }
  if (!isObject2(parsed)) {
    return content;
  }
  const parsedRecord = parsed;
  const stepsValue = parsedRecord.steps;
  if (!isObject2(stepsValue)) {
    return content;
  }
  const stepsRecord = stepsValue;
  const newStepsEntries = [];
  for (const [stepName2, step2] of Object.entries(stepsRecord)) {
    if (typeof step2 !== "object" || step2 === null) {
      newStepsEntries.push([stepName2, step2]);
      continue;
    }
    let newStep = { ...step2 };
    if (fixData.stepName === stepName2) {
      newStep = { ...step2, [fixData.paramName]: fixData.recommendedVersion };
    }
    newStepsEntries.push([stepName2, newStep]);
  }
  return JSON.stringify({ ...parsedRecord, steps: Object.fromEntries(newStepsEntries) }, null, indent);
}
__name(fixWrongStackVersion, "fixWrongStackVersion");
function fixMissingUse(content, fixData) {
  let parsed;
  let indent = "  ";
  try {
    parsed = JSON.parse(content);
    indent = getIndentation(content);
  } catch (_e) {
    return content;
  }
  if (!isObject2(parsed)) {
    return content;
  }
  const parsedRecord = parsed;
  const stepsValue = parsedRecord.steps;
  if (!isObject2(stepsValue)) {
    return content;
  }
  const stepsRecord = stepsValue;
  const stepValue = stepsRecord[fixData.stepName];
  if (!isObject2(stepValue) || !("robot" in stepValue)) {
    return content;
  }
  const step = stepValue;
  const firstInputStepName = getFirstStepNameThatDoesNotNeedInput(content);
  if (!firstInputStepName) {
    return content;
  }
  if (doesStepRobotSupportUse(step)) {
    step.use = firstInputStepName;
  }
  parsedRecord.steps = stepsRecord;
  return JSON.stringify(parsedRecord, null, indent);
}
__name(fixMissingUse, "fixMissingUse");
function fixDuplicateKeyInStep(content, _fixData) {
  const [templateError, template, indent] = parseSafeTemplate(content);
  if (templateError) {
    return content;
  }
  return JSON.stringify(template, null, indent);
}
__name(fixDuplicateKeyInStep, "fixDuplicateKeyInStep");
function fixMissingSteps(content) {
  const [templateError, template, indent] = parseSafeTemplate(content);
  if (templateError) {
    return JSON.stringify({ steps: {} }, null, "  ");
  }
  return JSON.stringify({ ...template, steps: {} }, null, indent);
}
__name(fixMissingSteps, "fixMissingSteps");
function fixMissingInput(content) {
  let parsed;
  let indent = "  ";
  try {
    parsed = JSON.parse(content);
    indent = getIndentation(content);
  } catch (_e) {
    return content;
  }
  if (!isObject2(parsed)) {
    return content;
  }
  const parsedRecord = parsed;
  const stepsValue = parsedRecord.steps;
  if (!isObject2(stepsValue)) {
    return content;
  }
  const stepsRecord = stepsValue;
  stepsRecord[":original"] = {
    robot: "/upload/handle"
  };
  for (const [stepName, step] of Object.entries(stepsRecord)) {
    if (stepName !== ":original" && isObject2(step) && !("use" in step) && "robot" in step) {
      const updatedStep = addUseReference(step, ":original");
      stepsRecord[stepName] = updatedStep;
    }
  }
  parsedRecord.steps = stepsRecord;
  return JSON.stringify(parsedRecord, null, indent);
}
__name(fixMissingInput, "fixMissingInput");
function fixInvalidStepsType(content) {
  let parsed;
  let indent = "  ";
  try {
    parsed = JSON.parse(content);
    indent = getIndentation(content);
  } catch (_err) {
    return content;
  }
  if (!isObject2(parsed)) {
    return content;
  }
  const parsedRecord = parsed;
  if (!isObject2(parsedRecord.steps)) {
    parsedRecord.steps = {};
  }
  return JSON.stringify(parsedRecord, null, indent);
}
__name(fixInvalidStepsType, "fixInvalidStepsType");
function fixEmptySteps(content) {
  const [templateError, template, indent] = parseSafeTemplate(content);
  if (templateError) {
    return content;
  }
  if (Object.keys(template.steps ?? {}).length === 0) {
    template.steps = {
      ":original": {
        robot: "/upload/handle"
      }
    };
  }
  return JSON.stringify(template, null, indent);
}
__name(fixEmptySteps, "fixEmptySteps");
function fixMissingOriginalStorage(content) {
  const [templateError, template, indent] = parseSafeTemplate(content);
  if (templateError) {
    return content;
  }
  for (const [, step] of entries2(template.steps)) {
    if (step.robot.endsWith("/store")) {
      const updatedStep = addUseReference(step, ":original", { leading: true });
      Object.assign(step, updatedStep);
    }
  }
  return JSON.stringify(template, null, indent);
}
__name(fixMissingOriginalStorage, "fixMissingOriginalStorage");
function fixSmartCdnInputField(content, fixData) {
  const [templateError, template, indent] = parseSafeTemplate(content);
  if (templateError) {
    return content;
  }
  const step = template.steps?.[fixData.stepName];
  if (!step || step.robot !== "/http/import") {
    return content;
  }
  const httpImportStep = step;
  httpImportStep.url = "https://demos.transloadit.com/${fields.input}";
  return JSON.stringify(template, null, indent);
}
__name(fixSmartCdnInputField, "fixSmartCdnInputField");
function applyFix(content, fixId, fixData) {
  switch (fixId) {
    case "fix-wrong-stack-version":
      return fixWrongStackVersion(content, fixWrongStackVersionSchema.parse(fixData));
    case "fix-missing-use":
      return fixMissingUse(content, fixMissingUseSchema.parse(fixData));
    case "fix-duplicate-key-in-step":
      return fixDuplicateKeyInStep(content, fixDuplicateKeyInStepSchema.parse(fixData));
    case "fix-missing-input":
      fixMissingInputSchema.parse(fixData);
      return fixMissingInput(content);
    case "fix-missing-steps":
      fixMissingStepsSchema.parse(fixData);
      return fixMissingSteps(content);
    case "fix-invalid-steps-type":
      fixInvalidStepsTypeSchema.parse(fixData);
      return fixInvalidStepsType(content);
    case "fix-empty-steps":
      fixEmptyStepsSchema.parse(fixData);
      return fixEmptySteps(content);
    case "fix-missing-original-storage":
      fixMissingOriginalStorageSchema.parse(fixData);
      return fixMissingOriginalStorage(content);
    case "fix-smart-cdn-input-field":
      return fixSmartCdnInputField(content, fixSmartCdnInputFieldSchema.parse(fixData));
    default:
      throw new Error(`Unknown fixId: ${fixId}`);
  }
}
__name(applyFix, "applyFix");

// node_modules/transloadit/dist/lintAssemblyInput.js
init_esm();

// node_modules/transloadit/dist/alphalib/templateMerge.js
init_esm();

// node_modules/lodash-es/merge.js
init_esm();

// node_modules/lodash-es/_baseMerge.js
init_esm();

// node_modules/lodash-es/_Stack.js
init_esm();

// node_modules/lodash-es/_ListCache.js
init_esm();

// node_modules/lodash-es/_listCacheClear.js
init_esm();
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_listCacheDelete.js
init_esm();

// node_modules/lodash-es/_assocIndexOf.js
init_esm();

// node_modules/lodash-es/eq.js
init_esm();
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
init_esm();
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
init_esm();
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
init_esm();
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries3) {
  var index = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index < length) {
    var entry = entries3[index];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_stackClear.js
init_esm();
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
__name(stackClear, "stackClear");
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
init_esm();
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
__name(stackDelete, "stackDelete");
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
init_esm();
function stackGet(key) {
  return this.__data__.get(key);
}
__name(stackGet, "stackGet");
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
init_esm();
function stackHas(key) {
  return this.__data__.has(key);
}
__name(stackHas, "stackHas");
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
init_esm();

// node_modules/lodash-es/_Map.js
init_esm();

// node_modules/lodash-es/_getNative.js
init_esm();

// node_modules/lodash-es/_baseIsNative.js
init_esm();

// node_modules/lodash-es/isFunction.js
init_esm();

// node_modules/lodash-es/_baseGetTag.js
init_esm();

// node_modules/lodash-es/_Symbol.js
init_esm();

// node_modules/lodash-es/_root.js
init_esm();

// node_modules/lodash-es/_freeGlobal.js
init_esm();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
init_esm();
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
init_esm();
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString2(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString2, "objectToString");
var objectToString_default = objectToString2;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObject.js
init_esm();
function isObject3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
__name(isObject3, "isObject");
var isObject_default = isObject3;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction3(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction3, "isFunction");
var isFunction_default = isFunction3;

// node_modules/lodash-es/_isMasked.js
init_esm();

// node_modules/lodash-es/_coreJsData.js
init_esm();
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
init_esm();
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
init_esm();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_MapCache.js
init_esm();

// node_modules/lodash-es/_mapCacheClear.js
init_esm();

// node_modules/lodash-es/_Hash.js
init_esm();

// node_modules/lodash-es/_hashClear.js
init_esm();

// node_modules/lodash-es/_nativeCreate.js
init_esm();
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
init_esm();
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
init_esm();
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
init_esm();
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
init_esm();
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries3) {
  var index = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index < length) {
    var entry = entries3[index];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_mapCacheDelete.js
init_esm();

// node_modules/lodash-es/_getMapData.js
init_esm();

// node_modules/lodash-es/_isKeyable.js
init_esm();
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
init_esm();
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
init_esm();
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
init_esm();
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries3) {
  var index = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index < length) {
    var entry = entries3[index];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
__name(stackSet, "stackSet");
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries3) {
  var data = this.__data__ = new ListCache_default(entries3);
  this.size = data.size;
}
__name(Stack, "Stack");
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_assignMergeValue.js
init_esm();

// node_modules/lodash-es/_baseAssignValue.js
init_esm();

// node_modules/lodash-es/_defineProperty.js
init_esm();
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
__name(baseAssignValue, "baseAssignValue");
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
__name(assignMergeValue, "assignMergeValue");
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/_baseFor.js
init_esm();

// node_modules/lodash-es/_createBaseFor.js
init_esm();
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
__name(createBaseFor, "createBaseFor");
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseMergeDeep.js
init_esm();

// node_modules/lodash-es/_cloneBuffer.js
init_esm();
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer4 = moduleExports ? root_default.Buffer : void 0;
var allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
__name(cloneBuffer, "cloneBuffer");
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_cloneTypedArray.js
init_esm();

// node_modules/lodash-es/_cloneArrayBuffer.js
init_esm();

// node_modules/lodash-es/_Uint8Array.js
init_esm();
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
__name(cloneArrayBuffer, "cloneArrayBuffer");
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
__name(cloneTypedArray, "cloneTypedArray");
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_copyArray.js
init_esm();
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
__name(copyArray, "copyArray");
var copyArray_default = copyArray;

// node_modules/lodash-es/_initCloneObject.js
init_esm();

// node_modules/lodash-es/_baseCreate.js
init_esm();
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  __name(object, "object");
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_getPrototype.js
init_esm();

// node_modules/lodash-es/_overArg.js
init_esm();
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
__name(overArg, "overArg");
var overArg_default = overArg;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/_isPrototype.js
init_esm();
var objectProto6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto6;
  return value === proto;
}
__name(isPrototype, "isPrototype");
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
__name(initCloneObject, "initCloneObject");
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/isArguments.js
init_esm();

// node_modules/lodash-es/_baseIsArguments.js
init_esm();

// node_modules/lodash-es/isObjectLike.js
init_esm();
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
__name(baseIsArguments, "baseIsArguments");
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var propertyIsEnumerable = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isArray.js
init_esm();
var isArray2 = Array.isArray;
var isArray_default = isArray2;

// node_modules/lodash-es/isArrayLikeObject.js
init_esm();

// node_modules/lodash-es/isArrayLike.js
init_esm();

// node_modules/lodash-es/isLength.js
init_esm();
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
__name(isLength, "isLength");
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike2(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
__name(isArrayLike2, "isArrayLike");
var isArrayLike_default = isArrayLike2;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
__name(isArrayLikeObject, "isArrayLikeObject");
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/isBuffer.js
init_esm();

// node_modules/lodash-es/stubFalse.js
init_esm();
function stubFalse() {
  return false;
}
__name(stubFalse, "stubFalse");
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var Buffer5 = moduleExports2 ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer5 ? Buffer5.isBuffer : void 0;
var isBuffer2 = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer2;

// node_modules/lodash-es/isPlainObject.js
init_esm();
var objectTag = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto8 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject3(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
__name(isPlainObject3, "isPlainObject");
var isPlainObject_default = isPlainObject3;

// node_modules/lodash-es/isTypedArray.js
init_esm();

// node_modules/lodash-es/_baseIsTypedArray.js
init_esm();
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag2 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
__name(baseIsTypedArray, "baseIsTypedArray");
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
init_esm();
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
__name(baseUnary, "baseUnary");
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
init_esm();
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var freeProcess = moduleExports3 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule3 && freeModule3.require && freeModule3.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray2 = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray2;

// node_modules/lodash-es/_safeGet.js
init_esm();
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
__name(safeGet, "safeGet");
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
init_esm();

// node_modules/lodash-es/_copyObject.js
init_esm();

// node_modules/lodash-es/_assignValue.js
init_esm();
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty7.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
__name(assignValue, "assignValue");
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
__name(copyObject, "copyObject");
var copyObject_default = copyObject;

// node_modules/lodash-es/keysIn.js
init_esm();

// node_modules/lodash-es/_arrayLikeKeys.js
init_esm();

// node_modules/lodash-es/_baseTimes.js
init_esm();
function baseTimes(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
__name(baseTimes, "baseTimes");
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_isIndex.js
init_esm();
var MAX_SAFE_INTEGER2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER2 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
__name(isIndex, "isIndex");
var isIndex_default = isIndex;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
__name(arrayLikeKeys, "arrayLikeKeys");
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_baseKeysIn.js
init_esm();

// node_modules/lodash-es/_nativeKeysIn.js
init_esm();
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
__name(nativeKeysIn, "nativeKeysIn");
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeysIn, "baseKeysIn");
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
__name(keysIn, "keysIn");
var keysIn_default = keysIn;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
__name(toPlainObject, "toPlainObject");
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
__name(baseMergeDeep, "baseMergeDeep");
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
__name(baseMerge, "baseMerge");
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_createAssigner.js
init_esm();

// node_modules/lodash-es/_baseRest.js
init_esm();

// node_modules/lodash-es/identity.js
init_esm();
function identity(value) {
  return value;
}
__name(identity, "identity");
var identity_default = identity;

// node_modules/lodash-es/_overRest.js
init_esm();

// node_modules/lodash-es/_apply.js
init_esm();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
__name(apply, "apply");
var apply_default = apply;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
__name(overRest, "overRest");
var overRest_default = overRest;

// node_modules/lodash-es/_setToString.js
init_esm();

// node_modules/lodash-es/_baseSetToString.js
init_esm();

// node_modules/lodash-es/constant.js
init_esm();
function constant(value) {
  return function() {
    return value;
  };
}
__name(constant, "constant");
var constant_default = constant;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_shortOut.js
init_esm();
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
__name(shortOut, "shortOut");
var shortOut_default = shortOut;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
__name(baseRest, "baseRest");
var baseRest_default = baseRest;

// node_modules/lodash-es/_isIterateeCall.js
init_esm();
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
__name(isIterateeCall, "isIterateeCall");
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
__name(createAssigner, "createAssigner");
var createAssigner_default = createAssigner;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/transloadit/dist/alphalib/templateMerge.js
function mergeTemplateContent(template, params) {
  const templateContent = structuredClone(template);
  const templateRecord = templateContent;
  if (templateContent.allow_steps_override == null) {
    templateContent.allow_steps_override = true;
  }
  if (params?.steps != null && templateContent.allow_steps_override === false) {
    throw new Error("TEMPLATE_DENIES_STEPS_OVERRIDE");
  }
  if (params == null) {
    return templateContent;
  }
  const paramsRecord = { ...params };
  for (const key of Object.keys(templateRecord)) {
    if (paramsRecord[key] === null && templateRecord[key] !== null) {
      paramsRecord[key] = templateRecord[key];
    }
  }
  return merge_default({}, templateRecord, paramsRecord);
}
__name(mergeTemplateContent, "mergeTemplateContent");

// node_modules/transloadit/dist/lintAssemblyInput.js
var DEFAULT_INDENT = "  ";
var isRecord2 = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null && !Array.isArray(value), "isRecord");
var unwrapStepsOnly = /* @__PURE__ */ __name((content, indent) => {
  try {
    const parsed = JSON.parse(content);
    if (isRecord2(parsed) && "steps" in parsed) {
      return JSON.stringify(parsed.steps ?? {}, null, indent);
    }
  } catch (_err) {
    return content;
  }
  return content;
}, "unwrapStepsOnly");
var buildLintInput = /* @__PURE__ */ __name((assemblyInstructions, template) => {
  let inputString;
  let parsedInput;
  let parseFailed = false;
  let indent = DEFAULT_INDENT;
  if (typeof assemblyInstructions === "string") {
    inputString = assemblyInstructions;
    indent = getIndentation(assemblyInstructions);
    try {
      parsedInput = JSON.parse(assemblyInstructions);
    } catch (_err) {
      parseFailed = true;
    }
  } else if (assemblyInstructions != null) {
    parsedInput = assemblyInstructions;
  }
  let wasStepsOnly = false;
  let instructions;
  if (parsedInput !== void 0) {
    if (isRecord2(parsedInput)) {
      if ("steps" in parsedInput) {
        instructions = parsedInput;
      } else {
        instructions = { steps: parsedInput };
        wasStepsOnly = true;
      }
    } else {
      instructions = { steps: parsedInput };
      wasStepsOnly = true;
    }
  }
  const shouldMergeTemplate = template != null && !parseFailed;
  if (shouldMergeTemplate) {
    instructions = mergeTemplateContent(template, instructions);
  }
  let lintContent = "";
  if (instructions != null) {
    if (typeof assemblyInstructions === "string" && !wasStepsOnly && !parseFailed && !shouldMergeTemplate) {
      lintContent = assemblyInstructions;
    } else {
      lintContent = JSON.stringify(instructions, null, indent);
    }
  } else if (inputString != null) {
    lintContent = inputString;
  }
  return { lintContent, wasStepsOnly, indent };
}, "buildLintInput");

// node_modules/transloadit/dist/lintAssemblyInstructions.js
async function lintAssemblyInstructions(options) {
  const { assemblyInstructions, template, fix = false, fatal = "error" } = options;
  if (assemblyInstructions == null && template == null) {
    throw new Error("Provide assemblyInstructions or template content to lint.");
  }
  const { lintContent, wasStepsOnly, indent } = buildLintInput(assemblyInstructions, template);
  let issues = await parseAndLint(lintContent);
  let fixedContent = lintContent;
  if (fix) {
    for (const issue of issues) {
      if (!issue.fixId)
        continue;
      fixedContent = applyFix(fixedContent, issue.fixId, issue.fixData);
    }
    issues = await parseAndLint(fixedContent);
  }
  const describedIssues = hydrateLintIssues(issues);
  const fatalTypes = fatal === "warning" ? /* @__PURE__ */ new Set(["warning", "error"]) : /* @__PURE__ */ new Set(["error"]);
  const success = !describedIssues.some((issue) => fatalTypes.has(issue.type));
  const result = {
    success,
    issues: describedIssues
  };
  if (fix) {
    result.fixedInstructions = wasStepsOnly ? unwrapStepsOnly(fixedContent, indent) : fixedContent;
  }
  return result;
}
__name(lintAssemblyInstructions, "lintAssemblyInstructions");

// node_modules/transloadit/dist/PaginationStream.js
init_esm();
import { Readable } from "node:stream";
var PaginationStream = class extends Readable {
  static {
    __name(this, "PaginationStream");
  }
  _fetchPage;
  _nitems;
  _pageno = 0;
  _items = [];
  _itemsRead = 0;
  constructor(fetchPage) {
    super({ objectMode: true });
    this._fetchPage = fetchPage;
  }
  async _read() {
    if (this._items.length > 0) {
      this._itemsRead++;
      process.nextTick(() => this.push(this._items.pop()));
      return;
    }
    if (this._nitems != null && this._itemsRead >= this._nitems) {
      process.nextTick(() => this.push(null));
      return;
    }
    try {
      const { items, ...rest } = await this._fetchPage(++this._pageno);
      if ("count" in rest) {
        this._nitems = rest.count;
      }
      if (items.length === 0) {
        process.nextTick(() => this.push(null));
        return;
      }
      this._items = Array.from(items);
      this._items.reverse();
      this._read();
    } catch (err) {
      this.emit("error", err);
    }
  }
};

// node_modules/transloadit/dist/PollingTimeoutError.js
init_esm();
var PollingTimeoutError = class extends Error {
  static {
    __name(this, "PollingTimeoutError");
  }
  name = "PollingTimeoutError";
  code = "POLLING_TIMED_OUT";
};

// node_modules/transloadit/dist/tus.js
init_esm();
var import_debug = __toESM(require_src(), 1);
import { stat } from "node:fs/promises";
import { basename } from "node:path";
var import_tus_js_client = __toESM(require_node2(), 1);
var log = (0, import_debug.default)("transloadit");
var logWarn = (0, import_debug.default)("transloadit:warn");
async function sendTusRequest({ streamsMap, assembly, requestedChunkSize, uploadConcurrency, onProgress, signal, uploadUrls, uploadBehavior = "await" }) {
  const streamLabels = Object.keys(streamsMap);
  let totalBytes = 0;
  let lastEmittedProgress = 0;
  const sizes = {};
  const uploadUrlsResult = { ...uploadUrls ?? {} };
  const haveUnknownLengthStreams = streamLabels.some((label) => !streamsMap[label]?.path);
  await pMap(streamLabels, async (label) => {
    if (signal?.aborted)
      throw new Error("Upload aborted");
    const streamInfo = streamsMap[label];
    if (!streamInfo) {
      throw new Error(`Stream info not found for label: ${label}`);
    }
    const { path: path2 } = streamInfo;
    if (path2) {
      const { size } = await stat(path2);
      sizes[label] = size;
      totalBytes += size;
    }
  }, { concurrency: 5, signal });
  const uploadProgresses = {};
  const completionPromises = [];
  const uploadUrlPromises = [];
  async function uploadSingleStream(label) {
    uploadProgresses[label] = 0;
    const streamInfo = streamsMap[label];
    if (!streamInfo) {
      throw new Error(`Stream info not found for label: ${label}`);
    }
    const { stream: stream2, path: path2 } = streamInfo;
    const size = sizes[label];
    let chunkSize = requestedChunkSize;
    let uploadLengthDeferred;
    const isStreamLengthKnown = !!path2;
    if (!isStreamLengthKnown) {
      uploadLengthDeferred = true;
      if (chunkSize === Number.POSITIVE_INFINITY)
        chunkSize = 5e7;
    }
    const onTusProgress = /* @__PURE__ */ __name((bytesUploaded) => {
      uploadProgresses[label] = bytesUploaded;
      let uploadedBytes = 0;
      for (const l of streamLabels) {
        uploadedBytes += uploadProgresses[l] ?? 0;
      }
      if (lastEmittedProgress < uploadedBytes) {
        lastEmittedProgress = uploadedBytes;
        onProgress({
          uploadedBytes,
          totalBytes: haveUnknownLengthStreams ? void 0 : totalBytes
        });
      }
    }, "onTusProgress");
    const filename = path2 ? basename(path2) : label;
    if (uploadBehavior === "none" && uploadUrls?.[label]) {
      uploadUrlsResult[label] = uploadUrls[label];
      uploadUrlPromises.push(Promise.resolve());
      completionPromises.push(Promise.resolve());
      return;
    }
    let urlResolved = false;
    let resolveUrl = /* @__PURE__ */ __name(() => {
    }, "resolveUrl");
    let rejectUrl = /* @__PURE__ */ __name(() => {
    }, "rejectUrl");
    const uploadUrlPromise = new Promise((resolve, reject) => {
      resolveUrl = /* @__PURE__ */ __name(() => {
        if (urlResolved)
          return;
        urlResolved = true;
        resolve();
      }, "resolveUrl");
      rejectUrl = /* @__PURE__ */ __name((err) => {
        if (urlResolved)
          return;
        urlResolved = true;
        reject(err);
      }, "rejectUrl");
    });
    let resolveCompletion = /* @__PURE__ */ __name(() => {
    }, "resolveCompletion");
    let rejectCompletion = /* @__PURE__ */ __name(() => {
    }, "rejectCompletion");
    const completionPromise = new Promise((resolve, reject) => {
      resolveCompletion = resolve;
      rejectCompletion = reject;
    });
    uploadUrlPromises.push(uploadUrlPromise);
    completionPromises.push(completionPromise);
    if (uploadUrls?.[label]) {
      uploadUrlsResult[label] = uploadUrls[label];
      resolveUrl();
    }
    const startPromise = new Promise((resolvePromise, rejectPromise) => {
      if (!assembly.assembly_ssl_url) {
        rejectPromise(new Error("assembly_ssl_url is not present in the assembly status"));
        return;
      }
      if (signal?.aborted) {
        rejectPromise(new Error("Upload aborted"));
        return;
      }
      let abortHandler;
      const resolve = /* @__PURE__ */ __name((_payload) => {
        if (abortHandler)
          signal?.removeEventListener("abort", abortHandler);
        resolveCompletion();
        resolveUrl();
        resolvePromise();
      }, "resolve");
      const reject = /* @__PURE__ */ __name((err) => {
        if (abortHandler)
          signal?.removeEventListener("abort", abortHandler);
        rejectCompletion(err);
        rejectUrl(err);
        rejectPromise(err);
      }, "reject");
      let tusUpload;
      const tusOptions = {
        endpoint: assembly.tus_url,
        uploadUrl: uploadUrls?.[label],
        metadata: {
          assembly_url: assembly.assembly_ssl_url,
          fieldname: label,
          filename
        },
        onError: reject,
        onProgress: onTusProgress,
        onSuccess: resolve,
        onUploadUrlAvailable: /* @__PURE__ */ __name(() => {
          const url = tusUpload?.url;
          if (url) {
            uploadUrlsResult[label] = url;
          }
          resolveUrl();
          if (uploadBehavior === "none") {
            tusUpload.abort();
            resolveCompletion();
          }
        }, "onUploadUrlAvailable")
      };
      if (size != null)
        tusOptions.uploadSize = size;
      if (chunkSize)
        tusOptions.chunkSize = chunkSize;
      if (uploadLengthDeferred)
        tusOptions.uploadLengthDeferred = uploadLengthDeferred;
      tusUpload = new import_tus_js_client.Upload(stream2, tusOptions);
      if (signal) {
        abortHandler = /* @__PURE__ */ __name(() => {
          tusUpload.abort();
          reject(new Error("Upload aborted"));
        }, "abortHandler");
        signal.addEventListener("abort", abortHandler, { once: true });
      }
      tusUpload.start();
    });
    if (uploadBehavior === "await") {
      await startPromise;
      log(label, "upload done");
      return;
    }
    startPromise.catch((err) => {
      logWarn("Background upload failed", err);
    });
    await uploadUrlPromise;
    log(label, "upload started");
  }
  __name(uploadSingleStream, "uploadSingleStream");
  await pMap(streamLabels, uploadSingleStream, { concurrency: uploadConcurrency, signal });
  await Promise.all(uploadUrlPromises);
  if (uploadBehavior === "await") {
    await Promise.all(completionPromises);
  } else {
    Promise.allSettled(completionPromises).catch((err) => {
      logWarn("Background upload failed", err);
    });
  }
  return { uploadUrls: uploadUrlsResult };
}
__name(sendTusRequest, "sendTusRequest");

// node_modules/transloadit/dist/apiTypes.js
init_esm();

// node_modules/transloadit/dist/inputFiles.js
init_esm();

// node_modules/transloadit/dist/robots.js
init_esm();

// node_modules/transloadit/dist/Transloadit.js
var log2 = (0, import_debug2.default)("transloadit");
var logWarn2 = (0, import_debug2.default)("transloadit:warn");
var { version } = package_default;
var getUploadKey = /* @__PURE__ */ __name((fieldname, filename, size) => {
  if (!fieldname || !filename || size == null)
    return null;
  return JSON.stringify([fieldname, filename, size]);
}, "getUploadKey");
var getSizeFromValue = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string")
    return Buffer.byteLength(value);
  if (Buffer.isBuffer(value))
    return value.length;
  if (value instanceof ArrayBuffer)
    return value.byteLength;
  if (ArrayBuffer.isView(value))
    return value.byteLength;
  return void 0;
}, "getSizeFromValue");
var toReadableUpload = /* @__PURE__ */ __name((label, value) => {
  const readable = isReadableStream2(value);
  if (!readable && isStream2(value)) {
    throw new Error(`Upload named "${label}" is not a Readable stream`);
  }
  return readable ? value : into_stream_default(value);
}, "toReadableUpload");
var buildStreamsMap = /* @__PURE__ */ __name((descriptors) => Object.fromEntries(descriptors.map((descriptor) => {
  if (descriptor.path) {
    const stream3 = createReadStream(descriptor.path);
    return [descriptor.label, { stream: stream3, path: descriptor.path }];
  }
  const value = descriptor.value;
  if (value == null) {
    throw new Error(`Upload named "${descriptor.label}" has no data`);
  }
  const stream2 = toReadableUpload(descriptor.label, value);
  return [descriptor.label, { stream: stream2 }];
})), "buildStreamsMap");
var pauseStreams = /* @__PURE__ */ __name((streamsMap) => {
  for (const { stream: stream2 } of Object.values(streamsMap)) {
    stream2.pause();
  }
}, "pauseStreams");
var createStreamErrorPromise = /* @__PURE__ */ __name((streamsMap) => {
  const promise = new Promise((_resolve, reject) => {
    for (const { stream: stream2 } of Object.values(streamsMap)) {
      stream2.on("error", reject);
    }
  });
  promise.catch(() => {
  });
  return promise;
}, "createStreamErrorPromise");
function checkAssemblyUrls(result) {
  if (result.assembly_url == null || result.assembly_ssl_url == null) {
    throw new InconsistentResponseError("Server returned an incomplete assembly response (no URL)");
  }
}
__name(checkAssemblyUrls, "checkAssemblyUrls");
function getHrTimeMs() {
  return Number(process.hrtime.bigint() / 1000000n);
}
__name(getHrTimeMs, "getHrTimeMs");
function getAssemblyIdFromUrl(assemblyUrl) {
  const match = assemblyUrl.match(/\/assemblies\/([^/?#]+)/);
  if (!match) {
    throw new Error(`Invalid assembly URL: ${assemblyUrl}`);
  }
  return match[1] ?? "";
}
__name(getAssemblyIdFromUrl, "getAssemblyIdFromUrl");
function checkResult(result) {
  if (typeof result === "object" && result !== null && "error" in result && typeof result.error === "string") {
    throw new ApiError({ body: result });
  }
}
__name(checkResult, "checkResult");
var Transloadit = class {
  static {
    __name(this, "Transloadit");
  }
  _authKey;
  _authSecret;
  _authToken;
  _endpoint;
  _maxRetries;
  _defaultTimeout;
  _gotRetry;
  _clientName;
  _lastUsedAssemblyUrl = "";
  _validateResponses = false;
  constructor(opts) {
    const rawToken = typeof opts?.authToken === "string" ? opts.authToken.trim() : "";
    const hasToken = rawToken.length > 0;
    if (opts.endpoint?.endsWith("/")) {
      throw new Error("Trailing slash in endpoint is not allowed");
    }
    if (!hasToken) {
      if (opts?.authKey == null) {
        throw new Error("Please provide an authKey");
      }
      if (opts.authSecret == null) {
        throw new Error("Please provide an authSecret");
      }
    }
    this._authKey = opts.authKey ?? "";
    this._authSecret = opts.authSecret ?? "";
    this._authToken = hasToken ? rawToken : null;
    this._endpoint = opts.endpoint || "https://api2.transloadit.com";
    this._maxRetries = opts.maxRetries != null ? opts.maxRetries : 5;
    this._defaultTimeout = opts.timeout != null ? opts.timeout : 6e4;
    this._clientName = opts.clientName?.trim() || `node-sdk:${version}`;
    this._gotRetry = opts.gotRetry != null ? opts.gotRetry : { limit: 0 };
    if (opts.validateResponses != null)
      this._validateResponses = opts.validateResponses;
  }
  getLastUsedAssemblyUrl() {
    return this._lastUsedAssemblyUrl;
  }
  setDefaultTimeout(timeout) {
    this._defaultTimeout = timeout;
  }
  /**
   * Create an Assembly
   *
   * @param opts assembly options
   */
  createAssembly(opts = {}) {
    const {
      params = {},
      waitForCompletion = false,
      chunkSize: requestedChunkSize = Number.POSITIVE_INFINITY,
      uploadConcurrency = 10,
      timeout = 24 * 60 * 60 * 1e3,
      // 1 day
      onUploadProgress = /* @__PURE__ */ __name(() => {
      }, "onUploadProgress"),
      onAssemblyProgress = /* @__PURE__ */ __name(() => {
      }, "onAssemblyProgress"),
      files = {},
      uploads = {},
      assemblyId,
      expectedUploads,
      signal,
      uploadBehavior = "await"
    } = opts;
    const startTimeMs = getHrTimeMs();
    let effectiveAssemblyId;
    if (assemblyId != null) {
      effectiveAssemblyId = assemblyId;
    } else {
      effectiveAssemblyId = randomUUID().replace(/-/g, "");
    }
    const urlSuffix = `/assemblies/${effectiveAssemblyId}`;
    const promise = (async () => {
      this._lastUsedAssemblyUrl = `${this._endpoint}${urlSuffix}`;
      await pMap(Object.entries(files), async ([, path2]) => access(path2, constants.F_OK | constants.R_OK), { concurrency: 5 });
      const descriptors = [
        ...Object.entries(files).map(([label, path2]) => ({
          label,
          path: path2,
          filename: basename2(path2)
        })),
        ...Object.entries(uploads).map(([label, value]) => ({
          label,
          filename: label,
          value
        }))
      ];
      const allStreamsMap = buildStreamsMap(descriptors);
      const allStreams = Object.values(allStreamsMap);
      pauseStreams(allStreamsMap);
      const streamErrorPromise = createStreamErrorPromise(allStreamsMap);
      const createAssemblyAndUpload = /* @__PURE__ */ __name(async () => {
        const totalExpectedUploads = expectedUploads == null ? allStreams.length : Math.max(expectedUploads, allStreams.length);
        const result = await this._remoteJson({
          urlSuffix,
          method: "post",
          timeout: { request: timeout },
          params,
          fields: {
            tus_num_expected_upload_files: totalExpectedUploads
          },
          signal
        });
        checkResult(result);
        if (Object.keys(allStreamsMap).length > 0) {
          const { uploadUrls } = await sendTusRequest({
            streamsMap: allStreamsMap,
            assembly: result,
            onProgress: onUploadProgress,
            requestedChunkSize,
            uploadConcurrency,
            signal,
            uploadBehavior
          });
          if (uploadBehavior !== "await" && Object.keys(uploadUrls).length > 0) {
            result.upload_urls = uploadUrls;
          }
        }
        const shouldWaitForCompletion = waitForCompletion && uploadBehavior === "await";
        if (!shouldWaitForCompletion)
          return result;
        if (result.assembly_id == null) {
          throw new InconsistentResponseError("Server returned an assembly response without an assembly_id after creation");
        }
        const awaitResult = await this.awaitAssemblyCompletion(result.assembly_id, {
          timeout,
          onAssemblyProgress,
          startTimeMs,
          signal
        });
        checkResult(awaitResult);
        return awaitResult;
      }, "createAssemblyAndUpload");
      return Promise.race([createAssemblyAndUpload(), streamErrorPromise]);
    })();
    return Object.assign(promise, { assemblyId: effectiveAssemblyId });
  }
  /**
   * Lint Assembly Instructions locally.
   *
   * If a templateId is provided, the template content is merged with the instructions,
   * just like the API. When a template sets `allow_steps_override=false`, providing
   * `steps` will throw a TEMPLATE_DENIES_STEPS_OVERRIDE error.
   *
   * The `assemblyInstructions` input may be a JSON string, a full instructions object,
   * or a steps-only object (missing the `steps` property).
   */
  async lintAssemblyInstructions(options) {
    const { templateId, ...rest } = options;
    if (!templateId) {
      return await lintAssemblyInstructions(rest);
    }
    const template = await this.getTemplate(templateId);
    return await lintAssemblyInstructions({
      ...rest,
      template: template.content
    });
  }
  /**
   * Mint a short-lived bearer token via POST /token.
   *
   * This uses HTTP Basic Auth (authKey + authSecret) and can optionally request a narrowed scope.
   * If `scope` is omitted, the token inherits the auth key's scope.
   */
  async mintBearerToken(options = {}) {
    if (this._authToken) {
      throw new Error("Cannot mint bearer tokens when using authToken authentication. Provide authKey + authSecret instead.");
    }
    const result = await mintBearerTokenWithCredentials({ authKey: this._authKey, authSecret: this._authSecret }, {
      ...options,
      endpoint: options.endpoint ?? this._endpoint
    });
    if (!result.ok) {
      throw new Error(result.error);
    }
    return result.data;
  }
  async resumeAssemblyUploads(opts) {
    const {
      assemblyUrl,
      files = {},
      uploads = {},
      chunkSize: requestedChunkSize = Number.POSITIVE_INFINITY,
      uploadConcurrency = 10,
      timeout = 24 * 60 * 60 * 1e3,
      // 1 day
      waitForCompletion = false,
      onUploadProgress = /* @__PURE__ */ __name(() => {
      }, "onUploadProgress"),
      onAssemblyProgress = /* @__PURE__ */ __name(() => {
      }, "onAssemblyProgress"),
      signal,
      uploadBehavior = "await"
    } = opts;
    const startTimeMs = getHrTimeMs();
    getAssemblyIdFromUrl(assemblyUrl);
    const assembly = await this._fetchAssemblyStatus({
      url: assemblyUrl,
      signal
    });
    const statusUrl = assembly.assembly_ssl_url ?? assembly.assembly_url ?? assemblyUrl;
    const finishedKeys = /* @__PURE__ */ new Set();
    for (const upload of assembly.uploads ?? []) {
      const key = getUploadKey(upload.field ?? null, upload.basename ?? null, upload.size);
      if (key)
        finishedKeys.add(key);
    }
    for (const upload of assembly.tus_uploads ?? []) {
      if (!upload.finished)
        continue;
      const key = getUploadKey(upload.fieldname, upload.filename, upload.size);
      if (key)
        finishedKeys.add(key);
    }
    const resumeUrls = /* @__PURE__ */ new Map();
    for (const upload of assembly.tus_uploads ?? []) {
      if (upload.finished)
        continue;
      if (!upload.upload_url)
        continue;
      const key = getUploadKey(upload.fieldname, upload.filename, upload.size);
      if (key)
        resumeUrls.set(key, upload.upload_url);
    }
    const descriptors = [];
    await pMap(Object.entries(files), async ([label, path2]) => {
      await access(path2, constants.F_OK | constants.R_OK);
      const info = await stat2(path2);
      descriptors.push({
        label,
        path: path2,
        filename: basename2(path2),
        size: info.size
      });
    }, { concurrency: 5 });
    for (const [label, value] of Object.entries(uploads)) {
      descriptors.push({
        label,
        filename: label,
        size: isReadableStream2(value) ? void 0 : getSizeFromValue(value),
        value
      });
    }
    const descriptorsToUpload = descriptors.filter((descriptor) => {
      const key = getUploadKey(descriptor.label, descriptor.filename, descriptor.size ?? null);
      return key ? !finishedKeys.has(key) : true;
    });
    const uploadUrlsByLabel = {};
    for (const descriptor of descriptorsToUpload) {
      if (!descriptor.path)
        continue;
      const key = getUploadKey(descriptor.label, descriptor.filename, descriptor.size ?? null);
      if (!key)
        continue;
      const uploadUrl = resumeUrls.get(key);
      if (uploadUrl)
        uploadUrlsByLabel[descriptor.label] = uploadUrl;
    }
    const streamsMap = buildStreamsMap(descriptorsToUpload);
    pauseStreams(streamsMap);
    if (Object.keys(streamsMap).length > 0) {
      const streamErrorPromise = createStreamErrorPromise(streamsMap);
      const uploadPromise = sendTusRequest({
        streamsMap,
        assembly,
        requestedChunkSize,
        uploadConcurrency,
        onProgress: onUploadProgress,
        signal,
        uploadUrls: uploadUrlsByLabel,
        uploadBehavior
      });
      await Promise.race([uploadPromise, streamErrorPromise]);
      const { uploadUrls } = await uploadPromise;
      if (uploadBehavior !== "await" && Object.keys(uploadUrls).length > 0) {
        assembly.upload_urls = uploadUrls;
      }
    }
    const latestAssembly = await this._fetchAssemblyStatus({
      url: statusUrl,
      signal
    });
    if (uploadBehavior !== "await" && assembly.upload_urls) {
      latestAssembly.upload_urls = assembly.upload_urls;
    }
    const shouldWaitForCompletion = waitForCompletion && uploadBehavior === "await";
    if (!shouldWaitForCompletion)
      return latestAssembly;
    if (latestAssembly.assembly_id == null) {
      throw new InconsistentResponseError("Server returned an assembly response without an assembly_id after resuming uploads");
    }
    const awaitResult = await this.awaitAssemblyCompletion(latestAssembly.assembly_id, {
      timeout,
      onAssemblyProgress,
      startTimeMs,
      assemblyUrl: statusUrl,
      signal
    });
    checkResult(awaitResult);
    return awaitResult;
  }
  async awaitAssemblyCompletion(assemblyId, { onAssemblyProgress = /* @__PURE__ */ __name(() => {
  }, "onAssemblyProgress"), timeout, startTimeMs = getHrTimeMs(), interval = 1e3, assemblyUrl, signal, onPoll } = {}) {
    assert2.ok(assemblyId);
    let lastResult;
    const fetchAssemblyStatus = /* @__PURE__ */ __name(() => {
      return assemblyUrl ? this._fetchAssemblyStatus({ url: assemblyUrl, signal }) : this.getAssembly(assemblyId, { signal });
    }, "fetchAssemblyStatus");
    while (true) {
      if (onPoll?.() === false && lastResult) {
        return lastResult;
      }
      if (signal?.aborted) {
        throw signal.reason ?? new DOMException("Aborted", "AbortError");
      }
      const result = await fetchAssemblyStatus();
      lastResult = result;
      if (!("ok" in result) || result.ok !== "ASSEMBLY_UPLOADING" && result.ok !== "ASSEMBLY_EXECUTING" && // ASSEMBLY_REPLAYING is not a valid 'ok' status for polling, it means it's done replaying.
      // The API does not seem to have an ASSEMBLY_REPLAYING status in the typical polling loop.
      // It's usually a final status from the replay endpoint.
      // For polling, we only care about UPLOADING and EXECUTING.
      // If a replay operation puts it into a pollable state, that state would be EXECUTING.
      result.ok !== "ASSEMBLY_REPLAYING") {
        return result;
      }
      try {
        onAssemblyProgress(result);
      } catch (err) {
        log2("Caught onAssemblyProgress error", err);
      }
      const nowMs = getHrTimeMs();
      if (timeout != null && nowMs - startTimeMs >= timeout) {
        throw new PollingTimeoutError("Polling timed out");
      }
      await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          signal?.removeEventListener("abort", onAbort);
          resolve();
        }, interval);
        function onAbort() {
          clearTimeout(timeoutId);
          reject(signal?.reason ?? new DOMException("Aborted", "AbortError"));
        }
        __name(onAbort, "onAbort");
        signal?.addEventListener("abort", onAbort, { once: true });
      });
    }
  }
  maybeThrowInconsistentResponseError(message) {
    const err = new InconsistentResponseError(message);
    if (this._validateResponses) {
      throw err;
    }
    console.error(`---
Please report this error to Transloadit (support@transloadit.com). We are working on better schemas for our API and this looks like something we do not cover yet: 

${err}
Thank you in advance!
---
`);
  }
  /**
   * Cancel the assembly
   *
   * @param assemblyId assembly ID
   * @returns after the assembly is deleted
   */
  async cancelAssembly(assemblyId) {
    const { assembly_ssl_url: url } = await this.getAssembly(assemblyId);
    const rawResult = await this._remoteJson({
      url,
      isTrustedUrl: true,
      method: "delete"
    });
    const parsedResult = zodParseWithContext(assemblyStatusSchema, rawResult);
    if (!parsedResult.success) {
      this.maybeThrowInconsistentResponseError(`The API responded with data that does not match the expected schema while cancelling Assembly: ${assemblyId}.
${parsedResult.humanReadable}`);
    }
    checkAssemblyUrls(rawResult);
    return rawResult;
  }
  /**
   * Replay an Assembly
   *
   * @param assemblyId of the assembly to replay
   * @param optional params
   * @returns after the replay is started
   */
  async replayAssembly(assemblyId, params = {}) {
    const result = await this._remoteJson({
      urlSuffix: `/assemblies/${assemblyId}/replay`,
      method: "post",
      ...Object.keys(params).length > 0 && { params }
    });
    checkResult(result);
    return result;
  }
  /**
   * Replay an Assembly notification
   *
   * @param assemblyId of the assembly whose notification to replay
   * @param optional params
   * @returns after the replay is started
   */
  async replayAssemblyNotification(assemblyId, params = {}) {
    return await this._remoteJson({
      urlSuffix: `/assembly_notifications/${assemblyId}/replay`,
      method: "post",
      ...Object.keys(params).length > 0 && { params }
    });
  }
  /**
   * List all assemblies
   *
   * @param params optional request options
   * @returns list of Assemblies
   */
  async listAssemblies(params) {
    const rawResponse = await this._remoteJson({
      urlSuffix: "/assemblies",
      method: "get",
      params: params || {}
    });
    if (rawResponse == null || typeof rawResponse !== "object" || !Array.isArray(rawResponse.items)) {
      throw new InconsistentResponseError("API response for listAssemblies is malformed or missing items array");
    }
    const parsedResult = zodParseWithContext(assemblyIndexSchema, rawResponse.items);
    if (!parsedResult.success) {
      this.maybeThrowInconsistentResponseError(`API response for listAssemblies contained items that do not match the expected schema.
${parsedResult.humanReadable}`);
    }
    return {
      items: rawResponse.items,
      count: rawResponse.count
    };
  }
  streamAssemblies(params) {
    return new PaginationStream(async (page) => this.listAssemblies({ ...params, page }));
  }
  /**
   * Get an Assembly
   *
   * @param assemblyId the Assembly Id
   * @param options optional request options
   * @returns the retrieved Assembly
   */
  async getAssembly(assemblyId, options) {
    return await this._fetchAssemblyStatus({
      assemblyId,
      signal: options?.signal
    });
  }
  async _fetchAssemblyStatus({ assemblyId, url, signal }) {
    const rawResult = await this._remoteJson({
      url,
      urlSuffix: url ? void 0 : `/assemblies/${assemblyId}`,
      isTrustedUrl: Boolean(url),
      signal
    });
    const parsedResult = zodParseWithContext(assemblyStatusSchema, rawResult);
    if (!parsedResult.success) {
      const label = assemblyId ?? url ?? "unknown";
      this.maybeThrowInconsistentResponseError(`The API responded with data that does not match the expected schema while getting Assembly: ${label}.
${parsedResult.humanReadable}`);
    }
    checkAssemblyUrls(rawResult);
    return rawResult;
  }
  /**
   * Create a Credential
   *
   * @param params optional request options
   * @returns when the Credential is created
   */
  async createTemplateCredential(params) {
    return await this._remoteJson({
      urlSuffix: "/template_credentials",
      method: "post",
      params: params || {}
    });
  }
  /**
   * Edit a Credential
   *
   * @param credentialId the Credential ID
   * @param params optional request options
   * @returns when the Credential is edited
   */
  async editTemplateCredential(credentialId, params) {
    return await this._remoteJson({
      urlSuffix: `/template_credentials/${credentialId}`,
      method: "put",
      params: params || {}
    });
  }
  /**
   * Delete a Credential
   *
   * @param credentialId the Credential ID
   * @returns when the Credential is deleted
   */
  async deleteTemplateCredential(credentialId) {
    return await this._remoteJson({
      urlSuffix: `/template_credentials/${credentialId}`,
      method: "delete"
    });
  }
  /**
   * Get a Credential
   *
   * @param credentialId the Credential ID
   * @returns when the Credential is retrieved
   */
  async getTemplateCredential(credentialId) {
    return await this._remoteJson({
      urlSuffix: `/template_credentials/${credentialId}`,
      method: "get"
    });
  }
  /**
   * List all TemplateCredentials
   *
   * @param params optional request options
   * @returns the list of templates
   */
  async listTemplateCredentials(params) {
    return await this._remoteJson({
      urlSuffix: "/template_credentials",
      method: "get",
      params: params || {}
    });
  }
  streamTemplateCredentials(params) {
    return new PaginationStream(async (page) => ({
      items: (await this.listTemplateCredentials({ ...params, page })).credentials
    }));
  }
  /**
   * Create an Assembly Template
   *
   * @param params optional request options
   * @returns when the template is created
   */
  async createTemplate(params) {
    return await this._remoteJson({
      urlSuffix: "/templates",
      method: "post",
      params: params || {}
    });
  }
  /**
   * Edit an Assembly Template
   *
   * @param templateId the template ID
   * @param params optional request options
   * @returns when the template is edited
   */
  async editTemplate(templateId, params) {
    return await this._remoteJson({
      urlSuffix: `/templates/${templateId}`,
      method: "put",
      params: params || {}
    });
  }
  /**
   * Delete an Assembly Template
   *
   * @param templateId the template ID
   * @returns when the template is deleted
   */
  async deleteTemplate(templateId) {
    return await this._remoteJson({
      urlSuffix: `/templates/${templateId}`,
      method: "delete"
    });
  }
  /**
   * Get an Assembly Template
   *
   * @param templateId the template ID
   * @returns when the template is retrieved
   */
  async getTemplate(templateId) {
    return await this._remoteJson({
      urlSuffix: `/templates/${templateId}`,
      method: "get"
    });
  }
  /**
   * List all Assembly Templates
   *
   * @param params optional request options
   * @returns the list of templates
   */
  async listTemplates(params) {
    return await this._remoteJson({
      urlSuffix: "/templates",
      method: "get",
      params: params || {}
    });
  }
  streamTemplates(params) {
    return new PaginationStream(async (page) => this.listTemplates({ ...params, page }));
  }
  /**
   * Get account Billing details for a specific month
   *
   * @param month the date for the required billing in the format yyyy-mm
   * @returns with billing data
   * @see https://transloadit.com/docs/api/bill-date-get/
   */
  async getBill(month) {
    assert2.ok(month, "month is required");
    return await this._remoteJson({
      urlSuffix: `/bill/${month}`,
      method: "get"
    });
  }
  calcSignature(params, algorithm) {
    if (!this._authKey || !this._authSecret) {
      throw new Error("Cannot sign params without authKey and authSecret.");
    }
    const jsonParams = this._prepareParams(params);
    const signature = this._calcSignature(jsonParams, algorithm);
    return { signature, params: jsonParams };
  }
  /**
   * Construct a signed Smart CDN URL. See https://transloadit.com/docs/topics/signature-authentication/#smart-cdn.
   */
  getSignedSmartCDNUrl(opts) {
    if (!this._authKey || !this._authSecret) {
      throw new Error("authKey and authSecret are required to sign Smart CDN URLs.");
    }
    return getSignedSmartCdnUrl({
      ...opts,
      authKey: this._authKey,
      authSecret: this._authSecret
    });
  }
  _calcSignature(toSign, algorithm = "sha384") {
    if (!this._authSecret) {
      throw new Error("Cannot sign params without authSecret.");
    }
    return signParamsSync(toSign, this._authSecret, algorithm);
  }
  // Sets the multipart/form-data for POST, PUT and DELETE requests, including
  // the streams, the signed params, and any additional fields.
  _appendForm(form, params, fields) {
    const shouldSign = Boolean(this._authKey && this._authSecret);
    let jsonParams = JSON.stringify(params ?? {});
    let signature;
    if (shouldSign) {
      const sigData = this.calcSignature(params);
      jsonParams = sigData.params;
      signature = sigData.signature;
    }
    form.append("params", jsonParams);
    if (fields != null) {
      for (const [key, val] of Object.entries(fields)) {
        form.append(key, val);
      }
    }
    if (signature) {
      form.append("signature", signature);
    }
  }
  // Implements HTTP GET query params, handling the case where the url already
  // has params.
  _appendParamsToUrl(url, params) {
    const prefix = url.indexOf("?") === -1 ? "?" : "&";
    const shouldSign = Boolean(this._authKey && this._authSecret);
    if (!shouldSign) {
      const jsonParams2 = JSON.stringify(params ?? {});
      return `${url}${prefix}params=${encodeURIComponent(jsonParams2)}`;
    }
    const { signature, params: jsonParams } = this.calcSignature(params);
    return `${url}${prefix}signature=${signature}&params=${encodeURIComponent(jsonParams)}`;
  }
  // Responsible for including auth parameters in all requests
  _prepareParams(paramsIn) {
    let params = paramsIn;
    if (params == null) {
      params = {};
    }
    if (params.auth == null) {
      params.auth = {};
    }
    if (params.auth.key == null) {
      params.auth.key = this._authKey;
    }
    if (params.auth.expires == null) {
      params.auth.expires = this._getExpiresDate();
    }
    return JSON.stringify(params);
  }
  // We want to mock this method
  _getExpiresDate() {
    const expiresDate = /* @__PURE__ */ new Date();
    expiresDate.setDate(expiresDate.getDate() + 1);
    return expiresDate.toISOString();
  }
  // Responsible for making API calls. Automatically sends streams with any POST,
  // PUT or DELETE requests. Automatically adds signature parameters to all
  // requests. Also automatically parses the JSON response.
  async _remoteJson(opts) {
    const { urlSuffix, url: urlInput, isTrustedUrl = false, timeout = { request: this._defaultTimeout }, method = "get", params = {}, fields, headers, signal } = opts;
    if (!urlSuffix && !urlInput)
      throw new Error("No URL provided");
    let url = urlInput || `${this._endpoint}${urlSuffix}`;
    if (urlInput && !isTrustedUrl) {
      const allowed = new URL(this._endpoint);
      const candidate = new URL(urlInput);
      if (allowed.origin !== candidate.origin) {
        throw new Error(`Untrusted URL: ${candidate.origin}`);
      }
    }
    if (method === "get") {
      url = this._appendParamsToUrl(url, params);
    }
    log2("Sending request", method, url);
    for (let retryCount = 0; ; retryCount++) {
      let form;
      if (method === "post" || method === "put" || method === "delete") {
        form = new import_form_data.default();
        this._appendForm(form, params, fields);
      }
      const requestOpts = {
        retry: this._gotRetry,
        body: form,
        timeout,
        headers: {
          "Transloadit-Client": this._clientName,
          "User-Agent": void 0,
          // Remove got's user-agent
          ...this._authToken ? { Authorization: `Bearer ${this._authToken}` } : {},
          ...headers
        },
        responseType: "json",
        signal
      };
      try {
        const request = source_default2[method](url, requestOpts);
        const { body } = await request;
        return body;
      } catch (err) {
        if (!(err instanceof RequestError))
          throw err;
        if (err instanceof HTTPError) {
          const { statusCode, body } = err.response;
          logWarn2("HTTP error", statusCode, body);
          const retryAfterHeader = err.response?.headers?.["retry-after"];
          const retryAfterSeconds = typeof retryAfterHeader === "string" ? Number(retryAfterHeader) : void 0;
          const retryInFromInfo = typeof body === "object" && body != null && "info" in body && typeof body.info === "object" && body.info != null && "retryIn" in body.info && typeof body.info.retryIn === "number" && body.info.retryIn > 0 ? body.info.retryIn : void 0;
          const retryInSec = retryInFromInfo ?? (typeof retryAfterSeconds === "number" && retryAfterSeconds > 0 ? retryAfterSeconds : void 0);
          const shouldRetry = retryCount < this._maxRetries && // 413 taken from https://transloadit.com/blog/2012/04/introducing-rate-limiting/
          // todo can 413 be removed?
          (statusCode === 413 && body && typeof body === "object" && body.error === "RATE_LIMIT_REACHED" || statusCode === 429);
          if (shouldRetry) {
            const retryDelaySec = retryInSec ?? 1;
            logWarn2(`Rate limit reached, retrying request in approximately ${retryDelaySec} seconds.`);
            const retryInMs = 1e3 * (retryDelaySec * (1 + 0.1 * Math.random()));
            await delay2(retryInMs);
          } else {
            throw new ApiError({
              cause: err,
              body: err.response?.body
            });
          }
        } else {
          throw err;
        }
      }
    }
  }
};

export {
  Transloadit
};
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

json-to-ast/build.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

tus-js-client/lib.es5/upload.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

tus-js-client/lib.es5/node/sources/FileSource.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

tus-js-client/lib.es5/node/sources/StreamSource.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=chunk-OGANR6MT.mjs.map
